
================================================================================
文件路径: backend_code_output.txt
--------------------------------------------------------------------------------


================================================================================
文件路径: backend_code_output.txt
--------------------------------------------------------------------------------


================================================================================
文件路径: backend_code_output.txt
--------------------------------------------------------------------------------


================================================================================
文件路径: backend_code_output.txt
--------------------------------------------------------------------------------


================================================================================
文件路径: backend_code_output.txt
--------------------------------------------------------------------------------


================================================================================
文件路径: python-backend\manage.py
--------------------------------------------------------------------------------

#!/usr/bin/env python
"""
Command-line utility for administrative tasks.

# For more information about this file, visit
# https://docs.djangoproject.com/en/2.1/ref/django-admin/
"""

import os
import sys

import django

if __name__ == '__main__':
    os.environ.setdefault(
        'DJANGO_SETTINGS_MODULE',
        'python_backend.settings')
    django.setup()

    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)



================================================================================
文件路径: python-backend\requirements.txt
--------------------------------------------------------------------------------

Django==5.2.8
asgiref==3.10.0
pip==25.0.1
psycopg2-binary==2.9.11
sqlparse==0.5.3
tzdata==2025.2
virtualenv==12.1.1
djangorestframework==3.15.2
markdown==3.7
django-filter==24.3
django-cors-headers==4.0.0


================================================================================
文件路径: python-backend\client\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\client\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class ClientConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'client'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\client\models.py
--------------------------------------------------------------------------------

from django.db import models

# Create your models here.



================================================================================
文件路径: python-backend\client\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\client\views.py
--------------------------------------------------------------------------------

from django.shortcuts import render

# Create your views here.
from rest_framework import viewsets, status

from rest_framework.decorators import action

from rest_framework.response import Response


================================================================================
文件路径: python-backend\client\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\client\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\core\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\core\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig

class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core'


================================================================================
文件路径: python-backend\core\context.py
--------------------------------------------------------------------------------

from core.models import *
from django.db.models import Q

class BaseContext:
    """基础 CRUD Context"""
    def __init__(self, model):
        self.model = model

    def get_by_id(self, pk):
        try:
            return self.model.objects.get(pk=pk)
        except self.model.DoesNotExist:
            return None

    def list_all(self):
        return self.model.objects.all()

    def create(self, **kwargs):
        return self.model.objects.create(**kwargs)

    def update(self, instance, **kwargs):
        for key, value in kwargs.items():
            setattr(instance, key, value)
        instance.save()
        return instance

    def delete(self, instance):
        instance.delete()


================================================================================
文件路径: python-backend\core\models.py
--------------------------------------------------------------------------------

from django.contrib.gis.db import models

# Create your models here.
class Admin(models.Model):
    account = models.CharField(unique=True, max_length=64)
    password = models.CharField(max_length=256)
    name = models.CharField(max_length=64, blank=True, null=True)

    class Meta:
        db_table = 'admin'
        # managed = False


class Building(models.Model):
    name = models.CharField(unique=True, max_length=64)
    address = models.CharField(max_length=256)
    description = models.CharField(max_length=256, blank=True, null=True)

    class Meta:
        db_table = 'building'
        # managed = False


class Event(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    description = models.CharField(max_length=256, blank=True, null=True)
    event_name = models.CharField(max_length=64)
    start_date = models.DateTimeField()
    end_date = models.DateTimeField()
    image_url = models.CharField(max_length=256, blank=True, null=True)

    class Meta:
        db_table = 'event'
        # managed = False


class EventEventarea(models.Model):
    pk = models.CompositePrimaryKey('event_id', 'eventarea_id')
    event = models.ForeignKey(Event, on_delete=models.CASCADE)
    eventarea = models.ForeignKey('Eventarea', on_delete=models.CASCADE)

    class Meta:
        db_table = 'event_eventarea'
        # managed = False
        # unique_together = (('event', 'eventarea'),)


class EventStorearea(models.Model):
    pk = models.CompositePrimaryKey('event_id', 'storearea_id')
    event = models.ForeignKey(Event, on_delete=models.CASCADE)
    storearea = models.ForeignKey('Storearea', on_delete=models.CASCADE)

    class Meta:
        db_table = 'event_storearea'
        # unique_together = (('event', 'storearea'),)
        # managed = False


class Eventarea(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    shape = models.PolygonField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    organizer_name = models.CharField(max_length=64)
    organizer_phone = models.CharField(max_length=16)
    type = models.IntegerField(blank=True, null=True)

    class Meta:
        db_table = 'eventarea'
        # managed = False


class EventareaMap(models.Model):
    pk = models.CompositePrimaryKey('eventarea_id', 'map_id')
    eventarea = models.ForeignKey(Eventarea, on_delete=models.CASCADE)
    map = models.ForeignKey('Map', on_delete=models.CASCADE)

    class Meta:
        db_table = 'eventarea_map'
        # unique_together = (('eventarea', 'map'),)
        # managed = False


class Facility(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    location = models.PointField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    type = models.IntegerField()

    class Meta:
        db_table = 'facility'
        # managed = False


class FacilityMap(models.Model):
    pk = models.CompositePrimaryKey('facility_id', 'map_id')
    facility = models.ForeignKey(Facility, on_delete=models.CASCADE)
    map = models.ForeignKey('Map', on_delete=models.CASCADE)

    class Meta:
        db_table = 'facility_map'
        # unique_together = (('facility', 'map'),)
        # managed = False


class Map(models.Model):
    building = models.ForeignKey(Building, models.CASCADE)
    floor_number = models.IntegerField()
    detail = models.GeometryCollectionField(srid=2385)

    class Meta:
        db_table = 'map'
        unique_together = (('building', 'floor_number'),)
        # managed = False


class Otherarea(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    shape = models.PolygonField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    type = models.IntegerField()
    is_public = models.BooleanField(blank=True, null=True)

    class Meta:
        db_table = 'otherarea'
        # managed = False


class OtherareaMap(models.Model):
    pk = models.CompositePrimaryKey('otherarea_id', 'map_id')
    otherarea = models.ForeignKey(Otherarea, on_delete=models.CASCADE)
    map = models.ForeignKey(Map, on_delete=models.CASCADE)

    class Meta:
        db_table = 'otherarea_map'
        # managed = False
        # unique_together = (('otherarea', 'map'),)


class Storearea(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    shape = models.PolygonField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    store_name = models.CharField(max_length=64)
    owner_name = models.CharField(max_length=64)
    owner_phone = models.CharField(max_length=16)
    logo_url = models.CharField(max_length=256, blank=True, null=True)
    open_time = models.TimeField(blank=True, null=True)
    close_time = models.TimeField(blank=True, null=True)
    type = models.IntegerField(blank=True, null=True)
    api_url = models.CharField(max_length=256, blank=True, null=True)

    class Meta:
        db_table = 'storearea'
        # managed = False


class StoreareaMap(models.Model):
    pk = models.CompositePrimaryKey('storearea_id', 'map_id')
    storearea = models.ForeignKey(Storearea, on_delete=models.CASCADE)
    map = models.ForeignKey(Map, on_delete=models.CASCADE)

    class Meta:
        db_table = 'storearea_map'
        # unique_together = (('storearea', 'map'),)
        # managed = False


================================================================================
文件路径: python-backend\core\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\core\views.py
--------------------------------------------------------------------------------

from django.shortcuts import render

# Create your views here.



================================================================================
文件路径: python-backend\core\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\core\migrations\0001_initial.py
--------------------------------------------------------------------------------

# Generated by Django 5.2.8 on 2025-12-10 02:55

import django.contrib.gis.db.models.fields
import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Admin',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('account', models.CharField(max_length=64, unique=True)),
                ('password', models.CharField(max_length=256)),
                ('name', models.CharField(blank=True, max_length=64, null=True)),
            ],
            options={
                'db_table': 'admin',
            },
        ),
        migrations.CreateModel(
            name='Building',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=64, unique=True)),
                ('address', models.CharField(max_length=256)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
            ],
            options={
                'db_table': 'building',
            },
        ),
        migrations.CreateModel(
            name='Event',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('event_name', models.CharField(max_length=64)),
                ('start_date', models.DateTimeField()),
                ('end_date', models.DateTimeField()),
                ('image_url', models.CharField(blank=True, max_length=256, null=True)),
            ],
            options={
                'db_table': 'event',
            },
        ),
        migrations.CreateModel(
            name='Eventarea',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('shape', django.contrib.gis.db.models.fields.PolygonField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('organizer_name', models.CharField(max_length=64)),
                ('organizer_phone', models.CharField(max_length=16)),
                ('type', models.IntegerField(blank=True, null=True)),
            ],
            options={
                'db_table': 'eventarea',
            },
        ),
        migrations.CreateModel(
            name='Facility',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('location', django.contrib.gis.db.models.fields.PointField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('type', models.IntegerField()),
            ],
            options={
                'db_table': 'facility',
            },
        ),
        migrations.CreateModel(
            name='Otherarea',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('shape', django.contrib.gis.db.models.fields.PolygonField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('type', models.IntegerField()),
                ('is_public', models.BooleanField(blank=True, null=True)),
            ],
            options={
                'db_table': 'otherarea',
            },
        ),
        migrations.CreateModel(
            name='Storearea',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('shape', django.contrib.gis.db.models.fields.PolygonField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('store_name', models.CharField(max_length=64)),
                ('owner_name', models.CharField(max_length=64)),
                ('owner_phone', models.CharField(max_length=16)),
                ('logo_url', models.CharField(blank=True, max_length=256, null=True)),
                ('open_time', models.TimeField(blank=True, null=True)),
                ('close_time', models.TimeField(blank=True, null=True)),
                ('type', models.IntegerField(blank=True, null=True)),
                ('api_url', models.CharField(blank=True, max_length=256, null=True)),
            ],
            options={
                'db_table': 'storearea',
            },
        ),
        migrations.CreateModel(
            name='EventEventarea',
            fields=[
                ('pk', models.CompositePrimaryKey('event_id', 'eventarea_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('event', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.event')),
                ('eventarea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.eventarea')),
            ],
            options={
                'db_table': 'event_eventarea',
            },
        ),
        migrations.CreateModel(
            name='Map',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('floor_number', models.IntegerField()),
                ('detail', django.contrib.gis.db.models.fields.GeometryCollectionField(srid=2385)),
                ('building', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.building')),
            ],
            options={
                'db_table': 'map',
                'unique_together': {('building', 'floor_number')},
            },
        ),
        migrations.CreateModel(
            name='FacilityMap',
            fields=[
                ('pk', models.CompositePrimaryKey('facility_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('facility', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.facility')),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
            ],
            options={
                'db_table': 'facility_map',
            },
        ),
        migrations.CreateModel(
            name='EventareaMap',
            fields=[
                ('pk', models.CompositePrimaryKey('eventarea_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('eventarea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.eventarea')),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
            ],
            options={
                'db_table': 'eventarea_map',
            },
        ),
        migrations.CreateModel(
            name='OtherareaMap',
            fields=[
                ('pk', models.CompositePrimaryKey('otherarea_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
                ('otherarea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.otherarea')),
            ],
            options={
                'db_table': 'otherarea_map',
            },
        ),
        migrations.CreateModel(
            name='EventStorearea',
            fields=[
                ('pk', models.CompositePrimaryKey('event_id', 'storearea_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('event', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.event')),
                ('storearea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.storearea')),
            ],
            options={
                'db_table': 'event_storearea',
            },
        ),
        migrations.CreateModel(
            name='StoreareaMap',
            fields=[
                ('pk', models.CompositePrimaryKey('storearea_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
                ('storearea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.storearea')),
            ],
            options={
                'db_table': 'storearea_map',
            },
        ),
    ]



================================================================================
文件路径: python-backend\core\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\editor\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\editor\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class EditorConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'editor'



================================================================================
文件路径: python-backend\editor\context.py
--------------------------------------------------------------------------------

from django.contrib.gis.geos import GEOSGeometry
from core.models import (
    Event,
    Storearea,
    StoreareaMap,
    EventStorearea,
    EventEventarea,
    Eventarea,
    EventareaMap,
    Otherarea,
    OtherareaMap,
)


class StoreareaContext:
    """
    店铺区域（Storearea）的数据访问层
    负责与数据库交互，仅提供shape属性相关的操作
    """

    @staticmethod
    def get_all():
        """获取所有店铺区域"""
        return Storearea.objects.all()

    @staticmethod
    def get_by_id(storearea_id):
        """根据ID获取店铺区域"""
        return Storearea.objects.filter(id=storearea_id).first()

    @staticmethod
    def create(shape, map_id=None):
        """创建新的店铺区域，并可选绑定到指定地图"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            # 这样无论是WKT还是GeoJSON格式，都会使用正确的SRID
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        storearea = Storearea.objects.create(shape=shape_geom)
        # 绑定到地图
        if map_id is not None:
            StoreareaMap.objects.create(storearea=storearea, map_id=map_id)
        return storearea

    @staticmethod
    def update_shape(storearea_id, shape):
        """更新店铺区域的形状"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        Storearea.objects.filter(id=storearea_id).update(shape=shape_geom)
        return StoreareaContext.get_by_id(storearea_id)

    @staticmethod
    def delete(storearea_id):
        """删除店铺区域"""
        Storearea.objects.filter(id=storearea_id).delete()

    @staticmethod
    def get_events_by_storearea(storearea_id):
        """获取店铺关联的所有活动ID"""
        event_relations = EventStorearea.objects.filter(storearea_id=storearea_id)
        return [relation.event_id for relation in event_relations]


class EventContext:
    """
    活动（Event）的数据访问层
    负责与数据库交互，仅提供shape属性相关的操作
    """

    @staticmethod
    def get_all():
        """获取所有活动"""
        return Event.objects.all()

    @staticmethod
    def get_by_id(event_id):
        """根据ID获取活动"""
        return Event.objects.filter(id=event_id).first()



    @staticmethod
    def get_storeareas_by_event(event_id):
        """获取活动关联的所有店铺区域ID"""
        storearea_relations = EventStorearea.objects.filter(event_id=event_id)
        return [relation.storearea_id for relation in storearea_relations]

    @staticmethod
    def get_eventareas_by_event(event_id):
        """获取活动关联的所有活动区域ID"""
        eventarea_relations = EventEventarea.objects.filter(event_id=event_id)
        return [relation.eventarea_id for relation in eventarea_relations]

    @staticmethod
    def add_storearea_relation(event_id, storearea_id):
        """添加活动与店铺区域的关联关系"""
        return EventStorearea.objects.get_or_create(event_id=event_id, storearea_id=storearea_id)

    @staticmethod
    def remove_storearea_relation(event_id, storearea_id):
        """移除活动与店铺区域的关联关系"""
        return EventStorearea.objects.filter(event_id=event_id, storearea_id=storearea_id).delete()

    @staticmethod
    def add_eventarea_relation(event_id, eventarea_id):
        """添加活动与活动区域的关联关系"""
        return EventEventarea.objects.get_or_create(event_id=event_id, eventarea_id=eventarea_id)

    @staticmethod
    def remove_eventarea_relation(event_id, eventarea_id):
        """移除活动与活动区域的关联关系"""
        return EventEventarea.objects.filter(event_id=event_id, eventarea_id=eventarea_id).delete()


class EventareaContext:
    """
    活动区域（Eventarea）的数据访问层
    负责与数据库交互，提供基本的CRUD操作
    """

    @staticmethod
    def get_all():
        """获取所有活动区域"""
        return Eventarea.objects.all()

    @staticmethod
    def get_by_id(eventarea_id):
        """根据ID获取活动区域"""
        return Eventarea.objects.filter(id=eventarea_id).first()

    @staticmethod
    def create(shape, map_id=None):
        """创建新的活动区域，并可选绑定到指定地图"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        eventarea = Eventarea.objects.create(shape=shape_geom)
        if map_id is not None:
            EventareaMap.objects.create(eventarea=eventarea, map_id=map_id)
        return eventarea

    @staticmethod
    def update_shape(eventarea_id, shape):
        """更新活动区域的形状"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        Eventarea.objects.filter(id=eventarea_id).update(shape=shape_geom)
        return EventareaContext.get_by_id(eventarea_id)

    @staticmethod
    def delete(eventarea_id):
        """删除活动区域"""
        Eventarea.objects.filter(id=eventarea_id).delete()


class OtherareaContext:
    """
    其他区域（Otherarea）的数据访问层
    负责与数据库交互，提供基本的CRUD操作
    """

    @staticmethod
    def get_all():
        """获取所有其他区域"""
        return Otherarea.objects.all()

    @staticmethod
    def get_by_id(otherarea_id):
        """根据ID获取其他区域"""
        return Otherarea.objects.filter(id=otherarea_id).first()

    @staticmethod
    def create(shape, map_id=None, type_val=None):
        """创建新的其他区域，并可选绑定到指定地图"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        otherarea = Otherarea.objects.create(
            shape=shape_geom,
            type=type_val if type_val is not None else 0  # 默认 0，避免 NOT NULL 约束报错
        )
        if map_id is not None:
            OtherareaMap.objects.create(otherarea=otherarea, map_id=map_id)
        return otherarea

    @staticmethod
    def update_shape(otherarea_id, shape):
        """更新其他区域的形状"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        Otherarea.objects.filter(id=otherarea_id).update(shape=shape_geom)
        return OtherareaContext.get_by_id(otherarea_id)

    @staticmethod
    def delete(otherarea_id):
        """删除其他区域"""
        Otherarea.objects.filter(id=otherarea_id).delete()



================================================================================
文件路径: python-backend\editor\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from django.apps import apps


def get_storearea_serializer():
    """获取 Storearea 序列化器"""
    Storearea = apps.get_model('core', 'Storearea')

    class StoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            fields = '__all__'
            # 由于使用了 managed=False，需要明确指定字段
            # 但 ModelSerializer 会自动从模型获取字段

    return StoreareaSerializer


def get_event_serializer():
    """获取 Event 序列化器"""
    Event = apps.get_model('core', 'Event')

    class EventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = '__all__'

    return EventSerializer


def get_eventarea_serializer():
    """获取活动区域序列化器"""
    Eventarea = apps.get_model('core', 'Eventarea')
    
    class EventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            fields = '__all__'
    
    return EventareaSerializer


def get_otherarea_serializer():
    """获取其他区域序列化器"""
    Otherarea = apps.get_model('core', 'Otherarea')
    
    class OtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            fields = '__all__'
    
    return OtherareaSerializer



================================================================================
文件路径: python-backend\editor\services.py
--------------------------------------------------------------------------------

from .context import StoreareaContext, EventContext, EventareaContext, OtherareaContext


class StoreareaService:
    """
    店铺区域（Storearea）的业务层
    负责处理业务逻辑，调用数据访问层方法，仅处理shape属性相关操作
    """

    @staticmethod
    def get_all_storeareas():
        """获取所有店铺区域"""
        return StoreareaContext.get_all()

    @staticmethod
    def get_storearea_by_id(storearea_id):
        """根据ID获取店铺区域"""
        return StoreareaContext.get_by_id(storearea_id)

    @staticmethod
    def create_storearea(shape, map_id=None):
        """创建新的店铺区域，并可选绑定到指定地图"""
        return StoreareaContext.create(shape, map_id)

    @staticmethod
    def update_shape(storearea_id, shape):
        """更新店铺区域的形状"""
        # 可以在这里添加业务逻辑验证
        return StoreareaContext.update_shape(storearea_id, shape)

    @staticmethod
    def delete_storearea(storearea_id):
        """删除店铺区域"""
        # 可以在这里添加业务逻辑验证
        return StoreareaContext.delete(storearea_id)

    @staticmethod
    def get_events_for_storearea(storearea_id):
        """获取店铺关联的所有活动ID"""
        return StoreareaContext.get_events_by_storearea(storearea_id)


class EventService:
    """
    活动（Event）的业务层
    负责处理业务逻辑，调用数据访问层方法，仅处理shape属性相关操作
    """

    @staticmethod
    def get_all_events():
        """获取所有活动"""
        return EventContext.get_all()

    @staticmethod
    def get_event_by_id(event_id):
        """根据ID获取活动"""
        return EventContext.get_by_id(event_id)



    @staticmethod
    def get_areas_for_event(event_id):
        """获取活动关联的所有区域ID（包括店铺区域和活动区域）"""
        storearea_ids = EventContext.get_storeareas_by_event(event_id)
        eventarea_ids = EventContext.get_eventareas_by_event(event_id)
        return {
            'storearea_ids': storearea_ids,
            'eventarea_ids': eventarea_ids,
            'all_area_ids': storearea_ids + eventarea_ids
        }

    @staticmethod
    def add_storearea_to_event(event_id, storearea_id):
        """添加活动与店铺区域的关联关系"""
        # 可以在这里添加业务逻辑验证（如检查活动和店铺是否存在等）
        return EventContext.add_storearea_relation(event_id, storearea_id)

    @staticmethod
    def remove_storearea_from_event(event_id, storearea_id):
        """移除活动与店铺区域的关联关系"""
        # 可以在这里添加业务逻辑验证
        return EventContext.remove_storearea_relation(event_id, storearea_id)

    @staticmethod
    def add_eventarea_to_event(event_id, eventarea_id):
        """添加活动与活动区域的关联关系"""
        # 可以在这里添加业务逻辑验证（如检查活动和活动区域是否存在等）
        return EventContext.add_eventarea_relation(event_id, eventarea_id)

    @staticmethod
    def remove_eventarea_from_event(event_id, eventarea_id):
        """移除活动与活动区域的关联关系"""
        # 可以在这里添加业务逻辑验证
        return EventContext.remove_eventarea_relation(event_id, eventarea_id)


class EventareaService:
    """
    活动区域（Eventarea）的业务层
    负责处理业务逻辑，调用数据访问层方法
    注意：在editor模块中只处理shape属性的更新
    """

    @staticmethod
    def get_all_eventareas():
        """获取所有活动区域"""
        return EventareaContext.get_all()

    @staticmethod
    def get_eventarea_by_id(eventarea_id):
        """根据ID获取活动区域"""
        return EventareaContext.get_by_id(eventarea_id)

    @staticmethod
    def create_eventarea(shape, map_id=None):
        """创建新的活动区域，并可选绑定到指定地图"""
        return EventareaContext.create(shape, map_id)

    @staticmethod
    def update_eventarea_shape(eventarea_id, shape):
        """更新活动区域的形状"""
        # 可以在这里添加业务逻辑验证（如形状有效性检查等）
        return EventareaContext.update_shape(eventarea_id, shape)

    @staticmethod
    def delete_eventarea(eventarea_id):
        """删除活动区域"""
        # 可以在这里添加业务逻辑验证
        return EventareaContext.delete(eventarea_id)


class OtherareaService:
    """
    其他区域（Otherarea）的业务层
    负责处理业务逻辑，调用数据访问层方法
    注意：在editor模块中只处理shape属性的更新
    """

    @staticmethod
    def get_all_otherareas():
        """获取所有其他区域"""
        return OtherareaContext.get_all()

    @staticmethod
    def get_otherarea_by_id(otherarea_id):
        """根据ID获取其他区域"""
        return OtherareaContext.get_by_id(otherarea_id)

    @staticmethod
    def create_otherarea(shape, map_id=None, type_val=None):
        """创建新的其他区域，并可选绑定到指定地图"""
        return OtherareaContext.create(shape, map_id, type_val)

    @staticmethod
    def update_otherarea_shape(otherarea_id, shape):
        """更新其他区域的形状"""
        # 可以在这里添加业务逻辑验证（如形状有效性检查等）
        return OtherareaContext.update_shape(otherarea_id, shape)

    @staticmethod
    def delete_otherarea(otherarea_id):
        """删除其他区域"""
        # 可以在这里添加业务逻辑验证
        return OtherareaContext.delete(otherarea_id)



================================================================================
文件路径: python-backend\editor\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\editor\urls.py
--------------------------------------------------------------------------------

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

# 创建路由器并注册视图集
router = DefaultRouter()
router.register(r'storearea', views.StoreareaViewSet, basename='editor_storearea')
router.register(r'event', views.EventViewSet, basename='editor_event')
router.register(r'eventarea', views.EventareaViewSet, basename='editor_eventarea')
router.register(r'otherarea', views.OtherareaViewSet, basename='editor_otherarea')

urlpatterns = [
    # 包含路由器生成的所有URL
    path('', include(router.urls)),
]




================================================================================
文件路径: python-backend\editor\views.py
--------------------------------------------------------------------------------

from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from django.shortcuts import get_object_or_404
from .serializers import get_storearea_serializer, get_event_serializer, get_eventarea_serializer, get_otherarea_serializer
from .services import StoreareaService, EventService, EventareaService, OtherareaService


class StoreareaViewSet(viewsets.ModelViewSet):
    """
    店铺区域（Storearea）的视图集
    
    注意：在editor模块中只处理shape属性的更新，其他属性在management中实现
    
    支持的操作：
    - GET /api/editor/storearea/ - 获取所有店铺区域列表
    - GET /api/editor/storearea/{id}/ - 获取指定店铺区域详情
    - POST /api/editor/storearea/ - 创建店铺区域（仅支持shape属性）
    - PATCH /api/editor/storearea/{id}/ - 部分更新店铺区域（仅支持shape属性）
    - DELETE /api/editor/storearea/{id}/ - 删除店铺区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_storearea_serializer()
    
    def get_queryset(self):
        """获取所有店铺区域"""
        return StoreareaService.get_all_storeareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有店铺区域列表"""
        storeareas = StoreareaService.get_all_storeareas()
        serializer = self.get_serializer(storeareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定店铺区域详情"""
        storearea = get_object_or_404(StoreareaService.get_all_storeareas(), pk=pk)
        serializer = self.get_serializer(storearea)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新店铺区域"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """部分更新店铺区域（仅支持shape属性）"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be updated in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        storearea = get_object_or_404(StoreareaService.get_all_storeareas(), pk=pk)
        shape = request.data.get('shape')
        
        updated_storearea = StoreareaService.update_shape(pk, shape)
        serializer = self.get_serializer(updated_storearea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建店铺区域（仅支持shape属性），并绑定到指定地图"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be provided when creating storearea in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        shape = request.data.get('shape')
        map_id = request.data.get('map_id')
        new_storearea = StoreareaService.create_storearea(shape, map_id)
        serializer = self.get_serializer(new_storearea)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    def destroy(self, request, pk=None):
        """删除店铺区域"""
        StoreareaService.delete_storearea(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)
    
    @action(detail=True, methods=['get'])
    def events(self, request, pk=None):
        """获取店铺关联的所有活动ID"""
        event_ids = StoreareaService.get_events_for_storearea(pk)
        return Response({
            'storearea_id': pk,
            'event_ids': event_ids
        })


class EventViewSet(viewsets.ModelViewSet):
    """
    活动（Event）的视图集
    
    注意：Event模型没有shape字段，因此不支持shape属性更新

    支持的操作：
    - GET /api/editor/event/ - 获取所有活动列表
    - GET /api/editor/event/{id}/ - 获取指定活动详情
    - GET /api/editor/event/{id}/areas/ - 获取活动关联的所有区域ID
    - POST/DELETE /api/editor/event/{id}/storeareas/ - 管理活动与店铺区域的关联关系
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_event_serializer()
    
    def get_queryset(self):
        """获取所有活动"""
        return EventService.get_all_events()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动列表"""
        events = EventService.get_all_events()
        serializer = self.get_serializer(events, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动详情"""
        event = get_object_or_404(EventService.get_all_events(), pk=pk)
        serializer = self.get_serializer(event)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新活动"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """不允许在editor模块中更新活动"""
        return Response(
            {'error': 'Update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def create(self, request, *args, **kwargs):
        """不允许在editor模块中创建活动"""
        return Response(
            {'error': 'Create not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def destroy(self, request, pk=None):
        """不允许在editor模块中删除活动"""
        return Response(
            {'error': 'Delete not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    @action(detail=True, methods=['get'])
    def areas(self, request, pk=None):
        """获取活动关联的所有区域ID（包括店铺区域和活动区域）"""
        areas = EventService.get_areas_for_event(pk)
        return Response({
            'event_id': pk,
            'storearea_ids': areas['storearea_ids'],
            'eventarea_ids': areas['eventarea_ids'],
            'all_area_ids': areas['all_area_ids']
        })
    
    @action(detail=True, methods=['post', 'delete'])
    def storeareas(self, request, pk=None):
        """管理活动与店铺区域的关联关系"""
        if request.method == 'POST':
            # 添加关联
            storearea_id = request.data.get('storearea_id')
            if not storearea_id:
                return Response(
                    {'error': 'storearea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            relation, created = EventService.add_storearea_to_event(pk, storearea_id)
            
            if created:
                return Response(
                    {'message': 'Relation created successfully'},
                    status=status.HTTP_201_CREATED
                )
            else:
                return Response(
                    {'message': 'Relation already exists'},
                    status=status.HTTP_200_OK
                )
        
        elif request.method == 'DELETE':
            # 删除关联
            storearea_id = request.data.get('storearea_id')
            if not storearea_id:
                return Response(
                    {'error': 'storearea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            deleted_count, _ = EventService.remove_storearea_from_event(pk, storearea_id)
            
            if deleted_count > 0:
                return Response(
                    {'message': 'Relation deleted successfully'},
                    status=status.HTTP_204_NO_CONTENT
                )
            else:
                return Response(
                    {'error': 'Relation not found'},
                    status=status.HTTP_404_NOT_FOUND
                )


class EventareaViewSet(viewsets.ModelViewSet):
    """
    活动区域（Eventarea）的视图集
    
    注意：在editor模块中只处理shape属性的更新，其他属性在management中实现
    
    支持的操作：
    - GET /api/editor/eventarea/ - 获取所有活动区域列表
    - GET /api/editor/eventarea/{id}/ - 获取指定活动区域详情
    - POST /api/editor/eventarea/ - 创建活动区域（仅支持shape属性）
    - PATCH /api/editor/eventarea/{id}/ - 部分更新活动区域（仅支持shape属性）
    - DELETE /api/editor/eventarea/{id}/ - 删除活动区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_eventarea_serializer()
    
    def get_queryset(self):
        """获取所有活动区域"""
        return EventareaService.get_all_eventareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动区域列表"""
        eventareas = EventareaService.get_all_eventareas()
        serializer = self.get_serializer(eventareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动区域详情"""
        eventarea = get_object_or_404(EventareaService.get_all_eventareas(), pk=pk)
        serializer = self.get_serializer(eventarea)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新活动区域"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """部分更新活动区域（仅支持shape属性）"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be updated in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        eventarea = get_object_or_404(EventareaService.get_all_eventareas(), pk=pk)
        shape = request.data.get('shape')
        
        updated_eventarea = EventareaService.update_eventarea_shape(pk, shape)
        serializer = self.get_serializer(updated_eventarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建活动区域（仅支持shape属性），并绑定到指定地图"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be provided when creating eventarea in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        shape = request.data.get('shape')
        map_id = request.data.get('map_id')
        new_eventarea = EventareaService.create_eventarea(shape, map_id)
        serializer = self.get_serializer(new_eventarea)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    def destroy(self, request, pk=None):
        """删除活动区域"""
        EventareaService.delete_eventarea(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)


class OtherareaViewSet(viewsets.ModelViewSet):
    """
    其他区域（Otherarea）的视图集
    
    注意：在editor模块中只处理shape属性的更新，其他属性在management中实现
    
    支持的操作：
    - GET /api/editor/otherarea/ - 获取所有其他区域列表
    - GET /api/editor/otherarea/{id}/ - 获取指定其他区域详情
    - POST /api/editor/otherarea/ - 创建其他区域（仅支持shape属性）
    - PATCH /api/editor/otherarea/{id}/ - 部分更新其他区域（仅支持shape属性）
    - DELETE /api/editor/otherarea/{id}/ - 删除其他区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_otherarea_serializer()
    
    def get_queryset(self):
        """获取所有其他区域"""
        return OtherareaService.get_all_otherareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有其他区域列表"""
        otherareas = OtherareaService.get_all_otherareas()
        serializer = self.get_serializer(otherareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定其他区域详情"""
        otherarea = get_object_or_404(OtherareaService.get_all_otherareas(), pk=pk)
        serializer = self.get_serializer(otherarea)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新其他区域"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """部分更新其他区域（仅支持shape属性）"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be updated in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        otherarea = get_object_or_404(OtherareaService.get_all_otherareas(), pk=pk)
        shape = request.data.get('shape')
        
        updated_otherarea = OtherareaService.update_otherarea_shape(pk, shape)
        serializer = self.get_serializer(updated_otherarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建其他区域（仅支持shape属性），并绑定到指定地图"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be provided when creating otherarea in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        shape = request.data.get('shape')
        map_id = request.data.get('map_id')
        type_val = request.data.get('type')
        new_otherarea = OtherareaService.create_otherarea(shape, map_id, type_val)
        serializer = self.get_serializer(new_otherarea)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    def destroy(self, request, pk=None):
        """删除其他区域"""
        OtherareaService.delete_otherarea(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)
    
    @action(detail=True, methods=['post', 'delete'])
    def eventareas(self, request, pk=None):
        """管理活动与活动区域的关联关系"""
        if request.method == 'POST':
            # 添加关联
            eventarea_id = request.data.get('eventarea_id')
            if not eventarea_id:
                return Response(
                    {'error': 'eventarea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            relation, created = EventService.add_eventarea_to_event(pk, eventarea_id)
            
            if created:
                return Response(
                    {'message': 'Relation created successfully'},
                    status=status.HTTP_201_CREATED
                )
            else:
                return Response(
                    {'message': 'Relation already exists'},
                    status=status.HTTP_200_OK
                )
        
        elif request.method == 'DELETE':
            # 删除关联
            eventarea_id = request.data.get('eventarea_id')
            if not eventarea_id:
                return Response(
                    {'error': 'eventarea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            deleted_count, _ = EventService.remove_eventarea_from_event(pk, eventarea_id)
            
            if deleted_count > 0:
                return Response(
                    {'message': 'Relation deleted successfully'},
                    status=status.HTTP_204_NO_CONTENT
                )
            else:
                return Response(
                    {'error': 'Relation not found'},
                    status=status.HTTP_404_NOT_FOUND
                )



================================================================================
文件路径: python-backend\editor\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\editor\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\guide\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\guide\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class GuideConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'guide'



================================================================================
文件路径: python-backend\guide\context.py
--------------------------------------------------------------------------------

from django.contrib.gis.geos import Polygon, Point
from typing import Tuple, List, Optional

# 导入所有涉及的模型
from core.models import Map, Storearea, Eventarea, Otherarea, Facility, StoreareaMap, EventareaMap, OtherareaMap, \
    FacilityMap


class GuideContext:  # 不继承 BaseContext
    """
    导航模块数据上下文
    职责：只负责从数据库提取几何数据，不负责路径计算逻辑
    """

    @staticmethod
    def get_map_geometry_data(map_id: int) -> Tuple[Optional[Polygon], List[Polygon], List[Polygon]]:
        """
        一次性获取地图的边界、原始镂空以及所有障碍物

        :param map_id: 地图 ID
        :return: (outer_shell, holes, obstacles)
        """
        # 1. 获取地图底图对象
        try:
            map_obj = Map.objects.get(pk=map_id)
        except Map.DoesNotExist:
            return None, [], []

        # 2. 解析地图底图 (GeometryCollection)
        # detail[0] 通常是地板外轮廓 (Polygon)
        # detail[1:] 是地板内部的镂空 (Polygon list)
        if not map_obj.detail or len(map_obj.detail) == 0:
            return None, [], []

        outer_shell = map_obj.detail[0]
        # 确保它是 Polygon，防止脏数据
        if not isinstance(outer_shell, Polygon):
            return None, [], []

        holes = []
        # 可能有镂空，也可能没有镂空
        if len(map_obj.detail) > 1:
            holes = list(map_obj.detail[1:])

        # 3. 获取所有业务层面的障碍物
        # 将所有障碍物统一合并到一个列表中返回
        obstacles = []

        # --- A. 获取商铺区域 (Polygon) ---
        stores = Storearea.objects.filter(
            storeareamap__map_id=map_id,
            shape__isnull=False
        ).values_list('shape', flat=True)
        obstacles.extend(stores)

        # --- B. 获取活动区域 (Polygon) ---
        events = Eventarea.objects.filter(
            eventareamap__map_id=map_id,
            shape__isnull=False
        ).values_list('shape', flat=True)
        obstacles.extend(events)

        # --- C. 获取其他区域 (Polygon) ---
        others = Otherarea.objects.filter(
            otherareamap__map_id=map_id,
            shape__isnull=False
        ).values_list('shape', flat=True)
        obstacles.extend(others)

        # --- D. 获取设施 (Point -> Polygon) ---
        facilities = Facility.objects.filter(
            facilitymap__map_id=map_id,
            location__isnull=False
        ).values_list('location', flat=True)
        # 将设施点膨胀后放入障碍物列表
        for point in facilities:
            # buffer(0.5) 表示以点为中心，半径 0.5 米的圆
            if isinstance(point, Point):
                obstacles.append(point.buffer(0.5))

        return outer_shell, holes, obstacles



================================================================================
文件路径: python-backend\guide\services.py
--------------------------------------------------------------------------------

# import networkx as nx
# from django.contrib.gis.geos import Point, LineString
# from map.context import MapContext
# from map.services import MapServices  # 复用校验逻辑
#
#
# class GuideService:
#
#     def __init__(self, map_id: int):
#         self.map_id = map_id
#         # 通过 Context 获取数据
#         self.outer_shell, self.holes = MapContext.get_map_geometry(map_id)
#         # 获取所有障碍物 (Map镂空 + 实体店铺 + 设施)
#         # 这里的 obstacles 是纯几何对象列表
#         self.obstacles = list(self.holes) + MapContext.get_all_obstacles(map_id)
#
#     # --- 接口 5: 完善导航接口 ---
#     def find_path(self, start_point: Point, end_point: Point):
#         """
#         计算单楼层内的两点路径
#         """
#         if not self.outer_shell:
#             return {"success": False, "message": "Map not initialized"}
#
#         # 0. 校验起终点合法性 (复用 MapService 的逻辑)
#         # 注意：这里我们假设 MapService 是无状态的工具类
#         valid_start, msg_start = MapService.check_area_placement(start_point, self.map_id)
#         # 对终点的检查可能需要放宽（因为终点可能就在店铺门口），这里暂时严格检查
#         valid_end, msg_end = MapService.check_area_placement(end_point, self.map_id)
#
#         if not valid_start:
#             return {"success": False, "message": f"Start point invalid: {msg_start}"}
#         # 如果终点是店铺，check_area_placement 会报错（因为和店铺重合），
#         # 实际逻辑中应该判断终点是否在障碍物内部，如果在内部，应该“弹出”到最近的可行走点。
#         # 此处简化，假设输入点已经处理过。
#
#         # 1. 构建可见性图 (Visibility Graph)
#         graph = nx.Graph()
#
#         # 节点包括：起点、终点、所有障碍物的顶点
#         nodes = [start_point, end_point]
#         for obs in self.obstacles:
#             # 获取多边形外环坐标 (去除最后一个重复点)
#             coords = obs.exterior.coords[:-1]
#             nodes.extend([Point(c, srid=2385) for c in coords])
#
#         # 2. 构建边
#         # 优化：仅在节点数较少时使用全连接 O(N^2)
#         node_ids = range(len(nodes))
#
#         for i in node_ids:
#             graph.add_node(i, pos=(nodes[i].x, nodes[i].y))
#
#         for i in node_ids:
#             for j in range(i + 1, len(nodes)):
#                 p1 = nodes[i]
#                 p2 = nodes[j]
#
#                 if self._is_line_of_sight_clear(p1, p2):
#                     dist = p1.distance(p2)
#                     graph.add_edge(i, j, weight=dist)
#
#         # 3. 计算 Dijkstra
#         try:
#             path_indices = nx.dijkstra_path(graph, source=0, target=1)
#             path_coords = [(nodes[i].x, nodes[i].y) for i in path_indices]
#
#             return {
#                 "success": True,
#                 "distance": nx.dijkstra_path_length(graph, source=0, target=1),
#                 "path": LineString(path_coords, srid=2385),
#                 "steps": path_coords
#             }
#         except nx.NetworkXNoPath:
#             return {
#                 "success": False,
#                 "message": "No walkable path found."
#             }
#
#     def _is_line_of_sight_clear(self, p1: Point, p2: Point) -> bool:
#         """
#         私有方法：判断视线是否被阻挡
#         """
#         line = LineString(p1, p2)
#
#         # 必须在外轮廓内
#         if not self.outer_shell.contains(line):
#             return False
#
#         # 不能穿过任何障碍物
#         for obstacle in self.obstacles:
#             # 使用 relation 或者 intersection 判断
#             if obstacle.intersects(line) and not obstacle.touches(line):
#                 return False
#         return True

from django.contrib.gis.geos import Point, LineString, Polygon
from typing import Tuple, List, Optional
import math
import heapq

# Context 导入
from guide.context import GuideContext


class GridSystem:
    """
    辅助类：网格系统类
    负责将世界坐标(Geo)转换为离散的网格坐标(Grid)
    并管理障碍物矩阵
    """

    def __init__(self, boundary_polygon: Polygon, resolution: float = 0.5):
        """
        :param boundary_polygon: 地图的外轮廓
        :param resolution: 网格精度，例如 0.5 表示每个网格格子 0.5x0.5 米
        """
        self.resolution = resolution
        self.boundary = boundary_polygon
        # 获取多边形 boundary_polygon 的最小最大坐标
        self.min_x, self.min_y, self.max_x, self.max_y = boundary_polygon.extent
        # 计算网格系统的 x方向、 y方向各自的格子总数
        self.width = int(math.ceil((self.max_x - self.min_x) / resolution))  # 这个方法 ceil 是向上取整
        self.height = int(math.ceil((self.max_y - self.min_y) / resolution))
        # 障碍物集合，存储不可行走的网格坐标元组 (gx, gy)
        self.obstacles = set()

    def world_to_grid(self, x: float, y: float) -> Tuple[int, int]:
        """将世界坐标转为网格坐标"""
        gx = int((x - self.min_x) / self.resolution)  # int() 是向下取整
        gy = int((y - self.min_y) / self.resolution)
        return gx, gy

    def grid_to_world(self, gx: int, gy: int) -> Tuple[float, float]:
        """将网格坐标中心转为世界坐标"""
        wx = self.min_x + (gx + 0.5) * self.resolution  # 这里是加上半格的意思，不是加上 0.5 米
        wy = self.min_y + (gy + 0.5) * self.resolution
        return wx, wy

    def mark_obstacles(self, geometry_list: List[Polygon]):
        """
        向 self.obstacles 集合中存储障碍物占据的格子坐标
        某个障碍物占据了哪些格子
        逆向思维：判断这个格子是否在这个障碍物多边形内
        """
        for poly in geometry_list:
            # 1. 性能优化：不要扫描全图，只扫描障碍物所在的那个矩形区域（Bounding Box）
            # poly.extent 返回 (min_x, min_y, max_x, max_y)
            min_x, min_y, max_x, max_y = poly.extent

            # 2. 把这个矩形区域的四个角，转换成网格坐标
            # min_gx, min_gy 是左下角格子的索引
            # max_gx, max_gy 是右上角格子的索引
            min_gx, min_gy = self.world_to_grid(min_x, min_y)
            max_gx, max_gy = self.world_to_grid(max_x, max_y)

            # 3. 修正边界，防止算出负数或者超出地图宽度的索引
            min_gx = max(0, min_gx)
            min_gy = max(0, min_gy)
            max_gx = min(self.width, max_gx + 1)  # +1 是为了保证循环能覆盖到边缘
            max_gy = min(self.height, max_gy + 1)

            # 4. 循环遍历这个小区域内的每一个格子
            for gx in range(min_gx, max_gx):
                for gy in range(min_gy, max_gy):
                    # 算出这个格子中心点在地图上的真实坐标 (wx, wy)
                    wx, wy = self.grid_to_world(gx, gy)

                    # 创建一个临时的点对象
                    cell_center = Point(wx, wy, srid=2385)

                    # 5. 关键判断：如果这个格子的中心点碰到了障碍物，这个格子就是不可走的
                    # intersects() 表示“相交”或“重叠”
                    if poly.intersects(cell_center):
                        self.obstacles.add((gx, gy))

    def is_walkable(self, gx: int, gy: int) -> bool:
        """检查网格点是否在地图内且不是障碍物"""
        # 1. 数组边界检查，严格小于 self.width，因为 self.width 是上取整
        if not (0 <= gx < self.width and 0 <= gy < self.height):
            return False
        # 2. 障碍物检查
        if (gx, gy) in self.obstacles:
            return False
        # 3. 地图边界检查
        # 算出这个格子中心的真实世界坐标
        wx, wy = self.grid_to_world(gx, gy)
        # 构造一个临时的点对象
        point = Point(wx, wy, srid=2385)
        # contains() 表示如果点在多边形内部返回 True，在外部返回 False
        if not self.boundary.contains(point):
            return False

        return True


class RoutePlanService:
    """
    路径规划业务服务层
    """

    def __init__(self):
        # 创建上下文对象
        self.ctx = GuideContext()

    def validate_request_params(self, map_id, start_data, end_data) -> Tuple[bool, str]:
        """
        在View中使用的，对Request请求参数的校验逻辑
        """
        # 1. 必填项校验
        if map_id is None:
            return False, "Missing parameter: map_id"
        if not start_data or not end_data:
            return False, "Missing parameter: start or end coordinates"

        # 2. 字典结构校验
        if not isinstance(start_data, dict) or not isinstance(end_data, dict):
            return False, "Coordinates must be JSON objects with x and y"

        # 3. 坐标数值校验
        try:
            float(start_data.get('x'))
            float(start_data.get('y'))
            float(end_data.get('x'))
            float(end_data.get('y'))
        except (ValueError, TypeError):
            return False, "Coordinates x and y must be valid numbers"

        return True, "Request params are valid"

    def calculate_route(self, map_id: int, start_pt: Point, end_pt: Point) -> Optional[LineString]:
        """
        主入口：计算路径
        """
        # 1. 获取地图几何数据 (调用 Context)
        # 期望返回:
        # outer_shell: Polygon (地图地板轮廓)
        # holes: List[Polygon] (地图本身镂空)
        # obstacles: List[Geometry] (商铺、活动区、其他区域、膨胀后的设施)
        outer_shell, holes, obstacles = self.ctx.get_map_geometry_data(map_id)

        if not outer_shell:
            raise ValueError(f"Map #{map_id} outer_shell missing")

        # 2. 初始化网格系统 (Grid System)
        # 设定分辨率为 0.5 米 (可根据性能需求调整)
        grid_sys = GridSystem(outer_shell, resolution=0.5)

        # 3. 网格化障碍物
        # 将 holes 和 obstacles 合并处理
        all_obstacles = holes + obstacles
        grid_sys.mark_obstacles(all_obstacles)

        # 4. 起点、终点坐标转换
        start_node = grid_sys.world_to_grid(start_pt.x, start_pt.y)
        end_node = grid_sys.world_to_grid(end_pt.x, end_pt.y)

        # 5. 校验起终点有效性
        if not grid_sys.is_walkable(*start_node):
            raise ValueError("Start node is not walkable")
        if not grid_sys.is_walkable(*end_node):
            raise ValueError("End node is not walkable")

        # 6. 执行 A* 算法，返回网格坐标的列表
        path_nodes = self._run_astar(start_node, end_node, grid_sys)

        if not path_nodes:
            return None

        # 7. 结果转换 (Grid Nodes -> Geo LineString)
        # 将网格路径转回世界坐标的折线
        return self._construct_linestring(path_nodes, grid_sys)

    def _run_astar(self, start_node: Tuple[int, int], end_node: Tuple[int, int], grid: GridSystem) \
            -> List[Tuple[int, int]]:
        """
        A* 算法核心逻辑
        :param start_node: (gx, gy) 起点
        :param end_node: (gx, gy) 终点
        :param grid: 网格系统对象，用于判断可行走性
        :return: [(x1, y1), (x2, y2), ...] 路径列表，如果找不到路径返回 None
        """
        # 1. 初始化 open_set (优先队列)，存放 (f_score, node)，可能的扩展节点
        # f_score = g_score + h_score
        open_set = []
        heapq.heappush(open_set, (0, start_node))

        # 2. 初始化记录字典
        # came_from: 记录路径回溯，key=当前节点, value=父节点
        came_from = {}

        # g_score: 从起点到当前节点的实际代价。默认无穷大。
        g_score = {start_node: 0.0}

        # f_score: 预估总代价。默认无穷大。
        # f_score[start_node] = h(start_node, end)
        f_score = {start_node: self._heuristic(start_node, end_node)}

        # 定义移动方向和对应的代价
        # (dx, dy, cost)
        sqrt2 = math.sqrt(2)
        movements = [
            (0, 1, 1.0), (0, -1, 1.0), (1, 0, 1.0), (-1, 0, 1.0),  # 上下右左
            (1, 1, sqrt2), (1, -1, sqrt2), (-1, 1, sqrt2), (-1, -1, sqrt2)  # 对角线
        ]

        # 3. 主循环，当 open_set 非空
        while open_set:
            # 取出 f_score 最小的节点
            current_f, current = heapq.heappop(open_set)

            # --- 成功到达终点 ---
            if current == end_node:
                return self._reconstruct_path(came_from, current)

            # 遍历 8 个邻居
            for dx, dy, move_cost in movements:
                neighbor = (current[0] + dx, current[1] + dy)

                # --- 核心判断：如果邻居不可走则跳过 ---
                if not grid.is_walkable(*neighbor):
                    continue

                # 计算经过当前节点到达邻居的 tentative_g (临时G值)
                tentative_g = g_score[current] + move_cost

                # 如果临时G值小于该邻居之前的G值，或者之前没访问过该邻居 (字典里找不到 neighbor 这个 key，就返回 inf)
                if tentative_g < g_score.get(neighbor, float('inf')):
                    # 更新记录
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g

                    # 计算 f 值 = g + h
                    new_f = tentative_g + self._heuristic(neighbor, end_node)
                    f_score[neighbor] = new_f

                    # 加入优先队列等待处理
                    heapq.heappush(open_set, (new_f, neighbor))

        # 循环结束仍未找到终点
        return None

    def _reconstruct_path(self, came_from: dict, current: Tuple[int, int]) -> List[Tuple[int, int]]:
        """
        私有辅助方法：从终点回溯到起点，重建路径
        """
        total_path = [current]
        while current in came_from:
            current = came_from[current]
            total_path.append(current)

        # 因为是从终点往回找的，所以要反转列表
        return total_path[::-1]

    def _heuristic(self, node_a: Tuple[int, int], node_b: Tuple[int, int]) -> float:
        """
        启发函数 (对角距离)
        """
        delta_x = abs(node_a[0] - node_b[0])
        delta_y = abs(node_a[1] - node_b[1])
        h_value = delta_x + delta_y + (math.sqrt(2) - 2) * min(delta_x, delta_y)
        return h_value

    def _construct_linestring(self, path_nodes: List[Tuple[int, int]], grid: GridSystem) -> LineString:
        """
        将网格节点序列转换为 PostGIS LineString 对象
        """
        points = []
        for gx, gy in path_nodes:
            wx, wy = grid.grid_to_world(gx, gy)
            points.append((wx, wy))

        return LineString(points, srid=2385)



================================================================================
文件路径: python-backend\guide\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase
from unittest.mock import MagicMock, patch
from django.contrib.gis.geos import Polygon, Point, LineString
from guide.services import RoutePlanService, GridSystem
from rest_framework.test import APITestCase
from rest_framework import status
from django.contrib.gis.geos import Polygon, GeometryCollection, Point
from core.models import Map, Building, Storearea, StoreareaMap


class GridSystemTestCase(TestCase):
    """
    测试 GridSystem 类的底层逻辑 (坐标转换、障碍物标记、边界检查)
    """

    def setUp(self):
        # 创建一个 10x10 的正方形地图 (SRID=2385)
        # 坐标范围: (0,0) -> (10,10)
        self.boundary = Polygon(((0, 0), (0, 10), (10, 10), (10, 0), (0, 0)), srid=2385)
        # 分辨率设为 1.0 米，方便计算 (网格大小 10x10)
        self.grid = GridSystem(self.boundary, resolution=1.0)

    def test_coordinate_conversion(self):
        """测试世界坐标与网格坐标的相互转换"""
        # 测试 world_to_grid (向下取整)
        # 坐标 (1.5, 1.5) 应该落在 (1, 1) 格子
        gx, gy = self.grid.world_to_grid(1.5, 1.5)
        self.assertEqual((gx, gy), (1, 1))

        # 测试 grid_to_world (取中心点)
        # 格子 (1, 1) 的中心应该是 (1.5, 1.5)
        wx, wy = self.grid.grid_to_world(1, 1)
        self.assertEqual((wx, wy), (1.5, 1.5))

    def test_mark_obstacles(self):
        """测试障碍物栅格化逻辑"""
        # 创建一个位于地图中心的障碍物 (4,4) 到 (6,6)
        obstacle = Polygon(((4, 4), (4, 6), (6, 6), (6, 4), (4, 4)), srid=2385)

        self.grid.mark_obstacles([obstacle])

        # 检查障碍物内部的点 (5, 5) -> 不可走
        self.assertFalse(self.grid.is_walkable(5, 5))

        # 检查障碍物边缘的点 (网格化后可能会占据边缘)
        # (4, 4) 根据 intersects 判定通常会被占据
        self.assertFalse(self.grid.is_walkable(4, 4))

        # 检查开阔区域的点 (1, 1) -> 可走
        self.assertTrue(self.grid.is_walkable(1, 1))

    def test_boundary_check_complex_shape(self):
        """
        测试不规则形状地图的边界检查 (L型地图)
        验证 is_walkable 中的 boundary.contains 逻辑
        """
        # 创建一个 L 型多边形 (缺口在右上角)
        # (0,0) -> (0,10) -> (5,10) -> (5,5) -> (10,5) -> (10,0) -> (0,0)
        l_shape_wkt = "POLYGON((0 0, 0 10, 5 10, 5 5, 10 5, 10 0, 0 0))"
        l_shape = Polygon.from_ewkt(l_shape_wkt)
        l_shape.srid = 2385

        grid = GridSystem(l_shape, resolution=1.0)

        # 1. 测试在地图内的点 (2, 2)
        self.assertTrue(grid.is_walkable(2, 2))

        # 2. 测试在 L 型缺口处的点 (8, 8)
        # 虽然 (8, 8) 在 GridSystem 的数组索引范围内 (width=10, height=10)
        # 但它在物理上位于大楼外部
        self.assertFalse(grid.is_walkable(8, 8))


class RoutePlanServiceTestCase(TestCase):
    """
    测试 A* 算法服务层逻辑
    使用 Mock 屏蔽 Context/数据库 操作
    """

    def setUp(self):
        self.service = RoutePlanService()
        # 基础地图: 20x20 米的正方形
        self.map_boundary = Polygon(((0, 0), (0, 20), (20, 20), (20, 0), (0, 0)), srid=2385)

    @patch('guide.services.GuideContext')
    def test_simple_straight_path(self, MockContext):
        """测试无障碍物的直线路径"""
        # --- Mock 设置 ---
        mock_ctx_instance = MockContext.return_value
        # 返回: (外框, 镂空[], 障碍物[])
        mock_ctx_instance.get_map_geometry_data.return_value = (self.map_boundary, [], [])

        # 替换 service 中的 ctx
        self.service.ctx = mock_ctx_instance

        # --- 执行测试 ---
        start = Point(2, 2, srid=2385)
        end = Point(18, 18, srid=2385)

        # 运行算法
        route = self.service.calculate_route(map_id=1, start_pt=start, end_pt=end)

        # --- 断言 ---
        self.assertIsInstance(route, LineString)
        # 直线距离约为 22.62 米
        # A* 也是走的对角线，长度应该非常接近直线距离
        self.assertAlmostEqual(route.length, start.distance(end), delta=1.0)

    @patch('guide.services.GuideContext')
    def test_obstacle_avoidance(self, MockContext):
        """测试绕行逻辑：起点和终点中间有一堵墙，必须从缺口绕过去"""
        # --- Mock 设置 ---
        mock_ctx_instance = MockContext.return_value

        # 定义障碍物：一堵带缺口的墙
        # 墙的范围：y轴 9到11，x轴 5到20。
        # 这意味着 x轴 0到5 的区域是空的（缺口），路径只能从这里通过。
        wall_with_gap = Polygon(((5, 9), (5, 11), (20, 11), (20, 9), (5, 9)), srid=2385)

        # 模拟 Context 返回：地图边界、无镂空、以及上面定义的障碍物
        mock_ctx_instance.get_map_geometry_data.return_value = (
            self.map_boundary,
            [],
            [wall_with_gap]
        )
        self.service.ctx = mock_ctx_instance

        # --- 执行测试 ---
        # 起点(10, 2) -> 终点(10, 18)
        # 直线连线会被墙挡住 (墙在 y=9~11, x=5~20)
        start = Point(10, 2, srid=2385)
        end = Point(10, 18, srid=2385)

        route = self.service.calculate_route(1, start, end)

        # --- 断言 ---
        self.assertIsNotNone(route)

        # 1. 验证路径长度：肯定大于直线距离 (16米)
        # 直线距离 = 18 - 2 = 16
        self.assertTrue(route.length > 16.0)

        # 2. 验证路径走向：必须经过左侧缺口
        # 获取路径上所有点的 x 坐标
        coords = route.coords
        min_x_in_path = min(p[0] for p in coords)

        # 因为墙是从 x=5 开始的，所以要想过去，路径中至少有一个点的 x 必须小于 5 (或者接近 5)
        # 我们这里断言 < 6.0 是为了留一点网格化精度的余量
        self.assertLess(min_x_in_path, 6.0)

    @patch('guide.services.GuideContext')
    def test_unreachable_target(self, MockContext):
        """测试终点被完全包围无法到达的情况"""
        mock_ctx_instance = MockContext.return_value

        # 障碍物完全包围终点 (10, 10)
        box = Polygon(((8, 8), (8, 12), (12, 12), (12, 8), (8, 8)), srid=2385)

        mock_ctx_instance.get_map_geometry_data.return_value = (self.map_boundary, [], [box])
        self.service.ctx = mock_ctx_instance

        start = Point(2, 2, srid=2385)
        end = Point(10, 10, srid=2385)  # 在盒子里面

        # 预期抛出 ValueError (因为 End node is not walkable)
        # 或者如果 End node 勉强算 walkable 但无法到达，则返回 None
        # 根据 services.py 逻辑，先检查 is_walkable

        # 由于障碍物占位，End point 所在的网格会被标记为 obstacle
        with self.assertRaises(ValueError) as cm:
            self.service.calculate_route(1, start, end)

        self.assertIn("End node is not walkable", str(cm.exception))


class GuideIntegrationTestCase(APITestCase):
    """
    第二步：集成测试
    测试 Views -> Services -> Context -> DB 的完整链路
    """

    def setUp(self):
        # 1. 创建基础建筑 (外键依赖)
        self.building = Building.objects.create(
            name="Test Mall",
            address="123 Test St"
        )

        # 2. 创建地图 (Map)
        # 地图是一个 20x20 的正方形
        # 注意：Map 的 detail 字段是 GeometryCollection
        boundary = Polygon(((0, 0), (0, 20), (20, 20), (20, 0), (0, 0)), srid=2385)
        gc = GeometryCollection(boundary, srid=2385)

        self.map_obj = Map.objects.create(
            building=self.building,
            floor_number=1,
            detail=gc
        )

        # 3. 创建一个商铺 (障碍物)
        # 商铺挡在地图中间 (8,8) 到 (12,12)
        store_shape = Polygon(((8, 8), (8, 12), (12, 12), (12, 8), (8, 8)), srid=2385)
        self.store = Storearea.objects.create(
            store_name="Blocker Store",
            owner_name="Test Owner",
            owner_phone="123",
            shape=store_shape,
            is_active=True  # 确保是激活状态
        )

        # 4. 关联商铺和地图 (建立中间表关系)
        # 注意：根据你的 models.py，StoreareaMap 有两个外键
        StoreareaMap.objects.create(
            storearea=self.store,
            map=self.map_obj
        )

        # API URL (需要你在 urls.py 中配置好，这里假设路径是 /api/guide/route/)
        self.url = '/api/guide/route/'

    def test_route_api_success(self):
        """测试完整的 API 调用流程"""
        # 起点 (2,2)，终点 (18,18)
        # 中间有商铺挡路，应该能规划出路径
        payload = {
            "map_id": self.map_obj.id,
            "start": {"x": 2.0, "y": 2.0},
            "end": {"x": 18.0, "y": 18.0}
        }

        response = self.client.post(self.url, payload, format='json')

        # 1. 验证状态码 200
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        # 2. 验证返回数据结构
        data = response.data
        self.assertIn("route", data)
        self.assertIn("distance", data)
        self.assertIsInstance(data["route"], dict)  # GeoJSON 对象
        self.assertIsInstance(data["route"]["coordinates"], list)

        # 3. 验证距离是否合理 (直线约22米，绕路肯定大于22米)
        self.assertTrue(data["distance"] > 22.0)

        # 打印一下结果看看
        print(f"\n[Integration Test] Route Distance: {data['distance']} meters")

    def test_api_missing_params(self):
        """测试参数缺失情况"""
        payload = {"map_id": self.map_obj.id}  # 缺少 start/end
        response = self.client.post(self.url, payload, format='json')
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

    def test_api_invalid_coordinates(self):
        """测试无效坐标 (起点在墙里)"""
        # 起点 (10, 10) 正好在刚才创建的 Storearea 内部
        payload = {
            "map_id": self.map_obj.id,
            "start": {"x": 10.0, "y": 10.0},
            "end": {"x": 18.0, "y": 18.0}
        }
        response = self.client.post(self.url, payload, format='json')

        # 预期报错：Start node is not walkable
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn("error", response.data)


================================================================================
文件路径: python-backend\guide\views.py
--------------------------------------------------------------------------------

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.contrib.gis.geos import Point
import json

# 导入服务类
from .services import RoutePlanService


class RoutePlanView(APIView):
    """
    POST /api/guide/route/
    接收起点终点坐标，返回路径规划结果
    """
    service_class = RoutePlanService

    def post(self, request):
        service = self.service_class()

        # 读取前端传参
        # 前端传参示例: {"map_id": 1, "start": {"x": 10.0, "y": 20.0}, "end": {"x": 50.0, "y": 60.0}}
        map_id = request.data.get('map_id')
        start_data = request.data.get('start')
        end_data = request.data.get('end')

        # 这一步负责检查参数是否存在、格式是否正确、坐标是否可转换为浮点数
        # 我们不需要在这里写 if-else，全交给 Service
        is_valid, error_msg = service.validate_request_params(map_id, start_data, end_data)

        if not is_valid:
            return Response({"error": error_msg}, status=status.HTTP_400_BAD_REQUEST)

        try:
            # 经过上面的校验，这里可以放心转换，不用担心 KeyError 或 TypeError
            start_point = Point(float(start_data['x']), float(start_data['y']), srid=2385)
            end_point = Point(float(end_data['x']), float(end_data['y']), srid=2385)

        except Exception as e:
            # 极端异常情况
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)

        try:
            # 预期 service 返回一个 LineString 对象
            route_geometry = service.calculate_route(map_id, start_point, end_point)

            if not route_geometry:
                return Response({"error": "Route not found or unreachable"}, status=status.HTTP_404_NOT_FOUND)

            # 构造返回
            response_data = {
                # json.loads(route_geometry.geojson) 将 GeoJSON 字符串转为 Python 字典/列表
                "route": json.loads(route_geometry.geojson),
                # route_geometry.length 自动计算米制长度，然后保留 2 位小数
                "distance": round(route_geometry.length, 2)
            }

            return Response(response_data)

        except Exception as e:
            # 捕获如算法内部抛出的业务异常
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)


================================================================================
文件路径: python-backend\guide\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\guide\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\management\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\management\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class ManagementConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'management'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\management\context.py
--------------------------------------------------------------------------------

from core.models import Eventarea, Otherarea, Event, Storearea, Facility,Admin
from core.context import BaseContext

class EventareaContext:
    """
    活动区域（Eventarea）的数据访问层
    
    提供与Eventarea模型相关的数据操作方法
    """
    
    @staticmethod
    def get_all_eventareas():
        """
        获取所有活动区域
        
        Returns:
            QuerySet: 活动区域的查询集
        """
        return Eventarea.objects.all()
    
    @staticmethod
    def get_eventarea_by_id(eventarea_id):
        """
        根据ID获取活动区域
        
        Args:
            eventarea_id: 活动区域ID
        
        Returns:
            Eventarea: 活动区域对象
        """
        return Eventarea.objects.get(id=eventarea_id)
    
    @staticmethod
    def create_eventarea(data):
        """
        创建新的活动区域
        
        Args:
            data: 活动区域数据
        
        Returns:
            Eventarea: 创建的活动区域对象
        """
        return Eventarea.objects.create(**data)
    
    @staticmethod
    def update_eventarea(eventarea_id, data):
        """
        更新活动区域
        
        Args:
            eventarea_id: 活动区域ID
            data: 更新数据
        
        Returns:
            Eventarea: 更新后的活动区域对象
        """
        eventarea = Eventarea.objects.get(id=eventarea_id)
        for key, value in data.items():
            setattr(eventarea, key, value)
        eventarea.save()
        return eventarea
    
    @staticmethod
    def delete_eventarea(eventarea_id):
        """
        删除活动区域
        
        Args:
            eventarea_id: 活动区域ID
        """
        Eventarea.objects.filter(id=eventarea_id).delete()


class EventContext:
    """
    活动（Event）的数据访问层
    
    提供与Event模型相关的数据操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """
    
    @staticmethod
    def get_all_events():
        """
        获取所有活动
        
        Returns:
            QuerySet: 活动的查询集
        """
        return Event.objects.all()
    
    @staticmethod
    def get_event_by_id(event_id):
        """
        根据ID获取活动
        
        Args:
            event_id: 活动ID
        
        Returns:
            Event: 活动对象
        """
        return Event.objects.get(id=event_id)
    
    @staticmethod
    def create_event(data):
        """
        创建新的活动
        
        Args:
            data: 活动数据
        
        Returns:
            Event: 创建的活动对象
        """
        return Event.objects.create(**data)
    
    @staticmethod
    def update_event(event_id, data):
        """
        更新活动
        
        Args:
            event_id: 活动ID
            data: 更新数据
        
        Returns:
            Event: 更新后的活动对象
        """
        event = Event.objects.get(id=event_id)
        for key, value in data.items():
            setattr(event, key, value)
        event.save()
        return event
    
    @staticmethod
    def delete_event(event_id):
        """
        删除活动
        
        Args:
            event_id: 活动ID
        """
        Event.objects.filter(id=event_id).delete()


class StoreareaContext:
    """
    店铺区域（Storearea）的数据访问层
    
    提供与Storearea模型相关的数据操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """
    
    @staticmethod
    def get_all_storeareas():
        """
        获取所有店铺区域
        
        Returns:
            QuerySet: 店铺区域的查询集
        """
        return Storearea.objects.all()
    
    @staticmethod
    def get_storearea_by_id(storearea_id):
        """
        根据ID获取店铺区域
        
        Args:
            storearea_id: 店铺区域ID
        
        Returns:
            Storearea: 店铺区域对象
        """
        return Storearea.objects.get(id=storearea_id)
    
    @staticmethod
    def create_storearea(data):
        """
        创建新的店铺区域
        
        Args:
            data: 店铺区域数据
        
        Returns:
            Storearea: 创建的店铺区域对象
        """
        return Storearea.objects.create(**data)
    
    @staticmethod
    def update_storearea(storearea_id, data):
        """
        更新店铺区域
        
        Args:
            storearea_id: 店铺区域ID
            data: 更新数据
        
        Returns:
            Storearea: 更新后的店铺区域对象
        """
        storearea = Storearea.objects.get(id=storearea_id)
        for key, value in data.items():
            setattr(storearea, key, value)
        storearea.save()
        return storearea
    
    @staticmethod
    def delete_storearea(storearea_id):
        """
        删除店铺区域
        
        Args:
            storearea_id: 店铺区域ID
        """
        Storearea.objects.filter(id=storearea_id).delete()


class OtherareaContext:
    """
    其他区域（Otherarea）的数据访问层
    
    提供与Otherarea模型相关的数据操作方法
    """
    
    @staticmethod
    def get_all_otherareas():
        """
        获取所有其他区域
        
        Returns:
            QuerySet: 其他区域的查询集
        """
        return Otherarea.objects.all()
    
    @staticmethod
    def get_otherarea_by_id(otherarea_id):
        """
        根据ID获取其他区域
        
        Args:
            otherarea_id: 其他区域ID
        
        Returns:
            Otherarea: 其他区域对象
        """
        return Otherarea.objects.get(id=otherarea_id)
    
    @staticmethod
    def create_otherarea(data):
        """
        创建新的其他区域
        
        Args:
            data: 其他区域数据
        
        Returns:
            Otherarea: 创建的其他区域对象
        """
        return Otherarea.objects.create(**data)
    
    @staticmethod
    def update_otherarea(otherarea_id, data):
        """
        更新其他区域
        
        Args:
            otherarea_id: 其他区域ID
            data: 更新数据
        
        Returns:
            Otherarea: 更新后的其他区域对象
        """
        otherarea = Otherarea.objects.get(id=otherarea_id)
        for key, value in data.items():
            setattr(otherarea, key, value)
        otherarea.save()
        return otherarea
    
    @staticmethod
    def delete_otherarea(otherarea_id):
        """
        删除其他区域
        
        Args:
            otherarea_id: 其他区域ID
        """
        Otherarea.objects.filter(id=otherarea_id).delete()


class FacilityContext:
    """
    设施（Facility）的数据访问层
    
    提供与Facility模型相关的数据操作方法
    注意：location属性由editor模块处理
    """
    
    @staticmethod
    def get_all_facilities():
        """
        获取所有设施
        
        Returns:
            QuerySet: 设施的查询集
        """
        return Facility.objects.all()
    
    @staticmethod
    def get_facility_by_id(facility_id):
        """
        根据ID获取设施
        
        Args:
            facility_id: 设施ID
        
        Returns:
            Facility: 设施对象
        """
        return Facility.objects.get(id=facility_id)
    
    @staticmethod
    def create_facility(data):
        """
        创建新的设施
        
        Args:
            data: 设施数据
        
        Returns:
            Facility: 创建的设施对象
        """
        return Facility.objects.create(**data)
    
    @staticmethod
    def update_facility(facility_id, data):
        """
        更新设施
        
        Args:
            facility_id: 设施ID
            data: 更新数据
        
        Returns:
            Facility: 更新后的设施对象
        """
        facility = Facility.objects.get(id=facility_id)
        for key, value in data.items():
            setattr(facility, key, value)
        facility.save()
        return facility
    
    @staticmethod
    def delete_facility(facility_id):
        """
        删除设施
        
        Args:
            facility_id: 设施ID
        """
        Facility.objects.filter(id=facility_id).delete()

class AdminContext(BaseContext):
    """针对 Admin 模型的基础 CRUD 和查询操作"""
    def __init__(self):
        super().__init__(Admin)

    def get_by_account(self, account: str) -> Admin | None:
        """根据账号名获取 Admin 实例"""
        try:
            return self.model.objects.get(account=account)
        except self.model.DoesNotExist:
            return None


================================================================================
文件路径: python-backend\management\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from django.apps import apps
from core.models import Admin

def get_eventarea_serializer():
    """获取活动区域序列化器"""
    Eventarea = apps.get_model('core', 'Eventarea')
    
    class EventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            exclude = ['shape']
    
    return EventareaSerializer


def get_otherarea_serializer():
    """获取其他区域序列化器"""
    Otherarea = apps.get_model('core', 'Otherarea')
    
    class OtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            exclude = ['shape']
    
    return OtherareaSerializer


def get_event_serializer():
    """获取Event模型的序列化器"""
    Event = apps.get_model('core', 'Event')
    
    class EventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = '__all__'
    
    return EventSerializer


def get_storearea_serializer():
    """获取Storearea模型的序列化器"""
    Storearea = apps.get_model('core', 'Storearea')
    
    class StoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            exclude = ['shape']
    
    return StoreareaSerializer


def get_facility_serializer():
    """获取Facility模型的序列化器"""
    Facility = apps.get_model('core', 'Facility')
    
    class FacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            exclude = ['location']
    
    return FacilitySerializer

# Input Serializers (用于接收前端数据)
class AdminRegisterSerializer(serializers.Serializer):
    """管理员注册输入"""
    account = serializers.CharField(max_length=64)
    password = serializers.CharField(max_length=128, write_only=True)
    name = serializers.CharField(max_length=64, required=False, allow_blank=True)

class AdminLoginSerializer(serializers.Serializer):
    """管理员登录输入"""
    account = serializers.CharField(max_length=64)
    password = serializers.CharField(max_length=128, write_only=True) # write_only: 密码只用于输入，不用于输出

class AdminUpdateSerializer(serializers.Serializer):
    """管理员修改信息输入 (用于 PUT / PATCH)"""
    name = serializers.CharField(max_length=64, required=False, allow_blank=True)
    # 允许修改密码，但必须使用新的字段名 new_password
    new_password = serializers.CharField(max_length=128, required=False, write_only=True)

# Output Serializer (用于返回 Admin 实例信息)
class AdminProfileSerializer(serializers.ModelSerializer):
    """管理员信息的输出格式 (不暴露密码)"""
    class Meta:
        model = Admin
        fields = ['id', 'account', 'name']
        read_only_fields = ['id', 'account'] # 账号和ID不能通过这个接口修改


================================================================================
文件路径: python-backend\management\services.py
--------------------------------------------------------------------------------

from .context import EventareaContext, OtherareaContext, EventContext, StoreareaContext, FacilityContext, AdminContext
from core.models import Admin
from django.contrib.auth.hashers import make_password, check_password
from django.core.exceptions import ValidationError


class AdminService:
    """负责管理员的注册、登录和个人信息修改的业务逻辑"""

    def __init__(self):
        self.ctx = AdminContext()

    def register_admin(self, account: str, password: str, name: str | None = None) -> Admin:
        """注册新管理员"""
        if self.ctx.get_by_account(account):
            raise ValidationError("Admin account already exists.")

        # 1. 密码哈希 (SECURITY CRITICAL)
        hashed_password = make_password(password)

        # 2. 创建实例
        admin_instance = self.ctx.create(
            account=account,
            password=hashed_password,
            name=name
        )
        return admin_instance

    def login_admin(self, account: str, password: str) -> Admin | None:
        """验证管理员登录凭证"""
        admin_instance = self.ctx.get_by_account(account)

        # 1. 检查实例是否存在
        if not admin_instance:
            return None  # 账号不存在

        # 2. 检查密码是否匹配 (使用 check_password 验证哈希值)
        if check_password(password, admin_instance.password):
            return admin_instance  # 登录成功

        return None  # 密码错误

    def update_profile(self, admin_instance: Admin, name: str | None, new_password: str | None) -> Admin:
        """更新管理员信息 (姓名和/或密码)"""
        update_data = {}

        if name is not None:
            update_data['name'] = name

        if new_password:
            # 3. 如果有新密码，哈希后再更新
            update_data['password'] = make_password(new_password)

        return self.ctx.update(admin_instance, **update_data)


class EventareaService:
    """
    活动区域（Eventarea）的业务逻辑层

    提供与Eventarea模型相关的业务逻辑处理方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_eventareas():
        """
        获取所有活动区域

        Returns:
            QuerySet: 活动区域的查询集
        """
        return EventareaContext.get_all_eventareas()

    @staticmethod
    def get_eventarea_by_id(eventarea_id):
        """
        根据ID获取活动区域

        Args:
            eventarea_id: 活动区域ID

        Returns:
            Eventarea: 活动区域对象
        """
        return EventareaContext.get_eventarea_by_id(eventarea_id)

    @staticmethod
    def create_eventarea(data):
        """
        创建新的活动区域

        Args:
            data: 活动区域数据

        Returns:
            Eventarea: 创建的活动区域对象
        """
        # 业务逻辑验证
        # 1. 验证数据完整性
        required_fields = ['is_active', 'description', 'organizer_name', 'organizer_phone', 'type']
        for field in required_fields:
            if field not in data:
                raise ValueError(f"Field '{field}' is required")

        # 2. 验证电话号码格式
        # 这里可以添加更复杂的电话号码验证逻辑
        if len(data['organizer_phone']) < 10:
            raise ValueError("Phone number must be at least 10 characters long")

        # 3. 验证类型是否合法
        valid_types = ['exhibition', 'concert', 'meeting', 'other']  # 根据实际需求调整
        if data['type'] not in valid_types:
            raise ValueError(f"Invalid type. Valid types are: {', '.join(valid_types)}")

        # 4. 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        return EventareaContext.create_eventarea(data)

    @staticmethod
    def update_eventarea(eventarea_id, data):
        """
        更新活动区域

        Args:
            eventarea_id: 活动区域ID
            data: 更新数据

        Returns:
            Eventarea: 更新后的活动区域对象
        """
        # 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        # 如果有其他业务逻辑验证，可以在这里添加

        return EventareaContext.update_eventarea(eventarea_id, data)

    @staticmethod
    def delete_eventarea(eventarea_id):
        """
        删除活动区域

        Args:
            eventarea_id: 活动区域ID
        """
        # 业务逻辑验证
        # 1. 验证活动区域是否存在
        eventarea = EventareaContext.get_eventarea_by_id(eventarea_id)

        # 2. 验证是否有相关联的活动
        if eventarea.event_set.exists():
            raise ValueError("Cannot delete eventarea with associated events")

        return EventareaContext.delete_eventarea(eventarea_id)


class OtherareaService:
    """
    其他区域（Otherarea）的业务逻辑层

    提供与Otherarea模型相关的业务逻辑处理方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_otherareas():
        """
        获取所有其他区域

        Returns:
            QuerySet: 其他区域的查询集
        """
        return OtherareaContext.get_all_otherareas()

    @staticmethod
    def get_otherarea_by_id(otherarea_id):
        """
        根据ID获取其他区域

        Args:
            otherarea_id: 其他区域ID

        Returns:
            Otherarea: 其他区域对象
        """
        return OtherareaContext.get_otherarea_by_id(otherarea_id)

    @staticmethod
    def create_otherarea(data):
        """
        创建新的其他区域

        Args:
            data: 其他区域数据

        Returns:
            Otherarea: 创建的其他区域对象
        """
        # 业务逻辑验证
        # 1. 验证数据完整性
        required_fields = ['is_active', 'description', 'type', 'is_public']
        for field in required_fields:
            if field not in data:
                raise ValueError(f"Field '{field}' is required")

        # 2. 验证类型是否合法
        valid_types = ['restroom', 'parking', 'entrance', 'exit', 'staircase', 'elevator', 'other']  # 根据实际需求调整
        if data['type'] not in valid_types:
            raise ValueError(f"Invalid type. Valid types are: {', '.join(valid_types)}")

        # 3. 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        return OtherareaContext.create_otherarea(data)

    @staticmethod
    def update_otherarea(otherarea_id, data):
        """
        更新其他区域

        Args:
            otherarea_id: 其他区域ID
            data: 更新数据

        Returns:
            Otherarea: 更新后的其他区域对象
        """
        # 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        # 如果有其他业务逻辑验证，可以在这里添加

        return OtherareaContext.update_otherarea(otherarea_id, data)

    @staticmethod
    def delete_otherarea(otherarea_id):
        """
        删除其他区域

        Args:
            otherarea_id: 其他区域ID
        """
        # 业务逻辑验证
        # 1. 验证其他区域是否存在
        otherarea = OtherareaContext.get_otherarea_by_id(otherarea_id)

        # 2. 可以添加其他验证逻辑

        return OtherareaContext.delete_otherarea(otherarea_id)


class EventService:
    """
    活动（Event）的业务逻辑层

    提供与Event模型相关的业务逻辑操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_events():
        """
        获取所有活动

        Returns:
            QuerySet: 活动的查询集
        """
        return EventContext.get_all_events()

    @staticmethod
    def get_event_by_id(event_id):
        """
        根据ID获取活动

        Args:
            event_id: 活动ID

        Returns:
            Event: 活动对象
        """
        return EventContext.get_event_by_id(event_id)

    @staticmethod
    def create_event(data):
        """
        创建新的活动

        Args:
            data: 活动数据

        Returns:
            Event: 创建的活动对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 业务逻辑验证
        # 这里可以添加更多的业务逻辑验证

        return EventContext.create_event(data)

    @staticmethod
    def update_event(event_id, data):
        """
        更新活动

        Args:
            event_id: 活动ID
            data: 更新数据

        Returns:
            Event: 更新后的活动对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 业务逻辑验证
        # 这里可以添加更多的业务逻辑验证

        return EventContext.update_event(event_id, data)

    @staticmethod
    def delete_event(event_id):
        """
        删除活动

        Args:
            event_id: 活动ID
        """
        EventContext.delete_event(event_id)


class StoreareaService:
    """
    店铺区域（Storearea）的业务逻辑层

    提供与Storearea模型相关的业务逻辑操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_storeareas():
        """
        获取所有店铺区域

        Returns:
            QuerySet: 店铺区域的查询集
        """
        return StoreareaContext.get_all_storeareas()

    @staticmethod
    def get_storearea_by_id(storearea_id):
        """
        根据ID获取店铺区域

        Args:
            storearea_id: 店铺区域ID

        Returns:
            Storearea: 店铺区域对象
        """
        return StoreareaContext.get_storearea_by_id(storearea_id)

    @staticmethod
    def create_storearea(data):
        """
        创建新的店铺区域

        Args:
            data: 店铺区域数据

        Returns:
            Storearea: 创建的店铺区域对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 业务逻辑验证
        # 这里可以添加更多的业务逻辑验证

        return StoreareaContext.create_storearea(data)

    @staticmethod
    def update_storearea(storearea_id, data):
        """
        更新店铺区域

        Args:
            storearea_id: 店铺区域ID
            data: 更新数据

        Returns:
            Storearea: 更新后的店铺区域对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 业务逻辑验证
        # 这里可以添加更多的业务逻辑验证

        return StoreareaContext.update_storearea(storearea_id, data)

    @staticmethod
    def delete_storearea(storearea_id):
        """
        删除店铺区域
        
        Args:
            storearea_id: 店铺区域ID
        """
        StoreareaContext.delete_storearea(storearea_id)


class FacilityService:
    """
    设施（Facility）的业务逻辑层
    
    提供与Facility模型相关的业务逻辑处理方法
    注意：location属性由editor模块处理
    """

    @staticmethod
    def get_all_facilities():
        """
        获取所有设施
        
        Returns:
            QuerySet: 设施的查询集
        """
        return FacilityContext.get_all_facilities()

    @staticmethod
    def get_facility_by_id(facility_id):
        """
        根据ID获取设施
        
        Args:
            facility_id: 设施ID
        
        Returns:
            Facility: 设施对象
        """
        return FacilityContext.get_facility_by_id(facility_id)

    @staticmethod
    def create_facility(data):
        """
        创建新的设施
        
        Args:
            data: 设施数据
        
        Returns:
            Facility: 创建的设施对象
        """
        # 业务逻辑验证
        # 1. 验证数据完整性
        required_fields = ['is_active', 'description', 'type']
        for field in required_fields:
            if field not in data:
                raise ValueError(f"Field '{field}' is required")

        # 2. 验证类型是否合法（根据实际需求调整）
        # 这里假设type是整数类型，表示不同的设施类型

        # 3. 如果提供了location属性，将其移除（location属性由editor模块处理）
        if 'location' in data:
            data.pop('location')

        return FacilityContext.create_facility(data)

    @staticmethod
    def update_facility(facility_id, data):
        """
        更新设施
        
        Args:
            facility_id: 设施ID
            data: 更新数据
        
        Returns:
            Facility: 更新后的设施对象
        """
        # 如果提供了location属性，将其移除（location属性由editor模块处理）
        if 'location' in data:
            data.pop('location')

        # 如果有其他业务逻辑验证，可以在这里添加

        return FacilityContext.update_facility(facility_id, data)

    @staticmethod
    def delete_facility(facility_id):
        """
        删除设施
        
        Args:
            facility_id: 设施ID
        """
        # 业务逻辑验证
        # 1. 验证设施是否存在
        facility = FacilityContext.get_facility_by_id(facility_id)

        # 2. 可以添加其他验证逻辑

        return FacilityContext.delete_facility(facility_id)


================================================================================
文件路径: python-backend\management\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.
from rest_framework.test import APITestCase
from rest_framework import status
from django.urls import reverse
from core.models import Admin
from django.contrib.auth.hashers import check_password, make_password


class AdminAuthAPITestCase(APITestCase):
    """
    测试管理员注册、登录、注销接口 (AdminAuthView)
    """

    def setUp(self):
        # 预先定义好路由名称
        self.register_url = reverse('admin-auth', kwargs={'action': 'register'})
        self.login_url = reverse('admin-auth', kwargs={'action': 'login'})
        self.logout_url = reverse('admin-auth', kwargs={'action': 'logout'})
        self.profile_url = reverse('admin-profile')  # 档案管理路由

        # 注册一个测试管理员供后续登录测试使用
        self.account = "testuser"
        self.password = "password123"
        self.admin = Admin.objects.create(
            account=self.account,
            password=make_password(self.password),  # 注意: 这里是明文，在测试中我们会手动进行哈希检查
            name="Original Name"
        )
        # # 注意: 真实的 AdminService.register_admin 会自动哈希密码，但这里我们绕过 Service 直接创建，
        # # 所以必须手动设置哈希后的密码才能通过 login 测试。
        # self.admin.password = check_password(self.password, 'fake_hash')  # 任意哈希值
        # self.admin.save()

    # ------------------ 注册 (Register) 测试 ------------------

    def test_register_success(self):
        """测试成功注册新管理员"""
        data = {"account": "newadmin", "password": "newpassword456", "name": "New Admin"}
        response = self.client.post(self.register_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Admin.objects.count(), 2)
        self.assertEqual(response.data['account'], 'newadmin')

        # 验证密码是否被哈希存储
        new_admin = Admin.objects.get(account='newadmin')
        self.assertTrue(check_password("newpassword456", new_admin.password))

    def test_register_duplicate_account(self):
        """测试注册时账号重复"""
        data = {"account": self.account, "password": "somepassword", "name": "Duplicate User"}
        response = self.client.post(self.register_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('account already exists', response.data['error'].lower())
        self.assertEqual(Admin.objects.count(), 1)  # 确认没有创建新用户

    # ------------------ 登录 (Login) 测试 ------------------

    def test_login_success(self):
        """测试成功登录"""
        data = {"account": self.account, "password": self.password}
        response = self.client.post(self.login_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['account'], self.account)
        # 验证 Session 是否被正确设置 (检查响应中的 session key)
        self.assertIn('sessionid', response.cookies)
        self.assertTrue(self.client.session.get('admin_id'))

    def test_login_failure_wrong_password(self):
        """测试密码错误导致登录失败"""
        data = {"account": self.account, "password": "wrongpassword"}
        response = self.client.post(self.login_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertIn('Invalid account or password', response.data['error'])

    def test_login_failure_non_existent_account(self):
        """测试账号不存在导致登录失败"""
        data = {"account": "nonexistent", "password": "anypassword"}
        response = self.client.post(self.login_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertIn('Invalid account or password', response.data['error'])

    # ------------------ 注销 (Logout) 测试 ------------------

    def test_logout_success(self):
        """测试成功注销"""
        # 先登录以设置 Session
        self.client.post(self.login_url, {"account": self.account, "password": self.password}, format='json')

        # 执行注销
        response = self.client.post(self.logout_url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        # 验证 Session 是否被清除
        self.assertIsNone(self.client.session.get('admin_id'))


class AdminProfileAPITestCase(APITestCase):
    """
    测试管理员档案管理接口 (AdminProfileView)
    """

    def setUp(self):
        self.login_url = reverse('admin-auth', kwargs={'action': 'login'})
        self.profile_url = reverse('admin-profile')

        self.account = "profileuser"
        self.password = "profilepass"

        # 手动创建 Admin 实例,确保密码哈希
        hashed_password = make_password(self.password)
        self.admin = Admin.objects.create(
            account=self.account,
            password=hashed_password,
            name="Profile Target"
        )

        # 登录并获取 Session Cookie
        self.client.post(self.login_url, {"account": self.account, "password": self.password}, format='json')
        # self.admin = Admin.objects.get(account=self.account)  # 获取实例

    # ------------------ 权限 (Authorization) 测试 ------------------

    def test_profile_requires_authentication(self):
        """测试未登录用户无法访问 Profile 接口"""
        self.client.logout()  # 清除 Session
        response_get = self.client.get(self.profile_url, format='json')
        response_put = self.client.put(self.profile_url, {"name": "fail"}, format='json')

        self.assertEqual(response_get.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertEqual(response_put.status_code, status.HTTP_401_UNAUTHORIZED)

    # ------------------ 获取信息 (GET) 测试 ------------------

    def test_get_profile_success(self):
        """测试成功获取个人信息"""
        response = self.client.get(self.profile_url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['account'], self.account)
        self.assertEqual(response.data['name'], "Profile Target")
        self.assertNotIn('password', response.data)  # 确保密码没有被泄露

    # ------------------ 修改信息 (PUT/PATCH) 测试 ------------------

    def test_update_name_success(self):
        """测试成功修改姓名"""
        new_name = "Updated User Name"
        response = self.client.put(self.profile_url, {"name": new_name}, format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['name'], new_name)

        # 验证数据库中的值已更新
        self.admin.refresh_from_db()
        self.assertEqual(self.admin.name, new_name)

    def test_update_password_success(self):
        """测试成功修改密码"""
        new_password = "verysecurepassword"
        response = self.client.put(self.profile_url, {"new_password": new_password}, format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['account'], self.account)

        # 验证新的密码能否用于登录
        self.admin.refresh_from_db()
        self.assertTrue(check_password(new_password, self.admin.password))

        # 验证旧密码失效
        self.assertFalse(check_password(self.password, self.admin.password))

    def test_update_both_success(self):
        """测试同时修改姓名和密码"""
        new_name = "Final Name"
        new_password = "FinalPassword"

        response = self.client.put(self.profile_url,
                                   {"name": new_name, "new_password": new_password},
                                   format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['name'], new_name)

        # 验证数据库
        self.admin.refresh_from_db()
        self.assertEqual(self.admin.name, new_name)
        self.assertTrue(check_password(new_password, self.admin.password))


================================================================================
文件路径: python-backend\management\urls.py
--------------------------------------------------------------------------------

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import EventareaViewSet, OtherareaViewSet, EventViewSet, StoreareaViewSet, FacilityViewSet

# 创建路由器并注册视图集
router = DefaultRouter()
router.register(r'eventarea', EventareaViewSet, basename='management_eventarea')
router.register(r'otherarea', OtherareaViewSet, basename='management_otherarea')
router.register(r'event', EventViewSet, basename='management_event')
router.register(r'storearea', StoreareaViewSet, basename='management_storearea')
router.register(r'facility', FacilityViewSet, basename='management_facility')

urlpatterns = [
    # 包含路由器生成的所有URL
    path('', include(router.urls)),
]



================================================================================
文件路径: python-backend\management\views.py
--------------------------------------------------------------------------------

from rest_framework import viewsets, status
from rest_framework.response import Response
from django.shortcuts import get_object_or_404
from .serializers import get_eventarea_serializer, get_otherarea_serializer, get_event_serializer, get_storearea_serializer, get_facility_serializer
from .services import EventareaService, OtherareaService, EventService, StoreareaService, FacilityService


class EventareaViewSet(viewsets.ModelViewSet):
    """
    活动区域（Eventarea）的视图集
    
    注意：
    - 在management模块中处理除shape属性外的所有其他属性
    - shape属性的操作由editor模块处理
    - 不允许修改shape属性
    
    支持的操作：
    - GET /api/management/eventarea/ - 获取所有活动区域列表
    - GET /api/management/eventarea/{id}/ - 获取指定活动区域详情
    - POST /api/management/eventarea/ - 创建新的活动区域
    - PUT /api/management/eventarea/{id}/ - 完整更新活动区域（不包括shape）
    - PATCH /api/management/eventarea/{id}/ - 部分更新活动区域（不包括shape）
    - DELETE /api/management/eventarea/{id}/ - 删除指定活动区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_eventarea_serializer()
    
    def get_queryset(self):
        """获取所有活动区域"""
        return EventareaService.get_all_eventareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动区域列表"""
        eventareas = EventareaService.get_all_eventareas()
        serializer = self.get_serializer(eventareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动区域详情"""
        eventarea = get_object_or_404(EventareaService.get_all_eventareas(), pk=pk)
        serializer = self.get_serializer(eventarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的活动区域"""
        try:
            # 检查是否包含shape属性，如果包含则移除
            data = request.data.copy()
            if 'shape' in data:
                data.pop('shape')
            
            eventarea = EventareaService.create_eventarea(data)
            serializer = self.get_serializer(eventarea)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新活动区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            eventarea = EventareaService.update_eventarea(pk, request.data)
            serializer = self.get_serializer(eventarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新活动区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            eventarea = EventareaService.update_eventarea(pk, request.data)
            serializer = self.get_serializer(eventarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """删除指定活动区域"""
        try:
            EventareaService.delete_eventarea(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class OtherareaViewSet(viewsets.ModelViewSet):
    """
    其他区域（Otherarea）的视图集
    
    注意：
    - 在management模块中处理除shape属性外的所有其他属性
    - shape属性的操作由editor模块处理
    - 不允许修改shape属性
    
    支持的操作：
    - GET /api/management/otherarea/ - 获取所有其他区域列表
    - GET /api/management/otherarea/{id}/ - 获取指定其他区域详情
    - POST /api/management/otherarea/ - 创建新的其他区域
    - PUT /api/management/otherarea/{id}/ - 完整更新其他区域（不包括shape）
    - PATCH /api/management/otherarea/{id}/ - 部分更新其他区域（不包括shape）
    - DELETE /api/management/otherarea/{id}/ - 删除指定其他区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_otherarea_serializer()
    
    def get_queryset(self):
        """获取所有其他区域"""
        return OtherareaService.get_all_otherareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有其他区域列表"""
        otherareas = OtherareaService.get_all_otherareas()
        serializer = self.get_serializer(otherareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定其他区域详情"""
        otherarea = get_object_or_404(OtherareaService.get_all_otherareas(), pk=pk)
        serializer = self.get_serializer(otherarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的其他区域"""
        try:
            # 检查是否包含shape属性，如果包含则移除
            data = request.data.copy()
            if 'shape' in data:
                data.pop('shape')
            
            otherarea = OtherareaService.create_otherarea(data)
            serializer = self.get_serializer(otherarea)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新其他区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            otherarea = OtherareaService.update_otherarea(pk, request.data)
            serializer = self.get_serializer(otherarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新其他区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            otherarea = OtherareaService.update_otherarea(pk, request.data)
            serializer = self.get_serializer(otherarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """删除指定其他区域"""
        try:
            OtherareaService.delete_otherarea(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class EventViewSet(viewsets.ModelViewSet):
    """
    活动（Event）的视图集
    
    支持的操作：
    - GET /api/management/event/ - 获取所有活动列表
    - GET /api/management/event/{id}/ - 获取指定活动详情
    - POST /api/management/event/ - 创建新的活动
    - PUT /api/management/event/{id}/ - 完整更新活动
    - PATCH /api/management/event/{id}/ - 部分更新活动
    - DELETE /api/management/event/{id}/ - 删除指定活动
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_event_serializer()
    
    def get_queryset(self):
        """获取所有活动"""
        return EventService.get_all_events()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动列表"""
        events = EventService.get_all_events()
        serializer = self.get_serializer(events, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动详情"""
        event = get_object_or_404(EventService.get_all_events(), pk=pk)
        serializer = self.get_serializer(event)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的活动"""
        try:
            event = EventService.create_event(request.data)
            serializer = self.get_serializer(event)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新活动"""
        try:
            event = EventService.update_event(pk, request.data)
            serializer = self.get_serializer(event)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新活动"""
        try:
            event = EventService.update_event(pk, request.data)
            serializer = self.get_serializer(event)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """删除指定活动"""
        try:
            EventService.delete_event(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class StoreareaViewSet(viewsets.ModelViewSet):
    """
    店铺区域（Storearea）的视图集
    
    注意：
    - 不处理shape属性，该属性由editor模块处理
    
    支持的操作：
    - GET /api/management/storearea/ - 获取所有店铺区域列表
    - GET /api/management/storearea/{id}/ - 获取指定店铺区域详情
    - POST /api/management/storearea/ - 创建新的店铺区域
    - PUT /api/management/storearea/{id}/ - 完整更新店铺区域（不包括shape）
    - PATCH /api/management/storearea/{id}/ - 部分更新店铺区域（不包括shape）
    - DELETE /api/management/storearea/{id}/ - 删除指定店铺区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_storearea_serializer()
    
    def get_queryset(self):
        """获取所有店铺区域"""
        return StoreareaService.get_all_storeareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有店铺区域列表"""
        storeareas = StoreareaService.get_all_storeareas()
        serializer = self.get_serializer(storeareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定店铺区域详情"""
        storearea = get_object_or_404(StoreareaService.get_all_storeareas(), pk=pk)
        serializer = self.get_serializer(storearea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的店铺区域"""
        try:
            # 检查是否包含shape属性，如果包含则移除
            data = request.data.copy()
            if 'shape' in data:
                data.pop('shape')
            
            storearea = StoreareaService.create_storearea(data)
            serializer = self.get_serializer(storearea)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新店铺区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            storearea = StoreareaService.update_storearea(pk, request.data)
            serializer = self.get_serializer(storearea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新店铺区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            storearea = StoreareaService.update_storearea(pk, request.data)
            serializer = self.get_serializer(storearea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """
        删除指定店铺区域
        """
        try:
            StoreareaService.delete_storearea(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class FacilityViewSet(viewsets.ModelViewSet):
    """
    设施（Facility）的视图集
    
    注意：
    - 在management模块中处理除location属性外的所有其他属性
    - location属性的操作由editor模块处理
    - 不允许修改location属性
    
    支持的操作：
    - GET /api/management/facility/ - 获取所有设施列表
    - GET /api/management/facility/{id}/ - 获取指定设施详情
    - POST /api/management/facility/ - 创建新的设施
    - PUT /api/management/facility/{id}/ - 完整更新设施（不包括location）
    - PATCH /api/management/facility/{id}/ - 部分更新设施（不包括location）
    - DELETE /api/management/facility/{id}/ - 删除指定设施
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_facility_serializer()
    
    def get_queryset(self):
        """获取所有设施"""
        return FacilityService.get_all_facilities()
    
    def list(self, request, *args, **kwargs):
        """获取所有设施列表"""
        facilities = FacilityService.get_all_facilities()
        serializer = self.get_serializer(facilities, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定设施详情"""
        facility = get_object_or_404(FacilityService.get_all_facilities(), pk=pk)
        serializer = self.get_serializer(facility)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的设施"""
        try:
            # 检查是否包含location属性，如果包含则移除
            data = request.data.copy()
            if 'location' in data:
                data.pop('location')
            
            facility = FacilityService.create_facility(data)
            serializer = self.get_serializer(facility)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新设施（不包括location）"""
        try:
            # 检查是否包含location属性，如果包含则返回错误
            if 'location' in request.data:
                return Response(
                    {'error': 'Location attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            facility = FacilityService.update_facility(pk, request.data)
            serializer = self.get_serializer(facility)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新设施（不包括location）"""
        try:
            # 检查是否包含location属性，如果包含则返回错误
            if 'location' in request.data:
                return Response(
                    {'error': 'Location attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            facility = FacilityService.update_facility(pk, request.data)
            serializer = self.get_serializer(facility)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """删除指定设施"""
        try:
            FacilityService.delete_facility(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.core.exceptions import ValidationError
from django.http import HttpRequest

from .services import AdminService
from .serializers import AdminRegisterSerializer, AdminLoginSerializer, AdminUpdateSerializer, AdminProfileSerializer
from core.models import Admin
from core.context import BaseContext


class AdminAuthMixin:
    """一个简单的用于检查管理员登录状态并加载 Admin 实例的 Mixin"""
    @staticmethod
    def get_admin_user(request: HttpRequest) -> Admin | None:
        admin_id = request.session.get('admin_id')
        if admin_id:
            try:
                # 使用 BaseContext 或 AdminContext 获取实例
                return BaseContext(Admin).get_by_id(admin_id)
            except Admin.DoesNotExist:
                del request.session['admin_id']  # 清理过期会话
                return None
        return None


class AdminAuthView(APIView):
    """
    处理管理员的注册、登录、注销
    POST /api/management/auth/register/
    POST /api/management/auth/login/
    POST /api/management/auth/logout/
    """
    service_class = AdminService

    def post(self, request, action):
        service = self.service_class()

        if action == 'register':
            serializer = AdminRegisterSerializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            try:
                admin = service.register_admin(**serializer.validated_data)
                return Response(AdminProfileSerializer(admin).data, status=status.HTTP_201_CREATED)
            except ValidationError as e:
                return Response({"error": e.message}, status=status.HTTP_400_BAD_REQUEST)

        elif action == 'login':
            serializer = AdminLoginSerializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            admin = service.login_admin(**serializer.validated_data)

            if admin:
                # 登录成功：在 session 中设置 ID
                request.session['admin_id'] = admin.id
                return Response(AdminProfileSerializer(admin).data, status=status.HTTP_200_OK)
            else:
                return Response({"error": "Invalid account or password"}, status=status.HTTP_401_UNAUTHORIZED)

        elif action == 'logout':
            if 'admin_id' in request.session:
                del request.session['admin_id']  # 清除 session
            return Response({"message": "Logout successful"}, status=status.HTTP_200_OK)

        else:
            return Response({"error": "Invalid action"}, status=status.HTTP_400_BAD_REQUEST)


# --- 个人信息接口 ---
class AdminProfileView(AdminAuthMixin, APIView):
    """
    处理管理员个人信息的获取和修改
    GET /api/management/profile/
    PUT/PATCH /api/management/profile/
    """
    service_class = AdminService
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.admin_user = None # 初始化实例属性
        
    def dispatch(self, request, *args, **kwargs):
        # 在处理请求前，先检查登录状态并加载 Admin 实例
        self.admin_user = self.get_admin_user(request)
        if not self.admin_user:
            return Response({"error": "Authentication credentials were not provided."},
                            status=status.HTTP_401_UNAUTHORIZED)
        return super().dispatch(request, *args, **kwargs)

    def get(self, request):
        """获取当前登录管理员的个人信息"""
        # self.admin_user 已在 dispatch 中加载并验证
        return Response(AdminProfileSerializer(self.admin_user).data)

    def put(self, request):
        """修改当前登录管理员的个人信息 (PUT/PATCH 通用)"""
        serializer = AdminUpdateSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        service = self.service_class()

        updated_admin = service.update_profile(
            admin_instance=self.admin_user,
            name=serializer.validated_data.get('name'),
            new_password=serializer.validated_data.get('new_password')
        )

        return Response(AdminProfileSerializer(updated_admin).data, status=status.HTTP_200_OK)


================================================================================
文件路径: python-backend\management\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\management\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\map\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\map\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig



class MapConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'map'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\map\context.py
--------------------------------------------------------------------------------

from core.models import Map, Storearea, Facility, Otherarea, Eventarea
from django.db.models import Q
from core.context import BaseContext


class MapContext(BaseContext):
    def __init__(self):
        super().__init__(Map)

    def get_map_with_building(self, map_id):
        """获取地图并预加载建筑信息"""
        try:
            return self.model.objects.select_related('building').get(pk=map_id)
        except self.model.DoesNotExist:
            return None

    @staticmethod
    def get_map_elements(map_obj):
        """一次性获取地图关联的所有元素 ID"""
        # 注意：这里只负责取数据，不负责格式化
        store_ids = map_obj.storeareamap_set.values_list('storearea_id', flat=True)
        facility_ids = map_obj.facilitymap_set.values_list('facility_id', flat=True)
        other_ids = map_obj.otherareamap_set.values_list('otherarea_id', flat=True)
        event_ids = map_obj.eventareamap_set.values_list('eventarea_id', flat=True)
        return store_ids, facility_ids, other_ids, event_ids

    def list_all_with_building(self):
        """获取所有地图列表，并预加载建筑信息"""
        return self.model.objects.select_related('building').all()

class ElementContext:
    """负责处理具体的商铺、设施等元素"""

    @staticmethod
    def get_stores_by_ids(ids):
        return Storearea.objects.filter(id__in=ids)

    @staticmethod
    def get_facilities_by_ids(ids):
        return Facility.objects.filter(id__in=ids)

    @staticmethod
    def get_others_by_ids(ids):
        return Otherarea.objects.filter(id__in=ids)

    @staticmethod
    def get_events_by_ids(ids):
        return Eventarea.objects.filter(id__in=ids)

    @staticmethod
    def search_globally(keyword):
        stores = Storearea.objects.filter(store_name__icontains=keyword)
        others = Otherarea.objects.filter(description__icontains=keyword, is_public=True)
        return stores, others


================================================================================
文件路径: python-backend\map\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from core.models import Map, Storearea, Facility, Otherarea, Eventarea
import json


# ==========================================
# 1. 子元素序列化器 (先定义，供 MapSerializer 调用)
# ==========================================

class OtherareaSerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Otherarea
        # 将 is_public 暴露出来，前端可以用不同颜色渲染
        fields = ['id', 'type', 'description', 'is_public',  'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.shape: return None
        return json.loads(obj.shape.geojson)


class StoreareaSerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Storearea
        fields = ['id', 'store_name', 'type', 'logo_url', 'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.shape: return None
        return json.loads(obj.shape.geojson)


class FacilitySerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Facility
        fields = ['id', 'type', 'description', 'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.location: return None
        return json.loads(obj.location.geojson)


class EventareaSerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Eventarea
        fields = ['id', 'description',  'type', 'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.shape: return None
        return json.loads(obj.shape.geojson)


# ==========================================
# 2. 地图聚合序列化器 (核心修改部分)
# ==========================================

class MapSerializer(serializers.ModelSerializer):
    """
    地图详情：包含该楼层的底图几何信息，以及关联的商铺、设施等。
    """
    building_name = serializers.CharField(source='building.name', read_only=True)
    detail_geojson = serializers.SerializerMethodField()

    # --- 关键修改开始 ---
    # 使用 source='temp_xxx' 对应 MapDisplayService 中挂载的属性名
    # read_only=True 表示这些字段只用于输出，不用于写入
    stores = StoreareaSerializer(source='temp_stores', many=True, read_only=True)
    facilities = FacilitySerializer(source='temp_facilities', many=True, read_only=True)
    other_areas = OtherareaSerializer(source='temp_others', many=True, read_only=True)
    events = EventareaSerializer(source='temp_events', many=True, read_only=True)

    # --- 关键修改结束 ---

    class Meta:
        model = Map
        fields = [
            'id',
            'building_id',
            'building_name',
            'floor_number',
            'detail_geojson',
            # 必须把新字段加入 fields 列表
            'stores',
            'facilities',
            'other_areas',
            'events'
        ]

    @staticmethod
    def get_detail_geojson(obj):
        """
        处理底图几何 (外轮廓 + 镂空)
        """
        if not obj.detail:
            return None

        # 保持原始坐标系 (SRID 2385)，方便前端计算米制距离
        # 如果需要经纬度，需在此处 clone().transform(4326)
        geometry = obj.detail.clone()
        return json.loads(geometry.geojson)


================================================================================
文件路径: python-backend\map\services.py
--------------------------------------------------------------------------------

from django.contrib.gis.geos import GEOSGeometry, Polygon
from typing import Tuple, List
from map.context import MapContext, ElementContext


# ==========================================
# Part 1: 纯几何算法 (保持不变)
# ==========================================
class GeometryAlgorithms:
    @staticmethod
    def validate_shape_syntax(geometry: GEOSGeometry) -> Tuple[bool, str]:
        if geometry is None: return False, "Geometry is None"
        if not geometry.valid: return False, f"Invalid Geometry: {geometry.valid_reason}"
        if isinstance(geometry, Polygon) and geometry.empty: return False, "Polygon is empty"
        return True, "Valid"

    @staticmethod
    def get_distance_between_areas(shape1: GEOSGeometry, shape2: GEOSGeometry) -> float:
        """
        接口 3: 获取输入的两个区域之间的距离
        """
        if not shape1 or not shape2:
            return -1.0
        # distance() 计算的是两个几何体之间最近点的欧几里得距离
        # 单位取决于 SRID (2385 为米)
        return shape1.distance(shape2)

    @staticmethod
    def validate_holes_inside_shell(outer_shell: GEOSGeometry, holes: List[GEOSGeometry]) -> Tuple[bool, str]:
        """
        接口 2: 镂空本身有无超出外轮廓区域
        """
        if not outer_shell:
            return False, "Outer shell is missing"

        if not holes:
            return True, "No holes to validate"

        for i, hole in enumerate(holes, start=1):
            # hole 必须完全在 outer_shell 内部 (contains)
            # 任何一部分超出或仅仅是相交都算非法
            if not outer_shell.contains(hole):
                return False, f"Hole #{i} is outside or intersecting the map boundary."

        return True, "All holes are valid"

    @staticmethod
    def check_placement(new_shape, outer_shell, holes, existing_obstacles):
        if not outer_shell: return False, "Map shell missing"
        if not outer_shell.contains(new_shape): return False, "Area exceeds map outer boundary"
        for i, hole in enumerate(holes):
            if hole.intersects(new_shape): return False, f"Area intersects with map hole #{i + 1}"
        for existing_shape in existing_obstacles:
            if existing_shape and existing_shape.intersects(new_shape):
                return False, "Area overlaps with an existing area"
        return True, "Placement valid"


# ==========================================
# Part 2: 业务服务 (修改部分)
# ==========================================

class MapDisplayService:
    """
    地图显示与校验服务
    """

    def __init__(self):
        self.map_ctx = MapContext()
        self.elem_ctx = ElementContext()

    def get_full_map_details(self, map_id):
        map_obj = self.map_ctx.get_map_with_building(map_id)
        if not map_obj: return None

        s_ids, f_ids, o_ids, e_ids = self.map_ctx.get_map_elements(map_obj)

        map_obj.temp_stores = self.elem_ctx.get_stores_by_ids(s_ids)
        map_obj.temp_facilities = self.elem_ctx.get_facilities_by_ids(f_ids)
        map_obj.temp_others = self.elem_ctx.get_others_by_ids(o_ids)
        map_obj.temp_events = self.elem_ctx.get_events_by_ids(e_ids)

        return map_obj

    def validate_geometry(self, geometry, map_id, exclude_id=None, area_type=None):
        """
        几何校验业务流程
        """
        # 1. 几何语法校验
        is_valid, msg = GeometryAlgorithms.validate_shape_syntax(geometry)
        if not is_valid:
            return False, msg

        # 2. 获取地图数据
        map_obj = self.map_ctx.get_map_with_building(map_id)
        if not map_obj or not map_obj.detail:
            return False, "Map data not found or empty"

        # 解析外轮廓和镂空
        outer_shell = map_obj.detail[0]
        holes = list(map_obj.detail[1:]) if len(map_obj.detail) > 1 else []

        # 3. 获取所有障碍物 (修改点：在 Service 层组装数据)
        obstacles = self._collect_obstacles(map_obj, exclude_id, area_type)

        # 4. 调用算法进行物理放置校验
        return GeometryAlgorithms.check_placement(
            new_shape=geometry,
            outer_shell=outer_shell,
            holes=holes,
            existing_obstacles=obstacles
        )

    def _collect_obstacles(self, map_obj, exclude_id, area_type) -> List[GEOSGeometry]:
        """
        私有辅助方法：利用 MapContext 和 ElementContext 收集该地图上所有实体的形状
        """
        obstacles = []

        # 1. 从 MapContext 获取所有关联 ID
        s_ids, f_ids, o_ids, e_ids = self.map_ctx.get_map_elements(map_obj)

        # 辅助函数：处理排除逻辑
        def should_include(item_id, item_type):
            # 如果类型相同且 ID 相同，则排除（说明是正在编辑的那个对象）
            if area_type == item_type and str(item_id) == str(exclude_id):
                return False
            return True

        # 2. 从 ElementContext 获取对象并提取形状

        # A. 商铺 (Stores)
        stores = self.elem_ctx.get_stores_by_ids(s_ids)
        for s in stores:
            if should_include(s.id, 'store') and s.shape:
                obstacles.append(s.shape)

        # B. 设施 (Facilities) - 需要 Buffer 处理
        facilities = self.elem_ctx.get_facilities_by_ids(f_ids)
        for f in facilities:
            if should_include(f.id, 'facility') and f.location:
                # 设施通常是点，必须膨胀成多边形才能进行碰撞检测
                # 假设半径 0.5 米
                obstacles.append(f.location.buffer(0.5))

        # C. 其他区域 (Otherareas)
        others = self.elem_ctx.get_others_by_ids(o_ids)
        for o in others:
            if should_include(o.id, 'other') and o.shape:
                obstacles.append(o.shape)

        # D. 活动区域 (Events)
        events = self.elem_ctx.get_events_by_ids(e_ids)
        for e in events:
            if should_include(e.id, 'event') and e.shape and e.is_active:
                obstacles.append(e.shape)

        return obstacles

    def get_map_list(self):
        """
        获取地图列表概要
        """
        # 1. 从 Context 获取所有地图
        maps = self.map_ctx.list_all_with_building()

        # 2. 初始化空属性，防止 MapSerializer 报错
        # (因为列表页通常不需要加载 heavy 的商铺/设施数据，只看底图或基础信息)
        for map_obj in maps:
            map_obj.temp_stores = []
            map_obj.temp_facilities = []
            map_obj.temp_others = []
            map_obj.temp_events = []

        return maps


================================================================================
文件路径: python-backend\map\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.
from rest_framework.test import APITestCase
from rest_framework import status
from django.urls import reverse
from django.contrib.gis.geos import Polygon, GeometryCollection
from core.models import Building, Map, Storearea, StoreareaMap


class MapViewSetTestCase(APITestCase):
    """
    测试 MapViewSet 的 list 和 retrieve 接口
    验证从数据库到 Service 再到 View 的数据流是否正常
    """

    def setUp(self):
        """
        测试数据准备：
        1. 创建 Building
        2. 创建 Map (带 GeometryCollection)
        3. 创建 Storearea (带 Polygon)
        4. 建立 Map 和 Storearea 的关联
        """
        # 1. 创建建筑
        self.building = Building.objects.create(
            name="测试万达广场",
            address="上海市杨浦区"
        )

        # 2. 创建地图底图几何 (SRID 2385)
        # 假设是一个 100x100 的正方形外轮廓
        outer_shell = Polygon(((0, 0), (0, 100), (100, 100), (100, 0), (0, 0)), srid=2385)
        # detail 字段是 GeometryCollection
        map_detail = GeometryCollection(outer_shell, srid=2385)

        self.map_obj = Map.objects.create(
            building=self.building,
            floor_number=1,
            detail=map_detail
        )

        # 3. 创建商铺
        # 在地图内部创建一个 10x10 的小方块商铺
        store_shape = Polygon(((10, 10), (10, 20), (20, 20), (20, 10), (10, 10)), srid=2385)
        self.store = Storearea.objects.create(
            store_name="测试海底捞",
            type=1,
            shape=store_shape,
            owner_name="张三",
            owner_phone="123456",
            is_active = True
        )

        # 4. 关联商铺到地图 (重要：否则 retrieve 接口不会返回该商铺)
        StoreareaMap.objects.create(
            map=self.map_obj,
            storearea=self.store
        )

        # 路由名称定义 (对应 urls.py 中的 router.register(..., basename='maps'))
        self.list_url = reverse('map-list')
        self.detail_url = reverse('map-detail', args=[self.map_obj.id])

    def test_list_maps(self):
        """
        测试获取地图列表 (GET /api/maps/)
        """
        response = self.client.get(self.list_url)

        # 1. 验证状态码
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        # 2. 验证返回数据类型是列表
        self.assertIsInstance(response.data, list)
        self.assertEqual(len(response.data), 1)

        # 3. 验证基础字段
        map_data = response.data[0]
        self.assertEqual(map_data['floor_number'], 1)
        self.assertEqual(map_data['building_name'], "测试万达广场")

        # 4. 验证列表接口是否正确处理了 temp_stores (应该为空列表或不报错)
        # 根据我们之前的 Service 逻辑，列表接口为了性能可能没有加载 stores，或者加载了空列表
        if 'stores' in map_data:
            self.assertIsInstance(map_data['stores'], list)

    def test_retrieve_map_success(self):
        """
        测试获取单张地图详情 (GET /api/maps/{id}/)
        核心：验证 Service 是否成功组装了 detail_geojson 和 stores
        """
        response = self.client.get(self.detail_url)

        # 1. 验证状态码
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        data = response.data

        # 2. 验证底图几何 (detail_geojson)
        self.assertIn('detail_geojson', data)
        self.assertEqual(data['detail_geojson']['type'], 'GeometryCollection')

        # 3. 验证关联元素 (stores)
        # 这是验证 MapDisplayService.get_full_map_details 逻辑的关键
        self.assertIn('stores', data)
        self.assertEqual(len(data['stores']), 1)

        store_data = data['stores'][0]
        self.assertEqual(store_data['store_name'], "测试海底捞")
        self.assertEqual(store_data['id'], self.store.id)

        # 验证商铺的几何是否被正确序列化为 GeoJSON
        self.assertIn('geometry', store_data)
        self.assertEqual(store_data['geometry']['type'], 'Polygon')

        # 4. 验证其他空列表字段是否存在 (facilities, events, etc.)
        self.assertIn('facilities', data)
        self.assertEqual(data['facilities'], [])  # setUp中没创建设施，应为空列表

    def test_retrieve_map_not_found(self):
        """
        测试获取不存在的地图 ID
        """
        non_existent_url = reverse('map-detail', args=[99999])
        response = self.client.get(non_existent_url)

        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)


================================================================================
文件路径: python-backend\map\views.py
--------------------------------------------------------------------------------

from rest_framework import viewsets, status
from rest_framework.views import APIView
from rest_framework.response import Response
from django.contrib.gis.geos import GEOSGeometry
import json

from .serializers import MapSerializer  # 序列化器依然需要，用于格式化输出
from map.services import MapDisplayService


class MapViewSet(viewsets.ViewSet):
    """
    只读 ViewSet，不继承 ModelViewSet
    """
    service_class = MapDisplayService

    def list(self, request):
        """GET /api/maps/"""
        service = self.service_class()

        # 1. 调用 Service 获取列表
        maps = service.get_map_list()

        # 2. 序列化返回
        # 注意：这里会返回所有地图的 GeoJSON，数据量可能较大
        # 实际生产中建议单独定义一个 SimpleMapSerializer (不含 detail_geojson) 用于列表
        serializer = MapSerializer(maps, many=True)

        return Response(serializer.data)

    def retrieve(self, request, pk=None):
        """GET /api/maps/{id}/"""
        service = self.service_class()

        # 1. 调用 Service 获取组装好的对象
        map_data = service.get_full_map_details(pk)

        if not map_data:
            return Response({"error": "Map not found"}, status=status.HTTP_404_NOT_FOUND)

        # 2. 使用 Serializer 格式化 Service 返回的数据
        # 注意：Serializer 内部字段 source='temp_stores' 需要对应 Service 挂载的属性
        serializer = MapSerializer(map_data)
        return Response(serializer.data)


class MapValidationView(APIView):
    """POST /api/maps/validate/"""
    service_class = MapDisplayService

    def post(self, request):
        service = self.service_class()

        # 1. 参数提取
        geometry_data = request.data.get('geometry')
        map_id = request.data.get('map_id')
        area_type = request.data.get('type')
        exclude_id = request.data.get('exclude_id')

        # 2. 数据预处理
        try:
            shape_str = json.dumps(geometry_data) if isinstance(geometry_data, dict) else geometry_data
            shape = GEOSGeometry(shape_str)
            if shape.srid != 2385: shape.srid = 2385
        except Exception:
            return Response({"error": "Invalid Geometry"}, status=400)

        # 3. 调用 Service 业务逻辑
        is_valid, reason = service.validate_geometry(shape, map_id, exclude_id, area_type)

        return Response({"valid": is_valid, "reason": reason})


================================================================================
文件路径: python-backend\map\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\map\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\python_backend\settings.py
--------------------------------------------------------------------------------

"""
Django settings for python_backend project.

Based on by 'django-admin startproject' using Django 2.1.2.

For more information on this file, see
https://docs.djangoproject.com/en/2.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/2.1/ref/settings/
"""

import os
import posixpath

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/2.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = '7306ec88-3719-40e9-88d4-2d6fdee59734'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ['*']

# Application references
# https://docs.djangoproject.com/en/2.1/ref/settings/#std:setting-INSTALLED_APPS
INSTALLED_APPS = [
    # Add your apps here to enable them
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.gis',
    'rest_framework',
    'django_filters',
    # 支持跨域请求
    'corsheaders',
    'core.apps.CoreConfig',
    'map.apps.MapConfig',
    'client.apps.ClientConfig',
    'management.apps.ManagementConfig',
    'search.apps.SearchConfig',
    'guide.apps.GuideConfig',
    'editor.apps.EditorConfig'
]

# Middleware framework
# https://docs.djangoproject.com/en/2.1/topics/http/middleware/
MIDDLEWARE = [
    # CORS middleware should be placed as high as possible
    'corsheaders.middleware.CorsMiddleware',
    # 注意：确保 CommonMiddleware 仍然在 CorsMiddleware 之后
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'python_backend.urls'

# Template configuration
# https://docs.djangoproject.com/en/2.1/topics/templates/
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'python_backend.wsgi.application'

# Database
# https://docs.djangoproject.com/en/2.1/ref/settings/#databases
DATABASES = {
    'default': {
        'ENGINE': 'django.contrib.gis.db.backends.postgis',
        'NAME': os.environ.get('POSTGRES_DB'),
        'USER': os.environ.get('POSTGRES_USER'),
        'PASSWORD': os.environ.get('POSTGRES_PASSWORD'),
        'HOST': 'postgres-db',
        'PORT': '5432',
    }
}

# Password validation
# https://docs.djangoproject.com/en/2.1/ref/settings/#auth-password-validators
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Internationalization
# https://docs.djangoproject.com/en/2.1/topics/i18n/
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_L10N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/2.1/howto/static-files/
STATIC_URL = '/static/'
STATIC_ROOT = posixpath.join(*(BASE_DIR.split(os.path.sep) + ['static']))

REST_FRAMEWORK = {
    # 默认权限设置：这里设置为默认需要登录才能访问，方便后续开发
    'DEFAULT_PERMISSION_CLASSES': [
        # 'rest_framework.permissions.IsAuthenticated',
        # 如果是开发初期想全部公开，可以改为:
        'rest_framework.permissions.AllowAny',
    ],

    # 默认认证方式
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
    ],

    # 默认分页设置 (推荐配置，防止大数据量查死数据库)
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,

    # 统一日期格式 (可选)
    'DATETIME_FORMAT': '%Y-%m-%d %H:%M:%S',
}

# CORS 设置（开发环境方便测试，生产请按需限制）
CORS_ALLOWED_ORIGINS = [
  "http://localhost:8080"
]
CORS_ALLOW_CREDENTIALS = True
# 可根据需要自定义允许的头、方法
# CORS_ALLOW_HEADERS = list(default_headers) + [
#     'your-custom-header',
# ]



================================================================================
文件路径: python-backend\python_backend\urls.py
--------------------------------------------------------------------------------

"""
python_backend URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/2.1/topics/http/urls/

Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""

# Uncomment next two lines to enable admin:
from django.contrib import admin
from django.urls import path,include
from rest_framework.routers import DefaultRouter
from map.views import MapViewSet, MapValidationView

from guide.views import RoutePlanView

from management.views import AdminAuthView, AdminProfileView


router = DefaultRouter()
router.register(r'maps', MapViewSet, basename='map')
urlpatterns = [
    path('search/', include('search.urls')),
    path('api/editor/', include('editor.urls')),
    path('api/management/', include('management.urls')),
    # Uncomment the next line to enable the admin:
    #path('admin/', admin.site.urls)
    path('api/maps/validate/', MapValidationView.as_view(), name='map-validate'),
    path('api/guide/route/',RoutePlanView.as_view(), name='route-plan'),
    path('api/', include(router.urls)),
    path('api/management/auth/<str:action>/', AdminAuthView.as_view(), name='admin-auth'),
    path('api/management/profile/', AdminProfileView.as_view(), name='admin-profile'),
    path('admin/', admin.site.urls),
    path('api/search/', include('search.urls')),
    # 其他URL配置...
]



================================================================================
文件路径: python-backend\python_backend\wsgi.py
--------------------------------------------------------------------------------

"""
WSGI config for python_backend project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

For more information, visit
https://docs.djangoproject.com/en/2.1/howto/deployment/wsgi/
"""

import os

import django
from django.core.wsgi import get_wsgi_application

os.environ.setdefault(
    'DJANGO_SETTINGS_MODULE',
    'python_backend.settings')
django.setup()

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
application = get_wsgi_application()



================================================================================
文件路径: python-backend\python_backend\__init__.py
--------------------------------------------------------------------------------

"""
Package for python_backend.
"""



================================================================================
文件路径: python-backend\search\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\search\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class SearchConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'search'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\search\context.py
--------------------------------------------------------------------------------

from django.apps import apps
from django.db.models import Q


class BaseSearchContext:
    """基础搜索上下文类"""

    def __init__(self, model_name):
        self.model_name = model_name
        self.model = apps.get_model('core', model_name)


class StoreareaContext(BaseSearchContext):
    """店铺区域上下文"""

    def __init__(self):
        super().__init__('Storearea')

    def get_by_id(self, storearea_id):
        """根据ID获取店铺区域"""
        try:
            return self.model.objects.get(id=storearea_id)
        except self.model.DoesNotExist:
            return None

    def search_by_name(self, name):
        """根据名称搜索店铺区域"""
        return self.model.objects.filter(
            store_name__icontains=name,
            is_active=True
        )

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选店铺区域"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_storearea_map_relations(self, storearea_id):
        """获取店铺区域的地图关联"""
        StoreareaMap = apps.get_model('core', 'StoreareaMap')
        return StoreareaMap.objects.filter(storearea_id=storearea_id)


class EventContext(BaseSearchContext):
    """活动上下文"""

    def __init__(self):
        super().__init__('Event')

    def get_by_id(self, event_id):
        """根据ID获取活动"""
        try:
            return self.model.objects.get(id=event_id)
        except self.model.DoesNotExist:
            return None

    def search_by_name(self, name):
        """根据名称搜索活动"""
        return self.model.objects.filter(
            event_name__icontains=name,
            is_active=True
        )

    def filter_active_events(self):
        """获取所有活跃活动"""
        return self.model.objects.filter(is_active=True)

    def get_event_storearea_relations(self, event_id):
        """获取活动的店铺区域关联"""
        EventStorearea = apps.get_model('core', 'EventStorearea')
        return EventStorearea.objects.filter(event_id=event_id)

    def get_event_eventarea_relations(self, event_id):
        """获取活动的活动区域关联"""
        EventEventarea = apps.get_model('core', 'EventEventarea')
        return EventEventarea.objects.filter(event_id=event_id)


class EventareaContext(BaseSearchContext):
    """活动区域上下文"""

    def __init__(self):
        super().__init__('Eventarea')

    def get_by_id(self, eventarea_id):
        """根据ID获取活动区域"""
        try:
            return self.model.objects.get(id=eventarea_id)
        except self.model.DoesNotExist:
            return None

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选活动区域"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_eventarea_map_relations(self, eventarea_id):
        """获取活动区域的地图关联"""
        EventareaMap = apps.get_model('core', 'EventareaMap')
        return EventareaMap.objects.filter(eventarea_id=eventarea_id)

    def get_eventarea_map_relations_by_map(self, map_id):
        """根据地图ID获取活动区域关联"""
        EventareaMap = apps.get_model('core', 'EventareaMap')
        return EventareaMap.objects.filter(map_id=map_id)


class FacilityContext(BaseSearchContext):
    """设施上下文"""

    def __init__(self):
        super().__init__('Facility')

    def get_by_id(self, facility_id):
        """根据ID获取设施"""
        try:
            return self.model.objects.get(id=facility_id)
        except self.model.DoesNotExist:
            return None

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选设施"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_facility_map_relations(self, facility_id):
        """获取设施的地图关联"""
        FacilityMap = apps.get_model('core', 'FacilityMap')
        return FacilityMap.objects.filter(facility_id=facility_id)

    def get_facility_map_relations_by_map(self, map_id):
        """根据地图ID获取设施关联"""
        FacilityMap = apps.get_model('core', 'FacilityMap')
        return FacilityMap.objects.filter(map_id=map_id)


class OtherareaContext(BaseSearchContext):
    """其他区域上下文"""

    def __init__(self):
        super().__init__('Otherarea')

    def get_by_id(self, otherarea_id):
        """根据ID获取其他区域"""
        try:
            return self.model.objects.get(id=otherarea_id)
        except self.model.DoesNotExist:
            return None

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选其他区域"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_otherarea_map_relations(self, otherarea_id):
        """获取其他区域的地图关联"""
        OtherareaMap = apps.get_model('core', 'OtherareaMap')
        return OtherareaMap.objects.filter(otherarea_id=otherarea_id)

    def get_otherarea_map_relations_by_map(self, map_id):
        """根据地图ID获取其他区域关联"""
        OtherareaMap = apps.get_model('core', 'OtherareaMap')
        return OtherareaMap.objects.filter(map_id=map_id)


class SearchElementContext:
    """搜索元素上下文，用于处理关联关系"""

    @staticmethod
    def get_storearea_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取店铺区域ID"""
        StoreareaMap = apps.get_model('core', 'StoreareaMap')
        Storearea = apps.get_model('core', 'Storearea')

        # 获取该地图的所有storearea关联
        storearea_maps = StoreareaMap.objects.filter(map_id=map_id)
        storearea_ids = [sm.storearea_id for sm in storearea_maps]

        # 如果提供了类型参数，则进一步过滤
        if type_id is not None:
            storeareas = Storearea.objects.filter(
                id__in=storearea_ids,
                type=type_id,
                is_active=True
            )
            storearea_ids = [storearea.id for storearea in storeareas]

        return storearea_ids

    @staticmethod
    def get_eventarea_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取活动区域ID"""
        EventareaMap = apps.get_model('core', 'EventareaMap')
        Eventarea = apps.get_model('core', 'Eventarea')

        eventarea_maps = EventareaMap.objects.filter(map_id=map_id)
        eventarea_ids = [em.eventarea_id for em in eventarea_maps]

        if type_id is not None:
            eventareas = Eventarea.objects.filter(
                id__in=eventarea_ids,
                type=type_id,
                is_active=True
            )
            eventarea_ids = [eventarea.id for eventarea in eventareas]

        return eventarea_ids

    @staticmethod
    def get_facility_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取设施ID"""
        FacilityMap = apps.get_model('core', 'FacilityMap')
        Facility = apps.get_model('core', 'Facility')

        facility_maps = FacilityMap.objects.filter(map_id=map_id)
        facility_ids = [fm.facility_id for fm in facility_maps]

        if type_id is not None:
            facilities = Facility.objects.filter(
                id__in=facility_ids,
                type=type_id,
                is_active=True
            )
            facility_ids = [facility.id for facility in facilities]

        return facility_ids

    @staticmethod
    def get_otherarea_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取其他区域ID"""
        OtherareaMap = apps.get_model('core', 'OtherareaMap')
        Otherarea = apps.get_model('core', 'Otherarea')

        otherarea_maps = OtherareaMap.objects.filter(map_id=map_id)
        otherarea_ids = [om.otherarea_id for om in otherarea_maps]

        if type_id is not None:
            otherareas = Otherarea.objects.filter(
                id__in=otherarea_ids,
                type=type_id,
                is_active=True
            )
            otherarea_ids = [otherarea.id for otherarea in otherareas]

        return otherarea_ids


================================================================================
文件路径: python-backend\search\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from django.apps import apps


# 使用延迟加载的方式定义序列化器
def get_storearea_serializer():
    Storearea = apps.get_model('core', 'Storearea')

    class StoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            fields = '__all__'

    return StoreareaSerializer


def get_event_serializer():
    Event = apps.get_model('core', 'Event')

    class EventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = '__all__'

    return EventSerializer


def get_eventarea_serializer():
    Eventarea = apps.get_model('core', 'Eventarea')

    class EventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            fields = '__all__'

    return EventareaSerializer


def get_facility_serializer():
    Facility = apps.get_model('core', 'Facility')

    class FacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            fields = '__all__'

    return FacilitySerializer


def get_otherarea_serializer():
    Otherarea = apps.get_model('core', 'Otherarea')

    class OtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            fields = '__all__'

    return OtherareaSerializer


def get_simple_storearea_serializer():
    Storearea = apps.get_model('core', 'Storearea')

    class SimpleStoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            fields = ['id', 'store_name', 'type']

    return SimpleStoreareaSerializer


def get_simple_event_serializer():
    Event = apps.get_model('core', 'Event')

    class SimpleEventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = ['id', 'event_name', 'start_date', 'end_date']

    return SimpleEventSerializer


def get_simple_eventarea_serializer():
    Eventarea = apps.get_model('core', 'Eventarea')

    class SimpleEventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            fields = ['id', 'organizer_name', 'type']

    return SimpleEventareaSerializer


def get_simple_facility_serializer():
    Facility = apps.get_model('core', 'Facility')

    class SimpleFacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            fields = ['id', 'type']

    return SimpleFacilitySerializer


def get_simple_otherarea_serializer():
    Otherarea = apps.get_model('core', 'Otherarea')

    class SimpleOtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            fields = ['id', 'type', 'is_public']

    return SimpleOtherareaSerializer



================================================================================
文件路径: python-backend\search\services.py
--------------------------------------------------------------------------------

from rest_framework import status
from django.apps import apps
from .context import (
    StoreareaContext, EventContext, EventareaContext,
    FacilityContext, OtherareaContext, SearchElementContext
)


class SearchService:
    """搜索服务"""

    def __init__(self):
        self.storearea_ctx = StoreareaContext()
        self.event_ctx = EventContext()
        self.eventarea_ctx = EventareaContext()
        self.facility_ctx = FacilityContext()
        self.otherarea_ctx = OtherareaContext()
        self.element_ctx = SearchElementContext()

    # ========== 店铺搜索功能 ==========

    def get_storearea_by_id(self, storearea_id):
        """获取ID为<>的商铺区域的所有信息"""
        storearea = self.storearea_ctx.get_by_id(storearea_id)
        if not storearea:
            return None, {'error': 'Storearea not found'}, status.HTTP_404_NOT_FOUND
        return storearea, None, None

    def search_storearea_by_name(self, name):
        """按名称寻找店铺区域"""
        if not name:
            return None, {'error': 'Name parameter is required'}, status.HTTP_400_BAD_REQUEST
        storeareas = self.storearea_ctx.search_by_name(name)
        return storeareas, None, None

    def list_storearea_by_type(self, type_param):
        """返回指定类型店铺区域列表"""
        if type_param:
            try:
                type_id = int(type_param)
                storeareas = self.storearea_ctx.filter_by_type(type_id=type_id)
                return storeareas, {'type': type_id}, None
            except ValueError:
                return None, {'error': 'Invalid type parameter'}, status.HTTP_400_BAD_REQUEST
        else:
            storeareas = self.storearea_ctx.filter_by_type()
            return storeareas, None, None

    def get_storearea_events(self, storearea_id):
        """返回指定店铺区域的所有活动ID列表"""
        storearea = self.storearea_ctx.get_by_id(storearea_id)
        if not storearea or not storearea.is_active:
            return None, {'error': 'Storearea not found'}, status.HTTP_404_NOT_FOUND

        EventStorearea = apps.get_model('core', 'EventStorearea')
        event_relations = EventStorearea.objects.filter(storearea_id=storearea_id)
        event_ids = [relation.event_id for relation in event_relations]

        return {'storearea_id': storearea_id, 'event_ids': event_ids}, None, None

    def get_storearea_map_ids(self, storearea_id):
        """获取storearea_id为<>的活动区域所属的map_id"""
        storearea_maps = self.storearea_ctx.get_storearea_map_relations(storearea_id)
        map_ids = [storearea_map.map_id for storearea_map in storearea_maps]
        return {'storearea_id': storearea_id, 'map_ids': map_ids}, None, None

    def get_storearea_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且type为<>的所有storearea的id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            storearea_ids = self.element_ctx.get_storearea_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'storearea_ids': storearea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_all_storearea_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有storearea_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            storearea_ids = self.element_ctx.get_storearea_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'storearea_ids': storearea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST

    # ========== 活动搜索功能 ==========

    def get_event_by_id(self, event_id):
        """按ID寻找活动"""
        event = self.event_ctx.get_by_id(event_id)
        if not event:
            return None, {'error': 'Event not found'}, status.HTTP_404_NOT_FOUND
        return event, None, None

    def search_event_by_name(self, name):
        """按名称寻找活动"""
        if not name:
            return None, {'error': 'Name parameter is required'}, status.HTTP_400_BAD_REQUEST
        events = self.event_ctx.search_by_name(name)
        return events, None, None

    def list_event_by_type(self, type_param):
        """返回指定类型活动列表"""
        events = self.event_ctx.filter_active_events()

        if type_param:
            try:
                type_id = int(type_param)
                EventEventarea = apps.get_model('core', 'EventEventarea')
                event_ids = EventEventarea.objects.filter(
                    eventarea__type=type_id
                ).values_list('event_id', flat=True).distinct()

                events = events.filter(id__in=event_ids)
                return events, {'type': type_id}, None
            except ValueError:
                return None, {'error': 'Invalid type parameter'}, status.HTTP_400_BAD_REQUEST
        else:
            return events, None, None

    def get_event_areas(self, event_id):
        """返回参加该活动的区域ID列表"""
        event = self.event_ctx.get_by_id(event_id)
        if not event:
            return None, {'error': 'Event not found'}, status.HTTP_404_NOT_FOUND

        storearea_relations = self.event_ctx.get_event_storearea_relations(event_id)
        storearea_ids = [relation.storearea_id for relation in storearea_relations]

        eventarea_relations = self.event_ctx.get_event_eventarea_relations(event_id)
        eventarea_ids = [relation.eventarea_id for relation in eventarea_relations]

        result = {
            'event_id': event_id,
            'storearea_ids': storearea_ids,
            'eventarea_ids': eventarea_ids,
            'all_area_ids': storearea_ids + eventarea_ids
        }
        return result, None, None

    # ========== 活动区域功能 ==========

    def get_eventarea_by_id(self, eventarea_id):
        """获取id为<>的活动区域的所有信息"""
        eventarea = self.eventarea_ctx.get_by_id(eventarea_id)
        if not eventarea:
            return None, {'error': 'Eventarea not found'}, status.HTTP_404_NOT_FOUND
        return eventarea, None, None

    def get_eventarea_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且 type为<>的所有eventarea的id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            eventarea_ids = self.element_ctx.get_eventarea_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'eventarea_ids': eventarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_eventarea_map_ids(self, eventarea_id):
        """获取eventarea_id为<>的活动区域所属的map_id"""
        eventarea_maps = self.eventarea_ctx.get_eventarea_map_relations(eventarea_id)
        map_ids = [eventarea_map.map_id for eventarea_map in eventarea_maps]
        return {'eventarea_id': eventarea_id, 'map_ids': map_ids}, None, None

    def get_all_eventarea_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有eventarea_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            eventarea_ids = self.element_ctx.get_eventarea_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'eventarea_ids': eventarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST

    # ========== 设施功能 ==========

    def get_facility_by_id(self, facility_id):
        """获取id为<>的设施的所有信息"""
        facility = self.facility_ctx.get_by_id(facility_id)
        if not facility:
            return None, {'error': 'Facility not found'}, status.HTTP_404_NOT_FOUND
        return facility, None, None

    def get_facility_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且type为<>的所有设施id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            facility_ids = self.element_ctx.get_facility_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'facility_ids': facility_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_facility_map_ids(self, facility_id):
        """获取facility_id为<>的活动区域所属的map_id"""
        facility_maps = self.facility_ctx.get_facility_map_relations(facility_id)
        map_ids = [facility_map.map_id for facility_map in facility_maps]
        return {'facility_id': facility_id, 'map_ids': map_ids}, None, None

    def get_all_facility_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有facility_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            facility_ids = self.element_ctx.get_facility_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'facility_ids': facility_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST

    # ========== 其他区域功能 ==========

    def get_otherarea_by_id(self, otherarea_id):
        """获取id为<>的其他区域的所有信息"""
        otherarea = self.otherarea_ctx.get_by_id(otherarea_id)
        if not otherarea:
            return None, {'error': 'Otherarea not found'}, status.HTTP_404_NOT_FOUND
        return otherarea, None, None

    def get_otherarea_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且type为<>的所有otherarea的id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            otherarea_ids = self.element_ctx.get_otherarea_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'otherarea_ids': otherarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_otherarea_map_ids(self, otherarea_id):
        """获取otherarea_id为<>的活动区域所属的map_id"""
        otherarea_maps = self.otherarea_ctx.get_otherarea_map_relations(otherarea_id)
        map_ids = [otherarea_map.map_id for otherarea_map in otherarea_maps]
        return {'otherarea_id': otherarea_id, 'map_ids': map_ids}, None, None

    def get_all_otherarea_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有otherarea_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            otherarea_ids = self.element_ctx.get_otherarea_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'otherarea_ids': otherarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST


================================================================================
文件路径: python-backend\search\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\search\urls.py
--------------------------------------------------------------------------------

from django.urls import path
from . import views

urlpatterns = [
    # Search店铺功能
    path('storearea/<int:storearea_id>/', views.storearea_by_id, name='storearea-by-id'),
    path('storearea/search/', views.storearea_search, name='storearea-search'),
    path('storearea/list/', views.storearea_list_by_type, name='storearea-list-by-type'),
    path('storearea/<int:storearea_id>/events/', views.storearea_events, name='storearea-events'),

    # 新增的店铺区域功能
    path('storearea/<int:storearea_id>/map/', views.storearea_map_ids, name='storearea-map-ids'),
    path('storearea/list/map/', views.storearea_ids_by_map_and_type, name='storearea-ids-by-map-type'),
    path('storearea/list/all_by_map/', views.all_storearea_ids_by_map, name='all-storearea-ids-by-map'),

    # Search活动功能
    path('event/<int:event_id>/', views.event_by_id, name='event-by-id'),
    path('event/search/', views.event_search, name='event-search'),
    path('event/list/', views.event_list_by_type, name='event-list-by-type'),
    path('event/<int:event_id>/areas/', views.event_areas, name='event-areas'),

    # 新增的活动区域功能
    path('eventarea/<int:eventarea_id>/', views.eventarea_by_id, name='eventarea-by-id'),
    path('eventarea/list/ids_by_map_type/', views.eventarea_ids_by_map_and_type, name='eventarea-ids-by-map-type'),
    path('eventarea/<int:eventarea_id>/map/', views.eventarea_map_ids, name='eventarea-map-ids'),
    path('eventarea/list/all_by_map/', views.all_eventarea_ids_by_map, name='all-eventarea-ids-by-map'),

    # 新增的设施功能
    path('facility/<int:facility_id>/', views.facility_by_id, name='facility-by-id'),
    path('facility/list/ids_by_map_type/', views.facility_ids_by_map_and_type, name='facility-ids-by-map-type'),
    path('facility/<int:facility_id>/map/', views.facility_map_ids, name='facility-map-ids'),
    path('facility/list/all_by_map/', views.all_facility_ids_by_map, name='all-facility-ids-by-map'),

    # 新增的其他区域功能
    path('otherarea/<int:otherarea_id>/', views.otherarea_by_id, name='otherarea-by-id'),
    path('otherarea/list/ids_by_map_type/', views.otherarea_ids_by_map_and_type, name='otherarea-ids-by-map-type'),
    path('otherarea/<int:otherarea_id>/map/', views.otherarea_map_ids, name='otherarea-map-ids'),
    path('otherarea/list/all_by_map/', views.all_otherarea_ids_by_map, name='all-otherarea-ids-by-map'),
]


================================================================================
文件路径: python-backend\search\views.py
--------------------------------------------------------------------------------

from rest_framework.decorators import api_view
from rest_framework.response import Response
from .services import SearchService
from .serializers import (
    get_storearea_serializer, get_simple_storearea_serializer,
    get_event_serializer, get_simple_event_serializer,
    get_eventarea_serializer, get_simple_eventarea_serializer,
    get_facility_serializer, get_simple_facility_serializer,
    get_otherarea_serializer, get_simple_otherarea_serializer
)

search_service = SearchService()


# ========== 店铺搜索功能 ==========

@api_view(['GET'])
def storearea_by_id(request, storearea_id):
    """获取id为<>的商铺区域的所有信息"""
    result, error, status_code = search_service.get_storearea_by_id(storearea_id)
    if error:
        return Response(error, status=status_code)

    StoreareaSerializer = get_storearea_serializer()
    serializer = StoreareaSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def storearea_search(request):
    """按名称寻找店铺区域"""
    name = request.GET.get('name', '').strip()
    result, error, status_code = search_service.search_storearea_by_name(name)
    if error:
        return Response(error, status=status_code)

    StoreareaSerializer = get_storearea_serializer()
    serializer = StoreareaSerializer(result, many=True)
    return Response(serializer.data)


@api_view(['GET'])
def storearea_list_by_type(request):
    """返回指定类型店铺区域列表"""
    type_param = request.GET.get('type', '').strip()
    result, extra, error = search_service.list_storearea_by_type(type_param)
    if error:
        return Response(error, status=extra)

    if type_param:
        StoreareaSerializer = get_storearea_serializer()
        serializer = StoreareaSerializer(result, many=True)
        response_data = {'type': extra['type'], 'storeareas': serializer.data}
    else:
        categorized = {}
        SimpleStoreareaSerializer = get_simple_storearea_serializer()
        for storearea in result:
            type_key = storearea.type or 0
            if type_key not in categorized:
                categorized[type_key] = []
            serializer = SimpleStoreareaSerializer(storearea)
            categorized[type_key].append(serializer.data)
        response_data = categorized

    return Response(response_data)


@api_view(['GET'])
def storearea_events(request, storearea_id):
    """返回指定店铺区域的所有活动ID列表"""
    result, error, status_code = search_service.get_storearea_events(storearea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def storearea_map_ids(request, storearea_id):
    """获取storearea_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_storearea_map_ids(storearea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def storearea_ids_by_map_and_type(request):
    """获取map_id为<> 且type为<>的所有storearea的id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_storearea_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_storearea_ids_by_map(request):
    """获取map_id为<>的地图对应的所有storearea_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_storearea_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 活动搜索功能 ==========

@api_view(['GET'])
def event_by_id(request, event_id):
    """按ID寻找活动"""
    result, error, status_code = search_service.get_event_by_id(event_id)
    if error:
        return Response(error, status=status_code)

    EventSerializer = get_event_serializer()
    serializer = EventSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def event_search(request):
    """按名称寻找活动"""
    name = request.GET.get('name', '').strip()
    result, error, status_code = search_service.search_event_by_name(name)
    if error:
        return Response(error, status=status_code)

    EventSerializer = get_event_serializer()
    serializer = EventSerializer(result, many=True)
    return Response(serializer.data)


@api_view(['GET'])
def event_list_by_type(request):
    """返回指定类型活动列表"""
    type_param = request.GET.get('type', '').strip()
    result, extra, error = search_service.list_event_by_type(type_param)
    if error:
        return Response(error, status=extra)

    if type_param:
        EventSerializer = get_event_serializer()
        serializer = EventSerializer(result, many=True)
        response_data = {'type': extra['type'], 'events': serializer.data}
    else:
        categorized = {}
        SimpleEventSerializer = get_simple_event_serializer()

        for event in result:
            # 获取该活动关联的所有Eventarea类型
            from django.apps import apps
            EventEventarea = apps.get_model('core', 'EventEventarea')
            eventarea_types = EventEventarea.objects.filter(
                event_id=event.id
            ).values_list('eventarea__type', flat=True).distinct()

            if not eventarea_types:
                type_key = 0
                if type_key not in categorized:
                    categorized[type_key] = []
                serializer = SimpleEventSerializer(event)
                categorized[type_key].append(serializer.data)
            else:
                for eventarea_type in eventarea_types:
                    type_key = eventarea_type or 0
                    if type_key not in categorized:
                        categorized[type_key] = []

                    serializer = SimpleEventSerializer(event)
                    categorized[type_key].append(serializer.data)

        response_data = categorized

    return Response(response_data)


@api_view(['GET'])
def event_areas(request, event_id):
    """返回参加该活动的区域ID列表"""
    result, error, status_code = search_service.get_event_areas(event_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 活动区域功能 ==========

@api_view(['GET'])
def eventarea_by_id(request, eventarea_id):
    """获取id为<>的活动区域的所有信息"""
    result, error, status_code = search_service.get_eventarea_by_id(eventarea_id)
    if error:
        return Response(error, status=status_code)

    EventareaSerializer = get_eventarea_serializer()
    serializer = EventareaSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def eventarea_ids_by_map_and_type(request):
    """获取map_id为<> 且 type为<>的所有eventarea的id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_eventarea_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def eventarea_map_ids(request, eventarea_id):
    """获取eventarea_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_eventarea_map_ids(eventarea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_eventarea_ids_by_map(request):
    """获取map_id为<>的地图对应的所有eventarea_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_eventarea_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 设施功能 ==========

@api_view(['GET'])
def facility_by_id(request, facility_id):
    """获取id为<>的设施的所有信息"""
    result, error, status_code = search_service.get_facility_by_id(facility_id)
    if error:
        return Response(error, status=status_code)

    FacilitySerializer = get_facility_serializer()
    serializer = FacilitySerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def facility_ids_by_map_and_type(request):
    """获取map_id为<> 且type为<>的所有设施id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_facility_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def facility_map_ids(request, facility_id):
    """获取facility_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_facility_map_ids(facility_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_facility_ids_by_map(request):
    """获取map_id为<>的地图对应的所有facility_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_facility_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 其他区域功能 ==========

@api_view(['GET'])
def otherarea_by_id(request, otherarea_id):
    """获取id为<>的其他区域的所有信息"""
    result, error, status_code = search_service.get_otherarea_by_id(otherarea_id)
    if error:
        return Response(error, status=status_code)

    OtherareaSerializer = get_otherarea_serializer()
    serializer = OtherareaSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def otherarea_ids_by_map_and_type(request):
    """获取map_id为<> 且type为<>的所有otherarea的id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_otherarea_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def otherarea_map_ids(request, otherarea_id):
    """获取otherarea_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_otherarea_map_ids(otherarea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_otherarea_ids_by_map(request):
    """获取map_id为<>的地图对应的所有otherarea_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_otherarea_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)



================================================================================
文件路径: python-backend\search\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\search\migrations\__init__.py
--------------------------------------------------------------------------------






================================================================================
文件路径: python-backend\manage.py
--------------------------------------------------------------------------------

#!/usr/bin/env python
"""
Command-line utility for administrative tasks.

# For more information about this file, visit
# https://docs.djangoproject.com/en/2.1/ref/django-admin/
"""

import os
import sys

import django

if __name__ == '__main__':
    os.environ.setdefault(
        'DJANGO_SETTINGS_MODULE',
        'python_backend.settings')
    django.setup()

    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)



================================================================================
文件路径: python-backend\requirements.txt
--------------------------------------------------------------------------------

Django==5.2.8
asgiref==3.10.0
pip==25.0.1
psycopg2-binary==2.9.11
sqlparse==0.5.3
tzdata==2025.2
virtualenv==12.1.1
djangorestframework==3.15.2
markdown==3.7
django-filter==24.3
django-cors-headers==4.0.0


================================================================================
文件路径: python-backend\client\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\client\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class ClientConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'client'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\client\models.py
--------------------------------------------------------------------------------

from django.db import models

# Create your models here.



================================================================================
文件路径: python-backend\client\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\client\views.py
--------------------------------------------------------------------------------

from django.shortcuts import render

# Create your views here.
from rest_framework import viewsets, status

from rest_framework.decorators import action

from rest_framework.response import Response


================================================================================
文件路径: python-backend\client\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\client\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\core\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\core\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig

class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core'


================================================================================
文件路径: python-backend\core\context.py
--------------------------------------------------------------------------------

from core.models import *
from django.db.models import Q

class BaseContext:
    """基础 CRUD Context"""
    def __init__(self, model):
        self.model = model

    def get_by_id(self, pk):
        try:
            return self.model.objects.get(pk=pk)
        except self.model.DoesNotExist:
            return None

    def list_all(self):
        return self.model.objects.all()

    def create(self, **kwargs):
        return self.model.objects.create(**kwargs)

    def update(self, instance, **kwargs):
        for key, value in kwargs.items():
            setattr(instance, key, value)
        instance.save()
        return instance

    def delete(self, instance):
        instance.delete()


================================================================================
文件路径: python-backend\core\models.py
--------------------------------------------------------------------------------

from django.contrib.gis.db import models

# Create your models here.
class Admin(models.Model):
    account = models.CharField(unique=True, max_length=64)
    password = models.CharField(max_length=256)
    name = models.CharField(max_length=64, blank=True, null=True)

    class Meta:
        db_table = 'admin'
        # managed = False


class Building(models.Model):
    name = models.CharField(unique=True, max_length=64)
    address = models.CharField(max_length=256)
    description = models.CharField(max_length=256, blank=True, null=True)

    class Meta:
        db_table = 'building'
        # managed = False


class Event(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    description = models.CharField(max_length=256, blank=True, null=True)
    event_name = models.CharField(max_length=64)
    start_date = models.DateTimeField()
    end_date = models.DateTimeField()
    image_url = models.CharField(max_length=256, blank=True, null=True)

    class Meta:
        db_table = 'event'
        # managed = False


class EventEventarea(models.Model):
    pk = models.CompositePrimaryKey('event_id', 'eventarea_id')
    event = models.ForeignKey(Event, on_delete=models.CASCADE)
    eventarea = models.ForeignKey('Eventarea', on_delete=models.CASCADE)

    class Meta:
        db_table = 'event_eventarea'
        # managed = False
        # unique_together = (('event', 'eventarea'),)


class EventStorearea(models.Model):
    pk = models.CompositePrimaryKey('event_id', 'storearea_id')
    event = models.ForeignKey(Event, on_delete=models.CASCADE)
    storearea = models.ForeignKey('Storearea', on_delete=models.CASCADE)

    class Meta:
        db_table = 'event_storearea'
        # unique_together = (('event', 'storearea'),)
        # managed = False


class Eventarea(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    shape = models.PolygonField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    organizer_name = models.CharField(max_length=64)
    organizer_phone = models.CharField(max_length=16)
    type = models.IntegerField(blank=True, null=True)

    class Meta:
        db_table = 'eventarea'
        # managed = False


class EventareaMap(models.Model):
    pk = models.CompositePrimaryKey('eventarea_id', 'map_id')
    eventarea = models.ForeignKey(Eventarea, on_delete=models.CASCADE)
    map = models.ForeignKey('Map', on_delete=models.CASCADE)

    class Meta:
        db_table = 'eventarea_map'
        # unique_together = (('eventarea', 'map'),)
        # managed = False


class Facility(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    location = models.PointField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    type = models.IntegerField()

    class Meta:
        db_table = 'facility'
        # managed = False


class FacilityMap(models.Model):
    pk = models.CompositePrimaryKey('facility_id', 'map_id')
    facility = models.ForeignKey(Facility, on_delete=models.CASCADE)
    map = models.ForeignKey('Map', on_delete=models.CASCADE)

    class Meta:
        db_table = 'facility_map'
        # unique_together = (('facility', 'map'),)
        # managed = False


class Map(models.Model):
    building = models.ForeignKey(Building, models.CASCADE)
    floor_number = models.IntegerField()
    detail = models.GeometryCollectionField(srid=2385)

    class Meta:
        db_table = 'map'
        unique_together = (('building', 'floor_number'),)
        # managed = False


class Otherarea(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    shape = models.PolygonField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    type = models.IntegerField()
    is_public = models.BooleanField(blank=True, null=True)

    class Meta:
        db_table = 'otherarea'
        # managed = False


class OtherareaMap(models.Model):
    pk = models.CompositePrimaryKey('otherarea_id', 'map_id')
    otherarea = models.ForeignKey(Otherarea, on_delete=models.CASCADE)
    map = models.ForeignKey(Map, on_delete=models.CASCADE)

    class Meta:
        db_table = 'otherarea_map'
        # managed = False
        # unique_together = (('otherarea', 'map'),)


class Storearea(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    shape = models.PolygonField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    store_name = models.CharField(max_length=64)
    owner_name = models.CharField(max_length=64)
    owner_phone = models.CharField(max_length=16)
    logo_url = models.CharField(max_length=256, blank=True, null=True)
    open_time = models.TimeField(blank=True, null=True)
    close_time = models.TimeField(blank=True, null=True)
    type = models.IntegerField(blank=True, null=True)
    api_url = models.CharField(max_length=256, blank=True, null=True)

    class Meta:
        db_table = 'storearea'
        # managed = False


class StoreareaMap(models.Model):
    pk = models.CompositePrimaryKey('storearea_id', 'map_id')
    storearea = models.ForeignKey(Storearea, on_delete=models.CASCADE)
    map = models.ForeignKey(Map, on_delete=models.CASCADE)

    class Meta:
        db_table = 'storearea_map'
        # unique_together = (('storearea', 'map'),)
        # managed = False


================================================================================
文件路径: python-backend\core\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\core\views.py
--------------------------------------------------------------------------------

from django.shortcuts import render

# Create your views here.



================================================================================
文件路径: python-backend\core\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\core\migrations\0001_initial.py
--------------------------------------------------------------------------------

# Generated by Django 5.2.8 on 2025-12-10 02:55

import django.contrib.gis.db.models.fields
import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Admin',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('account', models.CharField(max_length=64, unique=True)),
                ('password', models.CharField(max_length=256)),
                ('name', models.CharField(blank=True, max_length=64, null=True)),
            ],
            options={
                'db_table': 'admin',
            },
        ),
        migrations.CreateModel(
            name='Building',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=64, unique=True)),
                ('address', models.CharField(max_length=256)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
            ],
            options={
                'db_table': 'building',
            },
        ),
        migrations.CreateModel(
            name='Event',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('event_name', models.CharField(max_length=64)),
                ('start_date', models.DateTimeField()),
                ('end_date', models.DateTimeField()),
                ('image_url', models.CharField(blank=True, max_length=256, null=True)),
            ],
            options={
                'db_table': 'event',
            },
        ),
        migrations.CreateModel(
            name='Eventarea',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('shape', django.contrib.gis.db.models.fields.PolygonField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('organizer_name', models.CharField(max_length=64)),
                ('organizer_phone', models.CharField(max_length=16)),
                ('type', models.IntegerField(blank=True, null=True)),
            ],
            options={
                'db_table': 'eventarea',
            },
        ),
        migrations.CreateModel(
            name='Facility',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('location', django.contrib.gis.db.models.fields.PointField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('type', models.IntegerField()),
            ],
            options={
                'db_table': 'facility',
            },
        ),
        migrations.CreateModel(
            name='Otherarea',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('shape', django.contrib.gis.db.models.fields.PolygonField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('type', models.IntegerField()),
                ('is_public', models.BooleanField(blank=True, null=True)),
            ],
            options={
                'db_table': 'otherarea',
            },
        ),
        migrations.CreateModel(
            name='Storearea',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('shape', django.contrib.gis.db.models.fields.PolygonField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('store_name', models.CharField(max_length=64)),
                ('owner_name', models.CharField(max_length=64)),
                ('owner_phone', models.CharField(max_length=16)),
                ('logo_url', models.CharField(blank=True, max_length=256, null=True)),
                ('open_time', models.TimeField(blank=True, null=True)),
                ('close_time', models.TimeField(blank=True, null=True)),
                ('type', models.IntegerField(blank=True, null=True)),
                ('api_url', models.CharField(blank=True, max_length=256, null=True)),
            ],
            options={
                'db_table': 'storearea',
            },
        ),
        migrations.CreateModel(
            name='EventEventarea',
            fields=[
                ('pk', models.CompositePrimaryKey('event_id', 'eventarea_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('event', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.event')),
                ('eventarea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.eventarea')),
            ],
            options={
                'db_table': 'event_eventarea',
            },
        ),
        migrations.CreateModel(
            name='Map',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('floor_number', models.IntegerField()),
                ('detail', django.contrib.gis.db.models.fields.GeometryCollectionField(srid=2385)),
                ('building', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.building')),
            ],
            options={
                'db_table': 'map',
                'unique_together': {('building', 'floor_number')},
            },
        ),
        migrations.CreateModel(
            name='FacilityMap',
            fields=[
                ('pk', models.CompositePrimaryKey('facility_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('facility', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.facility')),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
            ],
            options={
                'db_table': 'facility_map',
            },
        ),
        migrations.CreateModel(
            name='EventareaMap',
            fields=[
                ('pk', models.CompositePrimaryKey('eventarea_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('eventarea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.eventarea')),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
            ],
            options={
                'db_table': 'eventarea_map',
            },
        ),
        migrations.CreateModel(
            name='OtherareaMap',
            fields=[
                ('pk', models.CompositePrimaryKey('otherarea_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
                ('otherarea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.otherarea')),
            ],
            options={
                'db_table': 'otherarea_map',
            },
        ),
        migrations.CreateModel(
            name='EventStorearea',
            fields=[
                ('pk', models.CompositePrimaryKey('event_id', 'storearea_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('event', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.event')),
                ('storearea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.storearea')),
            ],
            options={
                'db_table': 'event_storearea',
            },
        ),
        migrations.CreateModel(
            name='StoreareaMap',
            fields=[
                ('pk', models.CompositePrimaryKey('storearea_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
                ('storearea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.storearea')),
            ],
            options={
                'db_table': 'storearea_map',
            },
        ),
    ]



================================================================================
文件路径: python-backend\core\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\editor\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\editor\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class EditorConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'editor'



================================================================================
文件路径: python-backend\editor\context.py
--------------------------------------------------------------------------------

from django.contrib.gis.geos import GEOSGeometry
from core.models import (
    Event,
    Storearea,
    StoreareaMap,
    EventStorearea,
    EventEventarea,
    Eventarea,
    EventareaMap,
    Otherarea,
    OtherareaMap,
    Facility,
    FacilityMap
)


class StoreareaContext:
    """
    店铺区域（Storearea）的数据访问层
    负责与数据库交互，仅提供shape属性相关的操作
    """

    @staticmethod
    def get_all():
        """获取所有店铺区域"""
        return Storearea.objects.all()

    @staticmethod
    def get_by_id(storearea_id):
        """根据ID获取店铺区域"""
        return Storearea.objects.filter(id=storearea_id).first()

    @staticmethod
    def create(shape, map_id=None):
        """创建新的店铺区域，并可选绑定到指定地图"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            # 这样无论是WKT还是GeoJSON格式，都会使用正确的SRID
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        storearea = Storearea.objects.create(shape=shape_geom)
        # 绑定到地图
        if map_id is not None:
            StoreareaMap.objects.create(storearea=storearea, map_id=map_id)
        return storearea

    @staticmethod
    def update_shape(storearea_id, shape):
        """更新店铺区域的形状"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        Storearea.objects.filter(id=storearea_id).update(shape=shape_geom)
        return StoreareaContext.get_by_id(storearea_id)

    @staticmethod
    def delete(storearea_id):
        """删除店铺区域"""
        Storearea.objects.filter(id=storearea_id).delete()

    @staticmethod
    def get_events_by_storearea(storearea_id):
        """获取店铺关联的所有活动ID"""
        event_relations = EventStorearea.objects.filter(storearea_id=storearea_id)
        return [relation.event_id for relation in event_relations]


class EventContext:
    """
    活动（Event）的数据访问层
    负责与数据库交互，仅提供shape属性相关的操作
    """

    @staticmethod
    def get_all():
        """获取所有活动"""
        return Event.objects.all()

    @staticmethod
    def get_by_id(event_id):
        """根据ID获取活动"""
        return Event.objects.filter(id=event_id).first()



    @staticmethod
    def get_storeareas_by_event(event_id):
        """获取活动关联的所有店铺区域ID"""
        storearea_relations = EventStorearea.objects.filter(event_id=event_id)
        return [relation.storearea_id for relation in storearea_relations]

    @staticmethod
    def get_eventareas_by_event(event_id):
        """获取活动关联的所有活动区域ID"""
        eventarea_relations = EventEventarea.objects.filter(event_id=event_id)
        return [relation.eventarea_id for relation in eventarea_relations]

    @staticmethod
    def add_storearea_relation(event_id, storearea_id):
        """添加活动与店铺区域的关联关系"""
        return EventStorearea.objects.get_or_create(event_id=event_id, storearea_id=storearea_id)

    @staticmethod
    def remove_storearea_relation(event_id, storearea_id):
        """移除活动与店铺区域的关联关系"""
        return EventStorearea.objects.filter(event_id=event_id, storearea_id=storearea_id).delete()

    @staticmethod
    def add_eventarea_relation(event_id, eventarea_id):
        """添加活动与活动区域的关联关系"""
        return EventEventarea.objects.get_or_create(event_id=event_id, eventarea_id=eventarea_id)

    @staticmethod
    def remove_eventarea_relation(event_id, eventarea_id):
        """移除活动与活动区域的关联关系"""
        return EventEventarea.objects.filter(event_id=event_id, eventarea_id=eventarea_id).delete()


class EventareaContext:
    """
    活动区域（Eventarea）的数据访问层
    负责与数据库交互，提供基本的CRUD操作
    """

    @staticmethod
    def get_all():
        """获取所有活动区域"""
        return Eventarea.objects.all()

    @staticmethod
    def get_by_id(eventarea_id):
        """根据ID获取活动区域"""
        return Eventarea.objects.filter(id=eventarea_id).first()

    @staticmethod
    def create(shape, map_id=None):
        """创建新的活动区域，并可选绑定到指定地图"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        eventarea = Eventarea.objects.create(shape=shape_geom)
        if map_id is not None:
            EventareaMap.objects.create(eventarea=eventarea, map_id=map_id)
        return eventarea

    @staticmethod
    def update_shape(eventarea_id, shape):
        """更新活动区域的形状"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        Eventarea.objects.filter(id=eventarea_id).update(shape=shape_geom)
        return EventareaContext.get_by_id(eventarea_id)

    @staticmethod
    def delete(eventarea_id):
        """删除活动区域"""
        Eventarea.objects.filter(id=eventarea_id).delete()


class OtherareaContext:
    """
    其他区域（Otherarea）的数据访问层
    负责与数据库交互，提供基本的CRUD操作
    """

    @staticmethod
    def get_all():
        """获取所有其他区域"""
        return Otherarea.objects.all()

    @staticmethod
    def get_by_id(otherarea_id):
        """根据ID获取其他区域"""
        return Otherarea.objects.filter(id=otherarea_id).first()

    @staticmethod
    def create(shape, map_id=None, type_val=None):
        """创建新的其他区域，并可选绑定到指定地图"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        otherarea = Otherarea.objects.create(
            shape=shape_geom,
            type=type_val if type_val is not None else 0  # 默认 0，避免 NOT NULL 约束报错
        )
        if map_id is not None:
            OtherareaMap.objects.create(otherarea=otherarea, map_id=map_id)
        return otherarea

    @staticmethod
    def update_shape(otherarea_id, shape):
        """更新其他区域的形状"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        Otherarea.objects.filter(id=otherarea_id).update(shape=shape_geom)
        return OtherareaContext.get_by_id(otherarea_id)

    @staticmethod
    def delete(otherarea_id):
        """删除其他区域"""
        Otherarea.objects.filter(id=otherarea_id).delete()


class FacilityContext:
    """
    设施（Facility）的数据访问层
    """

    @staticmethod
    def get_all():
        return Facility.objects.all()

    @staticmethod
    def get_by_id(facility_id):
        return Facility.objects.filter(id=facility_id).first()

    @staticmethod
    def create(location, map_id=None, type_val=None):
        try:
            loc_geom = GEOSGeometry(location)
            if loc_geom.srid != 2385:
                loc_geom.srid = 2385
        except Exception as e:
            raise ValueError(f"Invalid spatial data: {str(e)}")

        facility = Facility.objects.create(
            location=loc_geom,
            type=type_val if type_val is not None else 0
        )
        if map_id is not None:
            FacilityMap.objects.create(facility=facility, map_id=map_id)
        return facility

    @staticmethod
    def update_location(facility_id, location):
        """更新设施位置"""
        try:
            loc_geom = GEOSGeometry(location)
            if loc_geom.srid != 2385:
                loc_geom.srid = 2385
        except Exception as e:
            raise ValueError(f"Invalid spatial data: {str(e)}")

        Facility.objects.filter(id=facility_id).update(location=loc_geom)
        return FacilityContext.get_by_id(facility_id)

    @staticmethod
    def delete(facility_id):
        Facility.objects.filter(id=facility_id).delete()


================================================================================
文件路径: python-backend\editor\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from django.apps import apps


def get_storearea_serializer():
    """获取 Storearea 序列化器"""
    Storearea = apps.get_model('core', 'Storearea')

    class StoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            fields = '__all__'
            # 由于使用了 managed=False，需要明确指定字段
            # 但 ModelSerializer 会自动从模型获取字段

    return StoreareaSerializer


def get_event_serializer():
    """获取 Event 序列化器"""
    Event = apps.get_model('core', 'Event')

    class EventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = '__all__'

    return EventSerializer


def get_eventarea_serializer():
    """获取活动区域序列化器"""
    Eventarea = apps.get_model('core', 'Eventarea')
    
    class EventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            fields = '__all__'
    
    return EventareaSerializer


def get_otherarea_serializer():
    """获取其他区域序列化器"""
    Otherarea = apps.get_model('core', 'Otherarea')
    
    class OtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            fields = '__all__'
    
    return OtherareaSerializer


def get_facility_serializer():
    """获取设施序列化器"""
    Facility = apps.get_model('core', 'Facility')

    class FacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            fields = '__all__'

    return FacilitySerializer


================================================================================
文件路径: python-backend\editor\services.py
--------------------------------------------------------------------------------

from .context import StoreareaContext, EventContext, EventareaContext, OtherareaContext,FacilityContext


class StoreareaService:
    """
    店铺区域（Storearea）的业务层
    负责处理业务逻辑，调用数据访问层方法，仅处理shape属性相关操作
    """

    @staticmethod
    def get_all_storeareas():
        """获取所有店铺区域"""
        return StoreareaContext.get_all()

    @staticmethod
    def get_storearea_by_id(storearea_id):
        """根据ID获取店铺区域"""
        return StoreareaContext.get_by_id(storearea_id)

    @staticmethod
    def create_storearea(shape, map_id=None):
        """创建新的店铺区域，并可选绑定到指定地图"""
        return StoreareaContext.create(shape, map_id)

    @staticmethod
    def update_shape(storearea_id, shape):
        """更新店铺区域的形状"""
        # 可以在这里添加业务逻辑验证
        return StoreareaContext.update_shape(storearea_id, shape)

    @staticmethod
    def delete_storearea(storearea_id):
        """删除店铺区域"""
        # 可以在这里添加业务逻辑验证
        return StoreareaContext.delete(storearea_id)

    @staticmethod
    def get_events_for_storearea(storearea_id):
        """获取店铺关联的所有活动ID"""
        return StoreareaContext.get_events_by_storearea(storearea_id)


class EventService:
    """
    活动（Event）的业务层
    负责处理业务逻辑，调用数据访问层方法，仅处理shape属性相关操作
    """

    @staticmethod
    def get_all_events():
        """获取所有活动"""
        return EventContext.get_all()

    @staticmethod
    def get_event_by_id(event_id):
        """根据ID获取活动"""
        return EventContext.get_by_id(event_id)



    @staticmethod
    def get_areas_for_event(event_id):
        """获取活动关联的所有区域ID（包括店铺区域和活动区域）"""
        storearea_ids = EventContext.get_storeareas_by_event(event_id)
        eventarea_ids = EventContext.get_eventareas_by_event(event_id)
        return {
            'storearea_ids': storearea_ids,
            'eventarea_ids': eventarea_ids,
            'all_area_ids': storearea_ids + eventarea_ids
        }

    @staticmethod
    def add_storearea_to_event(event_id, storearea_id):
        """添加活动与店铺区域的关联关系"""
        # 可以在这里添加业务逻辑验证（如检查活动和店铺是否存在等）
        return EventContext.add_storearea_relation(event_id, storearea_id)

    @staticmethod
    def remove_storearea_from_event(event_id, storearea_id):
        """移除活动与店铺区域的关联关系"""
        # 可以在这里添加业务逻辑验证
        return EventContext.remove_storearea_relation(event_id, storearea_id)

    @staticmethod
    def add_eventarea_to_event(event_id, eventarea_id):
        """添加活动与活动区域的关联关系"""
        # 可以在这里添加业务逻辑验证（如检查活动和活动区域是否存在等）
        return EventContext.add_eventarea_relation(event_id, eventarea_id)

    @staticmethod
    def remove_eventarea_from_event(event_id, eventarea_id):
        """移除活动与活动区域的关联关系"""
        # 可以在这里添加业务逻辑验证
        return EventContext.remove_eventarea_relation(event_id, eventarea_id)


class EventareaService:
    """
    活动区域（Eventarea）的业务层
    负责处理业务逻辑，调用数据访问层方法
    注意：在editor模块中只处理shape属性的更新
    """

    @staticmethod
    def get_all_eventareas():
        """获取所有活动区域"""
        return EventareaContext.get_all()

    @staticmethod
    def get_eventarea_by_id(eventarea_id):
        """根据ID获取活动区域"""
        return EventareaContext.get_by_id(eventarea_id)

    @staticmethod
    def create_eventarea(shape, map_id=None):
        """创建新的活动区域，并可选绑定到指定地图"""
        return EventareaContext.create(shape, map_id)

    @staticmethod
    def update_eventarea_shape(eventarea_id, shape):
        """更新活动区域的形状"""
        # 可以在这里添加业务逻辑验证（如形状有效性检查等）
        return EventareaContext.update_shape(eventarea_id, shape)

    @staticmethod
    def delete_eventarea(eventarea_id):
        """删除活动区域"""
        # 可以在这里添加业务逻辑验证
        return EventareaContext.delete(eventarea_id)


class OtherareaService:
    """
    其他区域（Otherarea）的业务层
    负责处理业务逻辑，调用数据访问层方法
    注意：在editor模块中只处理shape属性的更新
    """

    @staticmethod
    def get_all_otherareas():
        """获取所有其他区域"""
        return OtherareaContext.get_all()

    @staticmethod
    def get_otherarea_by_id(otherarea_id):
        """根据ID获取其他区域"""
        return OtherareaContext.get_by_id(otherarea_id)

    @staticmethod
    def create_otherarea(shape, map_id=None, type_val=None):
        """创建新的其他区域，并可选绑定到指定地图"""
        return OtherareaContext.create(shape, map_id, type_val)

    @staticmethod
    def update_otherarea_shape(otherarea_id, shape):
        """更新其他区域的形状"""
        # 可以在这里添加业务逻辑验证（如形状有效性检查等）
        return OtherareaContext.update_shape(otherarea_id, shape)

    @staticmethod
    def delete_otherarea(otherarea_id):
        """删除其他区域"""
        # 可以在这里添加业务逻辑验证
        return OtherareaContext.delete(otherarea_id)

class FacilityService:
    """
    设施（Facility）的业务层
    """
    @staticmethod
    def get_all_facilities():
        return FacilityContext.get_all()

    @staticmethod
    def get_facility_by_id(facility_id):
        return FacilityContext.get_by_id(facility_id)

    @staticmethod
    def create_facility(location, map_id=None, type_val=None):
        return FacilityContext.create(location, map_id, type_val)

    @staticmethod
    def update_facility_location(facility_id, location):
        return FacilityContext.update_location(facility_id, location)

    @staticmethod
    def delete_facility(facility_id):
        return FacilityContext.delete(facility_id)


================================================================================
文件路径: python-backend\editor\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\editor\urls.py
--------------------------------------------------------------------------------

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

# 创建路由器并注册视图集
router = DefaultRouter()
router.register(r'storearea', views.StoreareaViewSet, basename='editor_storearea')
router.register(r'event', views.EventViewSet, basename='editor_event')
router.register(r'eventarea', views.EventareaViewSet, basename='editor_eventarea')
router.register(r'otherarea', views.OtherareaViewSet, basename='editor_otherarea')
router.register(r'facility', views.FacilityViewSet, basename='editor_facility')

urlpatterns = [
    # 包含路由器生成的所有URL
    path('', include(router.urls)),
]




================================================================================
文件路径: python-backend\editor\views.py
--------------------------------------------------------------------------------

from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from django.shortcuts import get_object_or_404
from .serializers import get_storearea_serializer, get_event_serializer, get_eventarea_serializer, get_otherarea_serializer, get_facility_serializer
from .services import StoreareaService, EventService, EventareaService, OtherareaService, FacilityService


class StoreareaViewSet(viewsets.ModelViewSet):
    """
    店铺区域（Storearea）的视图集
    
    注意：在editor模块中只处理shape属性的更新，其他属性在management中实现
    
    支持的操作：
    - GET /api/editor/storearea/ - 获取所有店铺区域列表
    - GET /api/editor/storearea/{id}/ - 获取指定店铺区域详情
    - POST /api/editor/storearea/ - 创建店铺区域（仅支持shape属性）
    - PATCH /api/editor/storearea/{id}/ - 部分更新店铺区域（仅支持shape属性）
    - DELETE /api/editor/storearea/{id}/ - 删除店铺区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_storearea_serializer()
    
    def get_queryset(self):
        """获取所有店铺区域"""
        return StoreareaService.get_all_storeareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有店铺区域列表"""
        storeareas = StoreareaService.get_all_storeareas()
        serializer = self.get_serializer(storeareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定店铺区域详情"""
        storearea = get_object_or_404(StoreareaService.get_all_storeareas(), pk=pk)
        serializer = self.get_serializer(storearea)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新店铺区域"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """部分更新店铺区域（仅支持shape属性）"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be updated in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        storearea = get_object_or_404(StoreareaService.get_all_storeareas(), pk=pk)
        shape = request.data.get('shape')
        
        updated_storearea = StoreareaService.update_shape(pk, shape)
        serializer = self.get_serializer(updated_storearea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建店铺区域（仅支持shape属性），并绑定到指定地图"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be provided when creating storearea in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        shape = request.data.get('shape')
        map_id = request.data.get('map_id')
        new_storearea = StoreareaService.create_storearea(shape, map_id)
        serializer = self.get_serializer(new_storearea)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    def destroy(self, request, pk=None):
        """删除店铺区域"""
        StoreareaService.delete_storearea(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)
    
    @action(detail=True, methods=['get'])
    def events(self, request, pk=None):
        """获取店铺关联的所有活动ID"""
        event_ids = StoreareaService.get_events_for_storearea(pk)
        return Response({
            'storearea_id': pk,
            'event_ids': event_ids
        })


class EventViewSet(viewsets.ModelViewSet):
    """
    活动（Event）的视图集
    
    注意：Event模型没有shape字段，因此不支持shape属性更新

    支持的操作：
    - GET /api/editor/event/ - 获取所有活动列表
    - GET /api/editor/event/{id}/ - 获取指定活动详情
    - GET /api/editor/event/{id}/areas/ - 获取活动关联的所有区域ID
    - POST/DELETE /api/editor/event/{id}/storeareas/ - 管理活动与店铺区域的关联关系
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_event_serializer()
    
    def get_queryset(self):
        """获取所有活动"""
        return EventService.get_all_events()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动列表"""
        events = EventService.get_all_events()
        serializer = self.get_serializer(events, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动详情"""
        event = get_object_or_404(EventService.get_all_events(), pk=pk)
        serializer = self.get_serializer(event)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新活动"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """不允许在editor模块中更新活动"""
        return Response(
            {'error': 'Update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def create(self, request, *args, **kwargs):
        """不允许在editor模块中创建活动"""
        return Response(
            {'error': 'Create not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def destroy(self, request, pk=None):
        """不允许在editor模块中删除活动"""
        return Response(
            {'error': 'Delete not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    @action(detail=True, methods=['get'])
    def areas(self, request, pk=None):
        """获取活动关联的所有区域ID（包括店铺区域和活动区域）"""
        areas = EventService.get_areas_for_event(pk)
        return Response({
            'event_id': pk,
            'storearea_ids': areas['storearea_ids'],
            'eventarea_ids': areas['eventarea_ids'],
            'all_area_ids': areas['all_area_ids']
        })
    
    @action(detail=True, methods=['post', 'delete'])
    def storeareas(self, request, pk=None):
        """管理活动与店铺区域的关联关系"""
        if request.method == 'POST':
            # 添加关联
            storearea_id = request.data.get('storearea_id')
            if not storearea_id:
                return Response(
                    {'error': 'storearea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            relation, created = EventService.add_storearea_to_event(pk, storearea_id)
            
            if created:
                return Response(
                    {'message': 'Relation created successfully'},
                    status=status.HTTP_201_CREATED
                )
            else:
                return Response(
                    {'message': 'Relation already exists'},
                    status=status.HTTP_200_OK
                )
        
        elif request.method == 'DELETE':
            # 删除关联
            storearea_id = request.data.get('storearea_id')
            if not storearea_id:
                return Response(
                    {'error': 'storearea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            deleted_count, _ = EventService.remove_storearea_from_event(pk, storearea_id)
            
            if deleted_count > 0:
                return Response(
                    {'message': 'Relation deleted successfully'},
                    status=status.HTTP_204_NO_CONTENT
                )
            else:
                return Response(
                    {'error': 'Relation not found'},
                    status=status.HTTP_404_NOT_FOUND
                )


class EventareaViewSet(viewsets.ModelViewSet):
    """
    活动区域（Eventarea）的视图集
    
    注意：在editor模块中只处理shape属性的更新，其他属性在management中实现
    
    支持的操作：
    - GET /api/editor/eventarea/ - 获取所有活动区域列表
    - GET /api/editor/eventarea/{id}/ - 获取指定活动区域详情
    - POST /api/editor/eventarea/ - 创建活动区域（仅支持shape属性）
    - PATCH /api/editor/eventarea/{id}/ - 部分更新活动区域（仅支持shape属性）
    - DELETE /api/editor/eventarea/{id}/ - 删除活动区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_eventarea_serializer()
    
    def get_queryset(self):
        """获取所有活动区域"""
        return EventareaService.get_all_eventareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动区域列表"""
        eventareas = EventareaService.get_all_eventareas()
        serializer = self.get_serializer(eventareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动区域详情"""
        eventarea = get_object_or_404(EventareaService.get_all_eventareas(), pk=pk)
        serializer = self.get_serializer(eventarea)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新活动区域"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """部分更新活动区域（仅支持shape属性）"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be updated in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        eventarea = get_object_or_404(EventareaService.get_all_eventareas(), pk=pk)
        shape = request.data.get('shape')
        
        updated_eventarea = EventareaService.update_eventarea_shape(pk, shape)
        serializer = self.get_serializer(updated_eventarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建活动区域（仅支持shape属性），并绑定到指定地图"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be provided when creating eventarea in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        shape = request.data.get('shape')
        map_id = request.data.get('map_id')
        new_eventarea = EventareaService.create_eventarea(shape, map_id)
        serializer = self.get_serializer(new_eventarea)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    def destroy(self, request, pk=None):
        """删除活动区域"""
        EventareaService.delete_eventarea(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)


class OtherareaViewSet(viewsets.ModelViewSet):
    """
    其他区域（Otherarea）的视图集
    
    注意：在editor模块中只处理shape属性的更新，其他属性在management中实现
    
    支持的操作：
    - GET /api/editor/otherarea/ - 获取所有其他区域列表
    - GET /api/editor/otherarea/{id}/ - 获取指定其他区域详情
    - POST /api/editor/otherarea/ - 创建其他区域（仅支持shape属性）
    - PATCH /api/editor/otherarea/{id}/ - 部分更新其他区域（仅支持shape属性）
    - DELETE /api/editor/otherarea/{id}/ - 删除其他区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_otherarea_serializer()
    
    def get_queryset(self):
        """获取所有其他区域"""
        return OtherareaService.get_all_otherareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有其他区域列表"""
        otherareas = OtherareaService.get_all_otherareas()
        serializer = self.get_serializer(otherareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定其他区域详情"""
        otherarea = get_object_or_404(OtherareaService.get_all_otherareas(), pk=pk)
        serializer = self.get_serializer(otherarea)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新其他区域"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """部分更新其他区域（仅支持shape属性）"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be updated in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        otherarea = get_object_or_404(OtherareaService.get_all_otherareas(), pk=pk)
        shape = request.data.get('shape')
        
        updated_otherarea = OtherareaService.update_otherarea_shape(pk, shape)
        serializer = self.get_serializer(updated_otherarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建其他区域（仅支持shape属性），并绑定到指定地图"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be provided when creating otherarea in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        shape = request.data.get('shape')
        map_id = request.data.get('map_id')
        type_val = request.data.get('type')
        new_otherarea = OtherareaService.create_otherarea(shape, map_id, type_val)
        serializer = self.get_serializer(new_otherarea)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    def destroy(self, request, pk=None):
        """删除其他区域"""
        OtherareaService.delete_otherarea(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)
    
    @action(detail=True, methods=['post', 'delete'])
    def eventareas(self, request, pk=None):
        """管理活动与活动区域的关联关系"""
        if request.method == 'POST':
            # 添加关联
            eventarea_id = request.data.get('eventarea_id')
            if not eventarea_id:
                return Response(
                    {'error': 'eventarea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            relation, created = EventService.add_eventarea_to_event(pk, eventarea_id)
            
            if created:
                return Response(
                    {'message': 'Relation created successfully'},
                    status=status.HTTP_201_CREATED
                )
            else:
                return Response(
                    {'message': 'Relation already exists'},
                    status=status.HTTP_200_OK
                )
        
        elif request.method == 'DELETE':
            # 删除关联
            eventarea_id = request.data.get('eventarea_id')
            if not eventarea_id:
                return Response(
                    {'error': 'eventarea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            deleted_count, _ = EventService.remove_eventarea_from_event(pk, eventarea_id)
            
            if deleted_count > 0:
                return Response(
                    {'message': 'Relation deleted successfully'},
                    status=status.HTTP_204_NO_CONTENT
                )
            else:
                return Response(
                    {'error': 'Relation not found'},
                    status=status.HTTP_404_NOT_FOUND
                )


class FacilityViewSet(viewsets.ModelViewSet):
    """
    设施（Facility）的视图集
    支持操作：更新位置 (PATCH)
    """

    def get_serializer_class(self):
        return get_facility_serializer()

    def get_queryset(self):
        return FacilityService.get_all_facilities()

    def list(self, request, *args, **kwargs):
        facilities = FacilityService.get_all_facilities()
        serializer = self.get_serializer(facilities, many=True)
        return Response(serializer.data)

    def retrieve(self, request, pk=None):
        facility = get_object_or_404(FacilityService.get_all_facilities(), pk=pk)
        serializer = self.get_serializer(facility)
        return Response(serializer.data)

    def partial_update(self, request, pk=None):
        """部分更新设施（仅支持 location 属性）"""
        if 'location' not in request.data:
            return Response(
                {'error': 'Only location attribute can be updated in editor module'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # 检查 ID 是否存在
        get_object_or_404(FacilityService.get_all_facilities(), pk=pk)

        location = request.data.get('location')
        updated_facility = FacilityService.update_facility_location(pk, location)
        serializer = self.get_serializer(updated_facility)
        return Response(serializer.data)

    def create(self, request, *args, **kwargs):
        if 'location' not in request.data:
            return Response(
                {'error': 'Location is required'}, status=status.HTTP_400_BAD_REQUEST
            )

        location = request.data.get('location')
        map_id = request.data.get('map_id')
        type_val = request.data.get('type')

        new_facility = FacilityService.create_facility(location, map_id, type_val)
        serializer = self.get_serializer(new_facility)
        return Response(serializer.data, status=status.HTTP_201_CREATED)

    def destroy(self, request, pk=None):
        FacilityService.delete_facility(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)


================================================================================
文件路径: python-backend\editor\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\editor\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\guide\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\guide\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class GuideConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'guide'



================================================================================
文件路径: python-backend\guide\context.py
--------------------------------------------------------------------------------

from django.contrib.gis.geos import Polygon, Point
from typing import Tuple, List, Optional

# 导入所有涉及的模型
from core.models import Map, Storearea, Eventarea, Otherarea, Facility, StoreareaMap, EventareaMap, OtherareaMap, \
    FacilityMap


class GuideContext:  # 不继承 BaseContext
    """
    导航模块数据上下文
    职责：只负责从数据库提取几何数据，不负责路径计算逻辑
    """

    @staticmethod
    def get_map_geometry_data(map_id: int) -> Tuple[Optional[Polygon], List[Polygon], List[Polygon]]:
        """
        一次性获取地图的边界、原始镂空以及所有障碍物

        :param map_id: 地图 ID
        :return: (outer_shell, holes, obstacles)
        """
        # 1. 获取地图底图对象
        try:
            map_obj = Map.objects.get(pk=map_id)
        except Map.DoesNotExist:
            return None, [], []

        # 2. 解析地图底图 (GeometryCollection)
        # detail[0] 通常是地板外轮廓 (Polygon)
        # detail[1:] 是地板内部的镂空 (Polygon list)
        if not map_obj.detail or len(map_obj.detail) == 0:
            return None, [], []

        outer_shell = map_obj.detail[0]
        # 确保它是 Polygon，防止脏数据
        if not isinstance(outer_shell, Polygon):
            return None, [], []

        holes = []
        # 可能有镂空，也可能没有镂空
        if len(map_obj.detail) > 1:
            holes = list(map_obj.detail[1:])

        # 3. 获取所有业务层面的障碍物
        # 将所有障碍物统一合并到一个列表中返回
        obstacles = []

        # --- A. 获取商铺区域 (Polygon) ---
        stores = Storearea.objects.filter(
            storeareamap__map_id=map_id,
            shape__isnull=False
        ).values_list('shape', flat=True)
        obstacles.extend(stores)

        # --- B. 获取活动区域 (Polygon) ---
        events = Eventarea.objects.filter(
            eventareamap__map_id=map_id,
            shape__isnull=False
        ).values_list('shape', flat=True)
        obstacles.extend(events)

        # --- C. 获取其他区域 (Polygon) ---
        others = Otherarea.objects.filter(
            otherareamap__map_id=map_id,
            shape__isnull=False
        ).values_list('shape', flat=True)
        obstacles.extend(others)

        # --- D. 获取设施 (Point -> Polygon) ---
        facilities = Facility.objects.filter(
            facilitymap__map_id=map_id,
            location__isnull=False
        ).values_list('location', flat=True)
        # 将设施点膨胀后放入障碍物列表
        for point in facilities:
            # buffer(0.5) 表示以点为中心，半径 0.5 米的圆
            if isinstance(point, Point):
                obstacles.append(point.buffer(0.5))

        return outer_shell, holes, obstacles



================================================================================
文件路径: python-backend\guide\services.py
--------------------------------------------------------------------------------

# import networkx as nx
# from django.contrib.gis.geos import Point, LineString
# from map.context import MapContext
# from map.services import MapServices  # 复用校验逻辑
#
#
# class GuideService:
#
#     def __init__(self, map_id: int):
#         self.map_id = map_id
#         # 通过 Context 获取数据
#         self.outer_shell, self.holes = MapContext.get_map_geometry(map_id)
#         # 获取所有障碍物 (Map镂空 + 实体店铺 + 设施)
#         # 这里的 obstacles 是纯几何对象列表
#         self.obstacles = list(self.holes) + MapContext.get_all_obstacles(map_id)
#
#     # --- 接口 5: 完善导航接口 ---
#     def find_path(self, start_point: Point, end_point: Point):
#         """
#         计算单楼层内的两点路径
#         """
#         if not self.outer_shell:
#             return {"success": False, "message": "Map not initialized"}
#
#         # 0. 校验起终点合法性 (复用 MapService 的逻辑)
#         # 注意：这里我们假设 MapService 是无状态的工具类
#         valid_start, msg_start = MapService.check_area_placement(start_point, self.map_id)
#         # 对终点的检查可能需要放宽（因为终点可能就在店铺门口），这里暂时严格检查
#         valid_end, msg_end = MapService.check_area_placement(end_point, self.map_id)
#
#         if not valid_start:
#             return {"success": False, "message": f"Start point invalid: {msg_start}"}
#         # 如果终点是店铺，check_area_placement 会报错（因为和店铺重合），
#         # 实际逻辑中应该判断终点是否在障碍物内部，如果在内部，应该“弹出”到最近的可行走点。
#         # 此处简化，假设输入点已经处理过。
#
#         # 1. 构建可见性图 (Visibility Graph)
#         graph = nx.Graph()
#
#         # 节点包括：起点、终点、所有障碍物的顶点
#         nodes = [start_point, end_point]
#         for obs in self.obstacles:
#             # 获取多边形外环坐标 (去除最后一个重复点)
#             coords = obs.exterior.coords[:-1]
#             nodes.extend([Point(c, srid=2385) for c in coords])
#
#         # 2. 构建边
#         # 优化：仅在节点数较少时使用全连接 O(N^2)
#         node_ids = range(len(nodes))
#
#         for i in node_ids:
#             graph.add_node(i, pos=(nodes[i].x, nodes[i].y))
#
#         for i in node_ids:
#             for j in range(i + 1, len(nodes)):
#                 p1 = nodes[i]
#                 p2 = nodes[j]
#
#                 if self._is_line_of_sight_clear(p1, p2):
#                     dist = p1.distance(p2)
#                     graph.add_edge(i, j, weight=dist)
#
#         # 3. 计算 Dijkstra
#         try:
#             path_indices = nx.dijkstra_path(graph, source=0, target=1)
#             path_coords = [(nodes[i].x, nodes[i].y) for i in path_indices]
#
#             return {
#                 "success": True,
#                 "distance": nx.dijkstra_path_length(graph, source=0, target=1),
#                 "path": LineString(path_coords, srid=2385),
#                 "steps": path_coords
#             }
#         except nx.NetworkXNoPath:
#             return {
#                 "success": False,
#                 "message": "No walkable path found."
#             }
#
#     def _is_line_of_sight_clear(self, p1: Point, p2: Point) -> bool:
#         """
#         私有方法：判断视线是否被阻挡
#         """
#         line = LineString(p1, p2)
#
#         # 必须在外轮廓内
#         if not self.outer_shell.contains(line):
#             return False
#
#         # 不能穿过任何障碍物
#         for obstacle in self.obstacles:
#             # 使用 relation 或者 intersection 判断
#             if obstacle.intersects(line) and not obstacle.touches(line):
#                 return False
#         return True

from django.contrib.gis.geos import Point, LineString, Polygon
from typing import Tuple, List, Optional
import math
import heapq

# Context 导入
from guide.context import GuideContext


class GridSystem:
    """
    辅助类：网格系统类
    负责将世界坐标(Geo)转换为离散的网格坐标(Grid)
    并管理障碍物矩阵
    """

    def __init__(self, boundary_polygon: Polygon, resolution: float = 0.5):
        """
        :param boundary_polygon: 地图的外轮廓
        :param resolution: 网格精度，例如 0.5 表示每个网格格子 0.5x0.5 米
        """
        self.resolution = resolution
        self.boundary = boundary_polygon
        # 获取多边形 boundary_polygon 的最小最大坐标
        self.min_x, self.min_y, self.max_x, self.max_y = boundary_polygon.extent
        # 计算网格系统的 x方向、 y方向各自的格子总数
        self.width = int(math.ceil((self.max_x - self.min_x) / resolution))  # 这个方法 ceil 是向上取整
        self.height = int(math.ceil((self.max_y - self.min_y) / resolution))
        # 障碍物集合，存储不可行走的网格坐标元组 (gx, gy)
        self.obstacles = set()

    def world_to_grid(self, x: float, y: float) -> Tuple[int, int]:
        """将世界坐标转为网格坐标"""
        gx = int((x - self.min_x) / self.resolution)  # int() 是向下取整
        gy = int((y - self.min_y) / self.resolution)
        return gx, gy

    def grid_to_world(self, gx: int, gy: int) -> Tuple[float, float]:
        """将网格坐标中心转为世界坐标"""
        wx = self.min_x + (gx + 0.5) * self.resolution  # 这里是加上半格的意思，不是加上 0.5 米
        wy = self.min_y + (gy + 0.5) * self.resolution
        return wx, wy

    def mark_obstacles(self, geometry_list: List[Polygon]):
        """
        向 self.obstacles 集合中存储障碍物占据的格子坐标
        某个障碍物占据了哪些格子
        逆向思维：判断这个格子是否在这个障碍物多边形内
        """
        for poly in geometry_list:
            # 1. 性能优化：不要扫描全图，只扫描障碍物所在的那个矩形区域（Bounding Box）
            # poly.extent 返回 (min_x, min_y, max_x, max_y)
            min_x, min_y, max_x, max_y = poly.extent

            # 2. 把这个矩形区域的四个角，转换成网格坐标
            # min_gx, min_gy 是左下角格子的索引
            # max_gx, max_gy 是右上角格子的索引
            min_gx, min_gy = self.world_to_grid(min_x, min_y)
            max_gx, max_gy = self.world_to_grid(max_x, max_y)

            # 3. 修正边界，防止算出负数或者超出地图宽度的索引
            min_gx = max(0, min_gx)
            min_gy = max(0, min_gy)
            max_gx = min(self.width, max_gx + 1)  # +1 是为了保证循环能覆盖到边缘
            max_gy = min(self.height, max_gy + 1)

            # 4. 循环遍历这个小区域内的每一个格子
            for gx in range(min_gx, max_gx):
                for gy in range(min_gy, max_gy):
                    # 算出这个格子中心点在地图上的真实坐标 (wx, wy)
                    wx, wy = self.grid_to_world(gx, gy)

                    # 创建一个临时的点对象
                    cell_center = Point(wx, wy, srid=2385)

                    # 5. 关键判断：如果这个格子的中心点碰到了障碍物，这个格子就是不可走的
                    # intersects() 表示“相交”或“重叠”
                    if poly.intersects(cell_center):
                        self.obstacles.add((gx, gy))

    def is_walkable(self, gx: int, gy: int) -> bool:
        """检查网格点是否在地图内且不是障碍物"""
        # 1. 数组边界检查，严格小于 self.width，因为 self.width 是上取整
        if not (0 <= gx < self.width and 0 <= gy < self.height):
            return False
        # 2. 障碍物检查
        if (gx, gy) in self.obstacles:
            return False
        # 3. 地图边界检查
        # 算出这个格子中心的真实世界坐标
        wx, wy = self.grid_to_world(gx, gy)
        # 构造一个临时的点对象
        point = Point(wx, wy, srid=2385)
        # contains() 表示如果点在多边形内部返回 True，在外部返回 False
        if not self.boundary.contains(point):
            return False

        return True


class RoutePlanService:
    """
    路径规划业务服务层
    """

    def __init__(self):
        # 创建上下文对象
        self.ctx = GuideContext()

    def validate_request_params(self, map_id, start_data, end_data) -> Tuple[bool, str]:
        """
        在View中使用的，对Request请求参数的校验逻辑
        """
        # 1. 必填项校验
        if map_id is None:
            return False, "Missing parameter: map_id"
        if not start_data or not end_data:
            return False, "Missing parameter: start or end coordinates"

        # 2. 字典结构校验
        if not isinstance(start_data, dict) or not isinstance(end_data, dict):
            return False, "Coordinates must be JSON objects with x and y"

        # 3. 坐标数值校验
        try:
            float(start_data.get('x'))
            float(start_data.get('y'))
            float(end_data.get('x'))
            float(end_data.get('y'))
        except (ValueError, TypeError):
            return False, "Coordinates x and y must be valid numbers"

        return True, "Request params are valid"

    def calculate_route(self, map_id: int, start_pt: Point, end_pt: Point) -> Optional[LineString]:
        """
        主入口：计算路径
        """
        # 1. 获取地图几何数据 (调用 Context)
        # 期望返回:
        # outer_shell: Polygon (地图地板轮廓)
        # holes: List[Polygon] (地图本身镂空)
        # obstacles: List[Geometry] (商铺、活动区、其他区域、膨胀后的设施)
        outer_shell, holes, obstacles = self.ctx.get_map_geometry_data(map_id)

        if not outer_shell:
            raise ValueError(f"Map #{map_id} outer_shell missing")

        # 2. 初始化网格系统 (Grid System)
        # 设定分辨率为 0.5 米 (可根据性能需求调整)
        grid_sys = GridSystem(outer_shell, resolution=0.5)

        # 3. 网格化障碍物
        # 将 holes 和 obstacles 合并处理
        all_obstacles = holes + obstacles
        grid_sys.mark_obstacles(all_obstacles)

        # 4. 起点、终点坐标转换
        start_node = grid_sys.world_to_grid(start_pt.x, start_pt.y)
        end_node = grid_sys.world_to_grid(end_pt.x, end_pt.y)

        # 5. 校验起终点有效性
        if not grid_sys.is_walkable(*start_node):
            raise ValueError("Start node is not walkable")
        if not grid_sys.is_walkable(*end_node):
            raise ValueError("End node is not walkable")

        # 6. 执行 A* 算法，返回网格坐标的列表
        path_nodes = self._run_astar(start_node, end_node, grid_sys)

        if not path_nodes:
            return None

        # 7. 结果转换 (Grid Nodes -> Geo LineString)
        # 将网格路径转回世界坐标的折线
        return self._construct_linestring(path_nodes, grid_sys)

    def _run_astar(self, start_node: Tuple[int, int], end_node: Tuple[int, int], grid: GridSystem) \
            -> List[Tuple[int, int]]:
        """
        A* 算法核心逻辑
        :param start_node: (gx, gy) 起点
        :param end_node: (gx, gy) 终点
        :param grid: 网格系统对象，用于判断可行走性
        :return: [(x1, y1), (x2, y2), ...] 路径列表，如果找不到路径返回 None
        """
        # 1. 初始化 open_set (优先队列)，存放 (f_score, node)，可能的扩展节点
        # f_score = g_score + h_score
        open_set = []
        heapq.heappush(open_set, (0, start_node))

        # 2. 初始化记录字典
        # came_from: 记录路径回溯，key=当前节点, value=父节点
        came_from = {}

        # g_score: 从起点到当前节点的实际代价。默认无穷大。
        g_score = {start_node: 0.0}

        # f_score: 预估总代价。默认无穷大。
        # f_score[start_node] = h(start_node, end)
        f_score = {start_node: self._heuristic(start_node, end_node)}

        # 定义移动方向和对应的代价
        # (dx, dy, cost)
        sqrt2 = math.sqrt(2)
        movements = [
            (0, 1, 1.0), (0, -1, 1.0), (1, 0, 1.0), (-1, 0, 1.0),  # 上下右左
            (1, 1, sqrt2), (1, -1, sqrt2), (-1, 1, sqrt2), (-1, -1, sqrt2)  # 对角线
        ]

        # 3. 主循环，当 open_set 非空
        while open_set:
            # 取出 f_score 最小的节点
            current_f, current = heapq.heappop(open_set)

            # --- 成功到达终点 ---
            if current == end_node:
                return self._reconstruct_path(came_from, current)

            # 遍历 8 个邻居
            for dx, dy, move_cost in movements:
                neighbor = (current[0] + dx, current[1] + dy)

                # --- 核心判断：如果邻居不可走则跳过 ---
                if not grid.is_walkable(*neighbor):
                    continue

                # 计算经过当前节点到达邻居的 tentative_g (临时G值)
                tentative_g = g_score[current] + move_cost

                # 如果临时G值小于该邻居之前的G值，或者之前没访问过该邻居 (字典里找不到 neighbor 这个 key，就返回 inf)
                if tentative_g < g_score.get(neighbor, float('inf')):
                    # 更新记录
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g

                    # 计算 f 值 = g + h
                    new_f = tentative_g + self._heuristic(neighbor, end_node)
                    f_score[neighbor] = new_f

                    # 加入优先队列等待处理
                    heapq.heappush(open_set, (new_f, neighbor))

        # 循环结束仍未找到终点
        return None

    def _reconstruct_path(self, came_from: dict, current: Tuple[int, int]) -> List[Tuple[int, int]]:
        """
        私有辅助方法：从终点回溯到起点，重建路径
        """
        total_path = [current]
        while current in came_from:
            current = came_from[current]
            total_path.append(current)

        # 因为是从终点往回找的，所以要反转列表
        return total_path[::-1]

    def _heuristic(self, node_a: Tuple[int, int], node_b: Tuple[int, int]) -> float:
        """
        启发函数 (对角距离)
        """
        delta_x = abs(node_a[0] - node_b[0])
        delta_y = abs(node_a[1] - node_b[1])
        h_value = delta_x + delta_y + (math.sqrt(2) - 2) * min(delta_x, delta_y)
        return h_value

    def _construct_linestring(self, path_nodes: List[Tuple[int, int]], grid: GridSystem) -> LineString:
        """
        将网格节点序列转换为 PostGIS LineString 对象
        """
        points = []
        for gx, gy in path_nodes:
            wx, wy = grid.grid_to_world(gx, gy)
            points.append((wx, wy))

        return LineString(points, srid=2385)



================================================================================
文件路径: python-backend\guide\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase
from unittest.mock import MagicMock, patch
from django.contrib.gis.geos import Polygon, Point, LineString
from guide.services import RoutePlanService, GridSystem
from rest_framework.test import APITestCase
from rest_framework import status
from django.contrib.gis.geos import Polygon, GeometryCollection, Point
from core.models import Map, Building, Storearea, StoreareaMap


class GridSystemTestCase(TestCase):
    """
    测试 GridSystem 类的底层逻辑 (坐标转换、障碍物标记、边界检查)
    """

    def setUp(self):
        # 创建一个 10x10 的正方形地图 (SRID=2385)
        # 坐标范围: (0,0) -> (10,10)
        self.boundary = Polygon(((0, 0), (0, 10), (10, 10), (10, 0), (0, 0)), srid=2385)
        # 分辨率设为 1.0 米，方便计算 (网格大小 10x10)
        self.grid = GridSystem(self.boundary, resolution=1.0)

    def test_coordinate_conversion(self):
        """测试世界坐标与网格坐标的相互转换"""
        # 测试 world_to_grid (向下取整)
        # 坐标 (1.5, 1.5) 应该落在 (1, 1) 格子
        gx, gy = self.grid.world_to_grid(1.5, 1.5)
        self.assertEqual((gx, gy), (1, 1))

        # 测试 grid_to_world (取中心点)
        # 格子 (1, 1) 的中心应该是 (1.5, 1.5)
        wx, wy = self.grid.grid_to_world(1, 1)
        self.assertEqual((wx, wy), (1.5, 1.5))

    def test_mark_obstacles(self):
        """测试障碍物栅格化逻辑"""
        # 创建一个位于地图中心的障碍物 (4,4) 到 (6,6)
        obstacle = Polygon(((4, 4), (4, 6), (6, 6), (6, 4), (4, 4)), srid=2385)

        self.grid.mark_obstacles([obstacle])

        # 检查障碍物内部的点 (5, 5) -> 不可走
        self.assertFalse(self.grid.is_walkable(5, 5))

        # 检查障碍物边缘的点 (网格化后可能会占据边缘)
        # (4, 4) 根据 intersects 判定通常会被占据
        self.assertFalse(self.grid.is_walkable(4, 4))

        # 检查开阔区域的点 (1, 1) -> 可走
        self.assertTrue(self.grid.is_walkable(1, 1))

    def test_boundary_check_complex_shape(self):
        """
        测试不规则形状地图的边界检查 (L型地图)
        验证 is_walkable 中的 boundary.contains 逻辑
        """
        # 创建一个 L 型多边形 (缺口在右上角)
        # (0,0) -> (0,10) -> (5,10) -> (5,5) -> (10,5) -> (10,0) -> (0,0)
        l_shape_wkt = "POLYGON((0 0, 0 10, 5 10, 5 5, 10 5, 10 0, 0 0))"
        l_shape = Polygon.from_ewkt(l_shape_wkt)
        l_shape.srid = 2385

        grid = GridSystem(l_shape, resolution=1.0)

        # 1. 测试在地图内的点 (2, 2)
        self.assertTrue(grid.is_walkable(2, 2))

        # 2. 测试在 L 型缺口处的点 (8, 8)
        # 虽然 (8, 8) 在 GridSystem 的数组索引范围内 (width=10, height=10)
        # 但它在物理上位于大楼外部
        self.assertFalse(grid.is_walkable(8, 8))


class RoutePlanServiceTestCase(TestCase):
    """
    测试 A* 算法服务层逻辑
    使用 Mock 屏蔽 Context/数据库 操作
    """

    def setUp(self):
        self.service = RoutePlanService()
        # 基础地图: 20x20 米的正方形
        self.map_boundary = Polygon(((0, 0), (0, 20), (20, 20), (20, 0), (0, 0)), srid=2385)

    @patch('guide.services.GuideContext')
    def test_simple_straight_path(self, MockContext):
        """测试无障碍物的直线路径"""
        # --- Mock 设置 ---
        mock_ctx_instance = MockContext.return_value
        # 返回: (外框, 镂空[], 障碍物[])
        mock_ctx_instance.get_map_geometry_data.return_value = (self.map_boundary, [], [])

        # 替换 service 中的 ctx
        self.service.ctx = mock_ctx_instance

        # --- 执行测试 ---
        start = Point(2, 2, srid=2385)
        end = Point(18, 18, srid=2385)

        # 运行算法
        route = self.service.calculate_route(map_id=1, start_pt=start, end_pt=end)

        # --- 断言 ---
        self.assertIsInstance(route, LineString)
        # 直线距离约为 22.62 米
        # A* 也是走的对角线，长度应该非常接近直线距离
        self.assertAlmostEqual(route.length, start.distance(end), delta=1.0)

    @patch('guide.services.GuideContext')
    def test_obstacle_avoidance(self, MockContext):
        """测试绕行逻辑：起点和终点中间有一堵墙，必须从缺口绕过去"""
        # --- Mock 设置 ---
        mock_ctx_instance = MockContext.return_value

        # 定义障碍物：一堵带缺口的墙
        # 墙的范围：y轴 9到11，x轴 5到20。
        # 这意味着 x轴 0到5 的区域是空的（缺口），路径只能从这里通过。
        wall_with_gap = Polygon(((5, 9), (5, 11), (20, 11), (20, 9), (5, 9)), srid=2385)

        # 模拟 Context 返回：地图边界、无镂空、以及上面定义的障碍物
        mock_ctx_instance.get_map_geometry_data.return_value = (
            self.map_boundary,
            [],
            [wall_with_gap]
        )
        self.service.ctx = mock_ctx_instance

        # --- 执行测试 ---
        # 起点(10, 2) -> 终点(10, 18)
        # 直线连线会被墙挡住 (墙在 y=9~11, x=5~20)
        start = Point(10, 2, srid=2385)
        end = Point(10, 18, srid=2385)

        route = self.service.calculate_route(1, start, end)

        # --- 断言 ---
        self.assertIsNotNone(route)

        # 1. 验证路径长度：肯定大于直线距离 (16米)
        # 直线距离 = 18 - 2 = 16
        self.assertTrue(route.length > 16.0)

        # 2. 验证路径走向：必须经过左侧缺口
        # 获取路径上所有点的 x 坐标
        coords = route.coords
        min_x_in_path = min(p[0] for p in coords)

        # 因为墙是从 x=5 开始的，所以要想过去，路径中至少有一个点的 x 必须小于 5 (或者接近 5)
        # 我们这里断言 < 6.0 是为了留一点网格化精度的余量
        self.assertLess(min_x_in_path, 6.0)

    @patch('guide.services.GuideContext')
    def test_unreachable_target(self, MockContext):
        """测试终点被完全包围无法到达的情况"""
        mock_ctx_instance = MockContext.return_value

        # 障碍物完全包围终点 (10, 10)
        box = Polygon(((8, 8), (8, 12), (12, 12), (12, 8), (8, 8)), srid=2385)

        mock_ctx_instance.get_map_geometry_data.return_value = (self.map_boundary, [], [box])
        self.service.ctx = mock_ctx_instance

        start = Point(2, 2, srid=2385)
        end = Point(10, 10, srid=2385)  # 在盒子里面

        # 预期抛出 ValueError (因为 End node is not walkable)
        # 或者如果 End node 勉强算 walkable 但无法到达，则返回 None
        # 根据 services.py 逻辑，先检查 is_walkable

        # 由于障碍物占位，End point 所在的网格会被标记为 obstacle
        with self.assertRaises(ValueError) as cm:
            self.service.calculate_route(1, start, end)

        self.assertIn("End node is not walkable", str(cm.exception))


class GuideIntegrationTestCase(APITestCase):
    """
    第二步：集成测试
    测试 Views -> Services -> Context -> DB 的完整链路
    """

    def setUp(self):
        # 1. 创建基础建筑 (外键依赖)
        self.building = Building.objects.create(
            name="Test Mall",
            address="123 Test St"
        )

        # 2. 创建地图 (Map)
        # 地图是一个 20x20 的正方形
        # 注意：Map 的 detail 字段是 GeometryCollection
        boundary = Polygon(((0, 0), (0, 20), (20, 20), (20, 0), (0, 0)), srid=2385)
        gc = GeometryCollection(boundary, srid=2385)

        self.map_obj = Map.objects.create(
            building=self.building,
            floor_number=1,
            detail=gc
        )

        # 3. 创建一个商铺 (障碍物)
        # 商铺挡在地图中间 (8,8) 到 (12,12)
        store_shape = Polygon(((8, 8), (8, 12), (12, 12), (12, 8), (8, 8)), srid=2385)
        self.store = Storearea.objects.create(
            store_name="Blocker Store",
            owner_name="Test Owner",
            owner_phone="123",
            shape=store_shape,
            is_active=True  # 确保是激活状态
        )

        # 4. 关联商铺和地图 (建立中间表关系)
        # 注意：根据你的 models.py，StoreareaMap 有两个外键
        StoreareaMap.objects.create(
            storearea=self.store,
            map=self.map_obj
        )

        # API URL (需要你在 urls.py 中配置好，这里假设路径是 /api/guide/route/)
        self.url = '/api/guide/route/'

    def test_route_api_success(self):
        """测试完整的 API 调用流程"""
        # 起点 (2,2)，终点 (18,18)
        # 中间有商铺挡路，应该能规划出路径
        payload = {
            "map_id": self.map_obj.id,
            "start": {"x": 2.0, "y": 2.0},
            "end": {"x": 18.0, "y": 18.0}
        }

        response = self.client.post(self.url, payload, format='json')

        # 1. 验证状态码 200
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        # 2. 验证返回数据结构
        data = response.data
        self.assertIn("route", data)
        self.assertIn("distance", data)
        self.assertIsInstance(data["route"], dict)  # GeoJSON 对象
        self.assertIsInstance(data["route"]["coordinates"], list)

        # 3. 验证距离是否合理 (直线约22米，绕路肯定大于22米)
        self.assertTrue(data["distance"] > 22.0)

        # 打印一下结果看看
        print(f"\n[Integration Test] Route Distance: {data['distance']} meters")

    def test_api_missing_params(self):
        """测试参数缺失情况"""
        payload = {"map_id": self.map_obj.id}  # 缺少 start/end
        response = self.client.post(self.url, payload, format='json')
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

    def test_api_invalid_coordinates(self):
        """测试无效坐标 (起点在墙里)"""
        # 起点 (10, 10) 正好在刚才创建的 Storearea 内部
        payload = {
            "map_id": self.map_obj.id,
            "start": {"x": 10.0, "y": 10.0},
            "end": {"x": 18.0, "y": 18.0}
        }
        response = self.client.post(self.url, payload, format='json')

        # 预期报错：Start node is not walkable
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn("error", response.data)


================================================================================
文件路径: python-backend\guide\views.py
--------------------------------------------------------------------------------

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.contrib.gis.geos import Point
import json

# 导入服务类
from .services import RoutePlanService


class RoutePlanView(APIView):
    """
    POST /api/guide/route/
    接收起点终点坐标，返回路径规划结果
    """
    service_class = RoutePlanService

    def post(self, request):
        service = self.service_class()

        # 读取前端传参
        # 前端传参示例: {"map_id": 1, "start": {"x": 10.0, "y": 20.0}, "end": {"x": 50.0, "y": 60.0}}
        map_id = request.data.get('map_id')
        start_data = request.data.get('start')
        end_data = request.data.get('end')

        # 这一步负责检查参数是否存在、格式是否正确、坐标是否可转换为浮点数
        # 我们不需要在这里写 if-else，全交给 Service
        is_valid, error_msg = service.validate_request_params(map_id, start_data, end_data)

        if not is_valid:
            return Response({"error": error_msg}, status=status.HTTP_400_BAD_REQUEST)

        try:
            # 经过上面的校验，这里可以放心转换，不用担心 KeyError 或 TypeError
            start_point = Point(float(start_data['x']), float(start_data['y']), srid=2385)
            end_point = Point(float(end_data['x']), float(end_data['y']), srid=2385)

        except Exception as e:
            # 极端异常情况
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)

        try:
            # 预期 service 返回一个 LineString 对象
            route_geometry = service.calculate_route(map_id, start_point, end_point)

            if not route_geometry:
                return Response({"error": "Route not found or unreachable"}, status=status.HTTP_404_NOT_FOUND)

            # 构造返回
            response_data = {
                # json.loads(route_geometry.geojson) 将 GeoJSON 字符串转为 Python 字典/列表
                "route": json.loads(route_geometry.geojson),
                # route_geometry.length 自动计算米制长度，然后保留 2 位小数
                "distance": round(route_geometry.length, 2)
            }

            return Response(response_data)

        except Exception as e:
            # 捕获如算法内部抛出的业务异常
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)


================================================================================
文件路径: python-backend\guide\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\guide\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\management\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\management\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class ManagementConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'management'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\management\context.py
--------------------------------------------------------------------------------

from core.models import Eventarea, Otherarea, Event, Storearea, Facility,Admin
from core.context import BaseContext

class EventareaContext:
    """
    活动区域（Eventarea）的数据访问层
    
    提供与Eventarea模型相关的数据操作方法
    """
    
    @staticmethod
    def get_all_eventareas():
        """
        获取所有活动区域
        
        Returns:
            QuerySet: 活动区域的查询集
        """
        return Eventarea.objects.all()
    
    @staticmethod
    def get_eventarea_by_id(eventarea_id):
        """
        根据ID获取活动区域
        
        Args:
            eventarea_id: 活动区域ID
        
        Returns:
            Eventarea: 活动区域对象
        """
        return Eventarea.objects.get(id=eventarea_id)
    
    @staticmethod
    def create_eventarea(data):
        """
        创建新的活动区域
        
        Args:
            data: 活动区域数据
        
        Returns:
            Eventarea: 创建的活动区域对象
        """
        return Eventarea.objects.create(**data)
    
    @staticmethod
    def update_eventarea(eventarea_id, data):
        """
        更新活动区域
        
        Args:
            eventarea_id: 活动区域ID
            data: 更新数据
        
        Returns:
            Eventarea: 更新后的活动区域对象
        """
        eventarea = Eventarea.objects.get(id=eventarea_id)
        for key, value in data.items():
            setattr(eventarea, key, value)
        eventarea.save()
        return eventarea
    
    @staticmethod
    def delete_eventarea(eventarea_id):
        """
        删除活动区域
        
        Args:
            eventarea_id: 活动区域ID
        """
        Eventarea.objects.filter(id=eventarea_id).delete()


class EventContext:
    """
    活动（Event）的数据访问层
    
    提供与Event模型相关的数据操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """
    
    @staticmethod
    def get_all_events():
        """
        获取所有活动
        
        Returns:
            QuerySet: 活动的查询集
        """
        return Event.objects.all()
    
    @staticmethod
    def get_event_by_id(event_id):
        """
        根据ID获取活动
        
        Args:
            event_id: 活动ID
        
        Returns:
            Event: 活动对象
        """
        return Event.objects.get(id=event_id)
    
    @staticmethod
    def create_event(data):
        """
        创建新的活动
        
        Args:
            data: 活动数据
        
        Returns:
            Event: 创建的活动对象
        """
        return Event.objects.create(**data)
    
    @staticmethod
    def update_event(event_id, data):
        """
        更新活动
        
        Args:
            event_id: 活动ID
            data: 更新数据
        
        Returns:
            Event: 更新后的活动对象
        """
        event = Event.objects.get(id=event_id)
        for key, value in data.items():
            setattr(event, key, value)
        event.save()
        return event
    
    @staticmethod
    def delete_event(event_id):
        """
        删除活动
        
        Args:
            event_id: 活动ID
        """
        Event.objects.filter(id=event_id).delete()


class StoreareaContext:
    """
    店铺区域（Storearea）的数据访问层
    
    提供与Storearea模型相关的数据操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """
    
    @staticmethod
    def get_all_storeareas():
        """
        获取所有店铺区域
        
        Returns:
            QuerySet: 店铺区域的查询集
        """
        return Storearea.objects.all()
    
    @staticmethod
    def get_storearea_by_id(storearea_id):
        """
        根据ID获取店铺区域
        
        Args:
            storearea_id: 店铺区域ID
        
        Returns:
            Storearea: 店铺区域对象
        """
        return Storearea.objects.get(id=storearea_id)
    
    @staticmethod
    def create_storearea(data):
        """
        创建新的店铺区域
        
        Args:
            data: 店铺区域数据
        
        Returns:
            Storearea: 创建的店铺区域对象
        """
        return Storearea.objects.create(**data)
    
    @staticmethod
    def update_storearea(storearea_id, data):
        """
        更新店铺区域
        
        Args:
            storearea_id: 店铺区域ID
            data: 更新数据
        
        Returns:
            Storearea: 更新后的店铺区域对象
        """
        storearea = Storearea.objects.get(id=storearea_id)
        for key, value in data.items():
            setattr(storearea, key, value)
        storearea.save()
        return storearea
    
    @staticmethod
    def delete_storearea(storearea_id):
        """
        删除店铺区域
        
        Args:
            storearea_id: 店铺区域ID
        """
        Storearea.objects.filter(id=storearea_id).delete()


class OtherareaContext:
    """
    其他区域（Otherarea）的数据访问层
    
    提供与Otherarea模型相关的数据操作方法
    """
    
    @staticmethod
    def get_all_otherareas():
        """
        获取所有其他区域
        
        Returns:
            QuerySet: 其他区域的查询集
        """
        return Otherarea.objects.all()
    
    @staticmethod
    def get_otherarea_by_id(otherarea_id):
        """
        根据ID获取其他区域
        
        Args:
            otherarea_id: 其他区域ID
        
        Returns:
            Otherarea: 其他区域对象
        """
        return Otherarea.objects.get(id=otherarea_id)
    
    @staticmethod
    def create_otherarea(data):
        """
        创建新的其他区域
        
        Args:
            data: 其他区域数据
        
        Returns:
            Otherarea: 创建的其他区域对象
        """
        return Otherarea.objects.create(**data)
    
    @staticmethod
    def update_otherarea(otherarea_id, data):
        """
        更新其他区域
        
        Args:
            otherarea_id: 其他区域ID
            data: 更新数据
        
        Returns:
            Otherarea: 更新后的其他区域对象
        """
        otherarea = Otherarea.objects.get(id=otherarea_id)
        for key, value in data.items():
            setattr(otherarea, key, value)
        otherarea.save()
        return otherarea
    
    @staticmethod
    def delete_otherarea(otherarea_id):
        """
        删除其他区域
        
        Args:
            otherarea_id: 其他区域ID
        """
        Otherarea.objects.filter(id=otherarea_id).delete()


class FacilityContext:
    """
    设施（Facility）的数据访问层
    
    提供与Facility模型相关的数据操作方法
    注意：location属性由editor模块处理
    """
    
    @staticmethod
    def get_all_facilities():
        """
        获取所有设施
        
        Returns:
            QuerySet: 设施的查询集
        """
        return Facility.objects.all()
    
    @staticmethod
    def get_facility_by_id(facility_id):
        """
        根据ID获取设施
        
        Args:
            facility_id: 设施ID
        
        Returns:
            Facility: 设施对象
        """
        return Facility.objects.get(id=facility_id)
    
    @staticmethod
    def create_facility(data):
        """
        创建新的设施
        
        Args:
            data: 设施数据
        
        Returns:
            Facility: 创建的设施对象
        """
        return Facility.objects.create(**data)
    
    @staticmethod
    def update_facility(facility_id, data):
        """
        更新设施
        
        Args:
            facility_id: 设施ID
            data: 更新数据
        
        Returns:
            Facility: 更新后的设施对象
        """
        facility = Facility.objects.get(id=facility_id)
        for key, value in data.items():
            setattr(facility, key, value)
        facility.save()
        return facility
    
    @staticmethod
    def delete_facility(facility_id):
        """
        删除设施
        
        Args:
            facility_id: 设施ID
        """
        Facility.objects.filter(id=facility_id).delete()

class AdminContext(BaseContext):
    """针对 Admin 模型的基础 CRUD 和查询操作"""
    def __init__(self):
        super().__init__(Admin)

    def get_by_account(self, account: str) -> Admin | None:
        """根据账号名获取 Admin 实例"""
        try:
            return self.model.objects.get(account=account)
        except self.model.DoesNotExist:
            return None


================================================================================
文件路径: python-backend\management\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from django.apps import apps
from core.models import Admin

def get_eventarea_serializer():
    """获取活动区域序列化器"""
    Eventarea = apps.get_model('core', 'Eventarea')
    
    class EventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            exclude = ['shape']
    
    return EventareaSerializer


def get_otherarea_serializer():
    """获取其他区域序列化器"""
    Otherarea = apps.get_model('core', 'Otherarea')
    
    class OtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            exclude = ['shape']
    
    return OtherareaSerializer


def get_event_serializer():
    """获取Event模型的序列化器"""
    Event = apps.get_model('core', 'Event')
    
    class EventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = '__all__'
    
    return EventSerializer


def get_storearea_serializer():
    """获取Storearea模型的序列化器"""
    Storearea = apps.get_model('core', 'Storearea')
    
    class StoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            exclude = ['shape']
    
    return StoreareaSerializer


def get_facility_serializer():
    """获取Facility模型的序列化器"""
    Facility = apps.get_model('core', 'Facility')
    
    class FacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            exclude = ['location']
    
    return FacilitySerializer

# Input Serializers (用于接收前端数据)
class AdminRegisterSerializer(serializers.Serializer):
    """管理员注册输入"""
    account = serializers.CharField(max_length=64)
    password = serializers.CharField(max_length=128, write_only=True)
    name = serializers.CharField(max_length=64, required=False, allow_blank=True)

class AdminLoginSerializer(serializers.Serializer):
    """管理员登录输入"""
    account = serializers.CharField(max_length=64)
    password = serializers.CharField(max_length=128, write_only=True) # write_only: 密码只用于输入，不用于输出

class AdminUpdateSerializer(serializers.Serializer):
    """管理员修改信息输入 (用于 PUT / PATCH)"""
    name = serializers.CharField(max_length=64, required=False, allow_blank=True)
    # 允许修改密码，但必须使用新的字段名 new_password
    new_password = serializers.CharField(max_length=128, required=False, write_only=True)

# Output Serializer (用于返回 Admin 实例信息)
class AdminProfileSerializer(serializers.ModelSerializer):
    """管理员信息的输出格式 (不暴露密码)"""
    class Meta:
        model = Admin
        fields = ['id', 'account', 'name']
        read_only_fields = ['id', 'account'] # 账号和ID不能通过这个接口修改


================================================================================
文件路径: python-backend\management\services.py
--------------------------------------------------------------------------------

from .context import EventareaContext, OtherareaContext, EventContext, StoreareaContext, FacilityContext, AdminContext
from core.models import Admin
from django.contrib.auth.hashers import make_password, check_password
from django.core.exceptions import ValidationError


class AdminService:
    """负责管理员的注册、登录和个人信息修改的业务逻辑"""

    def __init__(self):
        self.ctx = AdminContext()

    def register_admin(self, account: str, password: str, name: str | None = None) -> Admin:
        """注册新管理员"""
        if self.ctx.get_by_account(account):
            raise ValidationError("Admin account already exists.")

        # 1. 密码哈希 (SECURITY CRITICAL)
        hashed_password = make_password(password)

        # 2. 创建实例
        admin_instance = self.ctx.create(
            account=account,
            password=hashed_password,
            name=name
        )
        return admin_instance

    def login_admin(self, account: str, password: str) -> Admin | None:
        """验证管理员登录凭证"""
        admin_instance = self.ctx.get_by_account(account)

        # 1. 检查实例是否存在
        if not admin_instance:
            return None  # 账号不存在

        # 2. 检查密码是否匹配 (使用 check_password 验证哈希值)
        if check_password(password, admin_instance.password):
            return admin_instance  # 登录成功

        return None  # 密码错误

    def update_profile(self, admin_instance: Admin, name: str | None, new_password: str | None) -> Admin:
        """更新管理员信息 (姓名和/或密码)"""
        update_data = {}

        if name is not None:
            update_data['name'] = name

        if new_password:
            # 3. 如果有新密码，哈希后再更新
            update_data['password'] = make_password(new_password)

        return self.ctx.update(admin_instance, **update_data)


class EventareaService:
    """
    活动区域（Eventarea）的业务逻辑层

    提供与Eventarea模型相关的业务逻辑处理方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_eventareas():
        """
        获取所有活动区域

        Returns:
            QuerySet: 活动区域的查询集
        """
        return EventareaContext.get_all_eventareas()

    @staticmethod
    def get_eventarea_by_id(eventarea_id):
        """
        根据ID获取活动区域

        Args:
            eventarea_id: 活动区域ID

        Returns:
            Eventarea: 活动区域对象
        """
        return EventareaContext.get_eventarea_by_id(eventarea_id)

    @staticmethod
    def create_eventarea(data):
        """
        创建新的活动区域

        Args:
            data: 活动区域数据

        Returns:
            Eventarea: 创建的活动区域对象
        """
        # 业务逻辑验证
        # 1. 验证数据完整性
        required_fields = ['is_active', 'description', 'organizer_name', 'organizer_phone', 'type']
        for field in required_fields:
            if field not in data:
                raise ValueError(f"Field '{field}' is required")

        # 2. 验证电话号码格式
        # 这里可以添加更复杂的电话号码验证逻辑
        if len(data['organizer_phone']) < 10:
            raise ValueError("Phone number must be at least 10 characters long")

        # 3. 验证类型是否合法
        valid_types = ['exhibition', 'concert', 'meeting', 'other']  # 根据实际需求调整
        if data['type'] not in valid_types:
            raise ValueError(f"Invalid type. Valid types are: {', '.join(valid_types)}")

        # 4. 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        return EventareaContext.create_eventarea(data)

    @staticmethod
    def update_eventarea(eventarea_id, data):
        """
        更新活动区域

        Args:
            eventarea_id: 活动区域ID
            data: 更新数据

        Returns:
            Eventarea: 更新后的活动区域对象
        """
        # 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        # 如果有其他业务逻辑验证，可以在这里添加

        return EventareaContext.update_eventarea(eventarea_id, data)

    @staticmethod
    def delete_eventarea(eventarea_id):
        """
        删除活动区域

        Args:
            eventarea_id: 活动区域ID
        """
        # 业务逻辑验证
        # 1. 验证活动区域是否存在
        eventarea = EventareaContext.get_eventarea_by_id(eventarea_id)

        # 2. 验证是否有相关联的活动
        if eventarea.event_set.exists():
            raise ValueError("Cannot delete eventarea with associated events")

        return EventareaContext.delete_eventarea(eventarea_id)


class OtherareaService:
    """
    其他区域（Otherarea）的业务逻辑层

    提供与Otherarea模型相关的业务逻辑处理方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_otherareas():
        """
        获取所有其他区域

        Returns:
            QuerySet: 其他区域的查询集
        """
        return OtherareaContext.get_all_otherareas()

    @staticmethod
    def get_otherarea_by_id(otherarea_id):
        """
        根据ID获取其他区域

        Args:
            otherarea_id: 其他区域ID

        Returns:
            Otherarea: 其他区域对象
        """
        return OtherareaContext.get_otherarea_by_id(otherarea_id)

    @staticmethod
    def create_otherarea(data):
        """
        创建新的其他区域

        Args:
            data: 其他区域数据

        Returns:
            Otherarea: 创建的其他区域对象
        """
        # 业务逻辑验证
        # 1. 验证数据完整性
        required_fields = ['is_active', 'description', 'type', 'is_public']
        for field in required_fields:
            if field not in data:
                raise ValueError(f"Field '{field}' is required")

        # 2. 验证类型是否合法
        valid_types = ['restroom', 'parking', 'entrance', 'exit', 'staircase', 'elevator', 'other']  # 根据实际需求调整
        if data['type'] not in valid_types:
            raise ValueError(f"Invalid type. Valid types are: {', '.join(valid_types)}")

        # 3. 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        return OtherareaContext.create_otherarea(data)

    @staticmethod
    def update_otherarea(otherarea_id, data):
        """
        更新其他区域

        Args:
            otherarea_id: 其他区域ID
            data: 更新数据

        Returns:
            Otherarea: 更新后的其他区域对象
        """
        # 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        # 如果有其他业务逻辑验证，可以在这里添加

        return OtherareaContext.update_otherarea(otherarea_id, data)

    @staticmethod
    def delete_otherarea(otherarea_id):
        """
        删除其他区域

        Args:
            otherarea_id: 其他区域ID
        """
        # 业务逻辑验证
        # 1. 验证其他区域是否存在
        otherarea = OtherareaContext.get_otherarea_by_id(otherarea_id)

        # 2. 可以添加其他验证逻辑

        return OtherareaContext.delete_otherarea(otherarea_id)


class EventService:
    """
    活动（Event）的业务逻辑层

    提供与Event模型相关的业务逻辑操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_events():
        """
        获取所有活动

        Returns:
            QuerySet: 活动的查询集
        """
        return EventContext.get_all_events()

    @staticmethod
    def get_event_by_id(event_id):
        """
        根据ID获取活动

        Args:
            event_id: 活动ID

        Returns:
            Event: 活动对象
        """
        return EventContext.get_event_by_id(event_id)

    @staticmethod
    def create_event(data):
        """
        创建新的活动

        Args:
            data: 活动数据

        Returns:
            Event: 创建的活动对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 业务逻辑验证
        # 这里可以添加更多的业务逻辑验证

        return EventContext.create_event(data)

    @staticmethod
    def update_event(event_id, data):
        """
        更新活动

        Args:
            event_id: 活动ID
            data: 更新数据

        Returns:
            Event: 更新后的活动对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 业务逻辑验证
        # 这里可以添加更多的业务逻辑验证

        return EventContext.update_event(event_id, data)

    @staticmethod
    def delete_event(event_id):
        """
        删除活动

        Args:
            event_id: 活动ID
        """
        EventContext.delete_event(event_id)


class StoreareaService:
    """
    店铺区域（Storearea）的业务逻辑层

    提供与Storearea模型相关的业务逻辑操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_storeareas():
        """
        获取所有店铺区域

        Returns:
            QuerySet: 店铺区域的查询集
        """
        return StoreareaContext.get_all_storeareas()

    @staticmethod
    def get_storearea_by_id(storearea_id):
        """
        根据ID获取店铺区域

        Args:
            storearea_id: 店铺区域ID

        Returns:
            Storearea: 店铺区域对象
        """
        return StoreareaContext.get_storearea_by_id(storearea_id)

    @staticmethod
    def create_storearea(data):
        """
        创建新的店铺区域

        Args:
            data: 店铺区域数据

        Returns:
            Storearea: 创建的店铺区域对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 业务逻辑验证
        # 这里可以添加更多的业务逻辑验证

        return StoreareaContext.create_storearea(data)

    @staticmethod
    def update_storearea(storearea_id, data):
        """
        更新店铺区域

        Args:
            storearea_id: 店铺区域ID
            data: 更新数据

        Returns:
            Storearea: 更新后的店铺区域对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 业务逻辑验证
        # 这里可以添加更多的业务逻辑验证

        return StoreareaContext.update_storearea(storearea_id, data)

    @staticmethod
    def delete_storearea(storearea_id):
        """
        删除店铺区域
        
        Args:
            storearea_id: 店铺区域ID
        """
        StoreareaContext.delete_storearea(storearea_id)


class FacilityService:
    """
    设施（Facility）的业务逻辑层
    
    提供与Facility模型相关的业务逻辑处理方法
    注意：location属性由editor模块处理
    """

    @staticmethod
    def get_all_facilities():
        """
        获取所有设施
        
        Returns:
            QuerySet: 设施的查询集
        """
        return FacilityContext.get_all_facilities()

    @staticmethod
    def get_facility_by_id(facility_id):
        """
        根据ID获取设施
        
        Args:
            facility_id: 设施ID
        
        Returns:
            Facility: 设施对象
        """
        return FacilityContext.get_facility_by_id(facility_id)

    @staticmethod
    def create_facility(data):
        """
        创建新的设施
        
        Args:
            data: 设施数据
        
        Returns:
            Facility: 创建的设施对象
        """
        # 业务逻辑验证
        # 1. 验证数据完整性
        required_fields = ['is_active', 'description', 'type']
        for field in required_fields:
            if field not in data:
                raise ValueError(f"Field '{field}' is required")

        # 2. 验证类型是否合法（根据实际需求调整）
        # 这里假设type是整数类型，表示不同的设施类型

        # 3. 如果提供了location属性，将其移除（location属性由editor模块处理）
        if 'location' in data:
            data.pop('location')

        return FacilityContext.create_facility(data)

    @staticmethod
    def update_facility(facility_id, data):
        """
        更新设施
        
        Args:
            facility_id: 设施ID
            data: 更新数据
        
        Returns:
            Facility: 更新后的设施对象
        """
        # 如果提供了location属性，将其移除（location属性由editor模块处理）
        if 'location' in data:
            data.pop('location')

        # 如果有其他业务逻辑验证，可以在这里添加

        return FacilityContext.update_facility(facility_id, data)

    @staticmethod
    def delete_facility(facility_id):
        """
        删除设施
        
        Args:
            facility_id: 设施ID
        """
        # 业务逻辑验证
        # 1. 验证设施是否存在
        facility = FacilityContext.get_facility_by_id(facility_id)

        # 2. 可以添加其他验证逻辑

        return FacilityContext.delete_facility(facility_id)


================================================================================
文件路径: python-backend\management\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.
from rest_framework.test import APITestCase
from rest_framework import status
from django.urls import reverse
from core.models import Admin
from django.contrib.auth.hashers import check_password, make_password


class AdminAuthAPITestCase(APITestCase):
    """
    测试管理员注册、登录、注销接口 (AdminAuthView)
    """

    def setUp(self):
        # 预先定义好路由名称
        self.register_url = reverse('admin-auth', kwargs={'action': 'register'})
        self.login_url = reverse('admin-auth', kwargs={'action': 'login'})
        self.logout_url = reverse('admin-auth', kwargs={'action': 'logout'})
        self.profile_url = reverse('admin-profile')  # 档案管理路由

        # 注册一个测试管理员供后续登录测试使用
        self.account = "testuser"
        self.password = "password123"
        self.admin = Admin.objects.create(
            account=self.account,
            password=make_password(self.password),  # 注意: 这里是明文，在测试中我们会手动进行哈希检查
            name="Original Name"
        )
        # # 注意: 真实的 AdminService.register_admin 会自动哈希密码，但这里我们绕过 Service 直接创建，
        # # 所以必须手动设置哈希后的密码才能通过 login 测试。
        # self.admin.password = check_password(self.password, 'fake_hash')  # 任意哈希值
        # self.admin.save()

    # ------------------ 注册 (Register) 测试 ------------------

    def test_register_success(self):
        """测试成功注册新管理员"""
        data = {"account": "newadmin", "password": "newpassword456", "name": "New Admin"}
        response = self.client.post(self.register_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Admin.objects.count(), 2)
        self.assertEqual(response.data['account'], 'newadmin')

        # 验证密码是否被哈希存储
        new_admin = Admin.objects.get(account='newadmin')
        self.assertTrue(check_password("newpassword456", new_admin.password))

    def test_register_duplicate_account(self):
        """测试注册时账号重复"""
        data = {"account": self.account, "password": "somepassword", "name": "Duplicate User"}
        response = self.client.post(self.register_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('account already exists', response.data['error'].lower())
        self.assertEqual(Admin.objects.count(), 1)  # 确认没有创建新用户

    # ------------------ 登录 (Login) 测试 ------------------

    def test_login_success(self):
        """测试成功登录"""
        data = {"account": self.account, "password": self.password}
        response = self.client.post(self.login_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['account'], self.account)
        # 验证 Session 是否被正确设置 (检查响应中的 session key)
        self.assertIn('sessionid', response.cookies)
        self.assertTrue(self.client.session.get('admin_id'))

    def test_login_failure_wrong_password(self):
        """测试密码错误导致登录失败"""
        data = {"account": self.account, "password": "wrongpassword"}
        response = self.client.post(self.login_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertIn('Invalid account or password', response.data['error'])

    def test_login_failure_non_existent_account(self):
        """测试账号不存在导致登录失败"""
        data = {"account": "nonexistent", "password": "anypassword"}
        response = self.client.post(self.login_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertIn('Invalid account or password', response.data['error'])

    # ------------------ 注销 (Logout) 测试 ------------------

    def test_logout_success(self):
        """测试成功注销"""
        # 先登录以设置 Session
        self.client.post(self.login_url, {"account": self.account, "password": self.password}, format='json')

        # 执行注销
        response = self.client.post(self.logout_url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        # 验证 Session 是否被清除
        self.assertIsNone(self.client.session.get('admin_id'))


class AdminProfileAPITestCase(APITestCase):
    """
    测试管理员档案管理接口 (AdminProfileView)
    """

    def setUp(self):
        self.login_url = reverse('admin-auth', kwargs={'action': 'login'})
        self.profile_url = reverse('admin-profile')

        self.account = "profileuser"
        self.password = "profilepass"

        # 手动创建 Admin 实例,确保密码哈希
        hashed_password = make_password(self.password)
        self.admin = Admin.objects.create(
            account=self.account,
            password=hashed_password,
            name="Profile Target"
        )

        # 登录并获取 Session Cookie
        self.client.post(self.login_url, {"account": self.account, "password": self.password}, format='json')
        # self.admin = Admin.objects.get(account=self.account)  # 获取实例

    # ------------------ 权限 (Authorization) 测试 ------------------

    def test_profile_requires_authentication(self):
        """测试未登录用户无法访问 Profile 接口"""
        self.client.logout()  # 清除 Session
        response_get = self.client.get(self.profile_url, format='json')
        response_put = self.client.put(self.profile_url, {"name": "fail"}, format='json')

        self.assertEqual(response_get.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertEqual(response_put.status_code, status.HTTP_401_UNAUTHORIZED)

    # ------------------ 获取信息 (GET) 测试 ------------------

    def test_get_profile_success(self):
        """测试成功获取个人信息"""
        response = self.client.get(self.profile_url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['account'], self.account)
        self.assertEqual(response.data['name'], "Profile Target")
        self.assertNotIn('password', response.data)  # 确保密码没有被泄露

    # ------------------ 修改信息 (PUT/PATCH) 测试 ------------------

    def test_update_name_success(self):
        """测试成功修改姓名"""
        new_name = "Updated User Name"
        response = self.client.put(self.profile_url, {"name": new_name}, format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['name'], new_name)

        # 验证数据库中的值已更新
        self.admin.refresh_from_db()
        self.assertEqual(self.admin.name, new_name)

    def test_update_password_success(self):
        """测试成功修改密码"""
        new_password = "verysecurepassword"
        response = self.client.put(self.profile_url, {"new_password": new_password}, format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['account'], self.account)

        # 验证新的密码能否用于登录
        self.admin.refresh_from_db()
        self.assertTrue(check_password(new_password, self.admin.password))

        # 验证旧密码失效
        self.assertFalse(check_password(self.password, self.admin.password))

    def test_update_both_success(self):
        """测试同时修改姓名和密码"""
        new_name = "Final Name"
        new_password = "FinalPassword"

        response = self.client.put(self.profile_url,
                                   {"name": new_name, "new_password": new_password},
                                   format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['name'], new_name)

        # 验证数据库
        self.admin.refresh_from_db()
        self.assertEqual(self.admin.name, new_name)
        self.assertTrue(check_password(new_password, self.admin.password))


================================================================================
文件路径: python-backend\management\urls.py
--------------------------------------------------------------------------------

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import EventareaViewSet, OtherareaViewSet, EventViewSet, StoreareaViewSet, FacilityViewSet

# 创建路由器并注册视图集
router = DefaultRouter()
router.register(r'eventarea', EventareaViewSet, basename='management_eventarea')
router.register(r'otherarea', OtherareaViewSet, basename='management_otherarea')
router.register(r'event', EventViewSet, basename='management_event')
router.register(r'storearea', StoreareaViewSet, basename='management_storearea')
router.register(r'facility', FacilityViewSet, basename='management_facility')

urlpatterns = [
    # 包含路由器生成的所有URL
    path('', include(router.urls)),
]



================================================================================
文件路径: python-backend\management\views.py
--------------------------------------------------------------------------------

from rest_framework import viewsets, status
from rest_framework.response import Response
from django.shortcuts import get_object_or_404
from .serializers import get_eventarea_serializer, get_otherarea_serializer, get_event_serializer, get_storearea_serializer, get_facility_serializer
from .services import EventareaService, OtherareaService, EventService, StoreareaService, FacilityService


class EventareaViewSet(viewsets.ModelViewSet):
    """
    活动区域（Eventarea）的视图集
    
    注意：
    - 在management模块中处理除shape属性外的所有其他属性
    - shape属性的操作由editor模块处理
    - 不允许修改shape属性
    
    支持的操作：
    - GET /api/management/eventarea/ - 获取所有活动区域列表
    - GET /api/management/eventarea/{id}/ - 获取指定活动区域详情
    - POST /api/management/eventarea/ - 创建新的活动区域
    - PUT /api/management/eventarea/{id}/ - 完整更新活动区域（不包括shape）
    - PATCH /api/management/eventarea/{id}/ - 部分更新活动区域（不包括shape）
    - DELETE /api/management/eventarea/{id}/ - 删除指定活动区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_eventarea_serializer()
    
    def get_queryset(self):
        """获取所有活动区域"""
        return EventareaService.get_all_eventareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动区域列表"""
        eventareas = EventareaService.get_all_eventareas()
        serializer = self.get_serializer(eventareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动区域详情"""
        eventarea = get_object_or_404(EventareaService.get_all_eventareas(), pk=pk)
        serializer = self.get_serializer(eventarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的活动区域"""
        try:
            # 检查是否包含shape属性，如果包含则移除
            data = request.data.copy()
            if 'shape' in data:
                data.pop('shape')
            
            eventarea = EventareaService.create_eventarea(data)
            serializer = self.get_serializer(eventarea)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新活动区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            eventarea = EventareaService.update_eventarea(pk, request.data)
            serializer = self.get_serializer(eventarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新活动区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            eventarea = EventareaService.update_eventarea(pk, request.data)
            serializer = self.get_serializer(eventarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """删除指定活动区域"""
        try:
            EventareaService.delete_eventarea(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class OtherareaViewSet(viewsets.ModelViewSet):
    """
    其他区域（Otherarea）的视图集
    
    注意：
    - 在management模块中处理除shape属性外的所有其他属性
    - shape属性的操作由editor模块处理
    - 不允许修改shape属性
    
    支持的操作：
    - GET /api/management/otherarea/ - 获取所有其他区域列表
    - GET /api/management/otherarea/{id}/ - 获取指定其他区域详情
    - POST /api/management/otherarea/ - 创建新的其他区域
    - PUT /api/management/otherarea/{id}/ - 完整更新其他区域（不包括shape）
    - PATCH /api/management/otherarea/{id}/ - 部分更新其他区域（不包括shape）
    - DELETE /api/management/otherarea/{id}/ - 删除指定其他区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_otherarea_serializer()
    
    def get_queryset(self):
        """获取所有其他区域"""
        return OtherareaService.get_all_otherareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有其他区域列表"""
        otherareas = OtherareaService.get_all_otherareas()
        serializer = self.get_serializer(otherareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定其他区域详情"""
        otherarea = get_object_or_404(OtherareaService.get_all_otherareas(), pk=pk)
        serializer = self.get_serializer(otherarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的其他区域"""
        try:
            # 检查是否包含shape属性，如果包含则移除
            data = request.data.copy()
            if 'shape' in data:
                data.pop('shape')
            
            otherarea = OtherareaService.create_otherarea(data)
            serializer = self.get_serializer(otherarea)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新其他区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            otherarea = OtherareaService.update_otherarea(pk, request.data)
            serializer = self.get_serializer(otherarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新其他区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            otherarea = OtherareaService.update_otherarea(pk, request.data)
            serializer = self.get_serializer(otherarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """删除指定其他区域"""
        try:
            OtherareaService.delete_otherarea(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class EventViewSet(viewsets.ModelViewSet):
    """
    活动（Event）的视图集
    
    支持的操作：
    - GET /api/management/event/ - 获取所有活动列表
    - GET /api/management/event/{id}/ - 获取指定活动详情
    - POST /api/management/event/ - 创建新的活动
    - PUT /api/management/event/{id}/ - 完整更新活动
    - PATCH /api/management/event/{id}/ - 部分更新活动
    - DELETE /api/management/event/{id}/ - 删除指定活动
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_event_serializer()
    
    def get_queryset(self):
        """获取所有活动"""
        return EventService.get_all_events()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动列表"""
        events = EventService.get_all_events()
        serializer = self.get_serializer(events, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动详情"""
        event = get_object_or_404(EventService.get_all_events(), pk=pk)
        serializer = self.get_serializer(event)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的活动"""
        try:
            event = EventService.create_event(request.data)
            serializer = self.get_serializer(event)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新活动"""
        try:
            event = EventService.update_event(pk, request.data)
            serializer = self.get_serializer(event)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新活动"""
        try:
            event = EventService.update_event(pk, request.data)
            serializer = self.get_serializer(event)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """删除指定活动"""
        try:
            EventService.delete_event(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class StoreareaViewSet(viewsets.ModelViewSet):
    """
    店铺区域（Storearea）的视图集
    
    注意：
    - 不处理shape属性，该属性由editor模块处理
    
    支持的操作：
    - GET /api/management/storearea/ - 获取所有店铺区域列表
    - GET /api/management/storearea/{id}/ - 获取指定店铺区域详情
    - POST /api/management/storearea/ - 创建新的店铺区域
    - PUT /api/management/storearea/{id}/ - 完整更新店铺区域（不包括shape）
    - PATCH /api/management/storearea/{id}/ - 部分更新店铺区域（不包括shape）
    - DELETE /api/management/storearea/{id}/ - 删除指定店铺区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_storearea_serializer()
    
    def get_queryset(self):
        """获取所有店铺区域"""
        return StoreareaService.get_all_storeareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有店铺区域列表"""
        storeareas = StoreareaService.get_all_storeareas()
        serializer = self.get_serializer(storeareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定店铺区域详情"""
        storearea = get_object_or_404(StoreareaService.get_all_storeareas(), pk=pk)
        serializer = self.get_serializer(storearea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的店铺区域"""
        try:
            # 检查是否包含shape属性，如果包含则移除
            data = request.data.copy()
            if 'shape' in data:
                data.pop('shape')
            
            storearea = StoreareaService.create_storearea(data)
            serializer = self.get_serializer(storearea)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新店铺区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            storearea = StoreareaService.update_storearea(pk, request.data)
            serializer = self.get_serializer(storearea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新店铺区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            storearea = StoreareaService.update_storearea(pk, request.data)
            serializer = self.get_serializer(storearea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """
        删除指定店铺区域
        """
        try:
            StoreareaService.delete_storearea(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class FacilityViewSet(viewsets.ModelViewSet):
    """
    设施（Facility）的视图集
    
    注意：
    - 在management模块中处理除location属性外的所有其他属性
    - location属性的操作由editor模块处理
    - 不允许修改location属性
    
    支持的操作：
    - GET /api/management/facility/ - 获取所有设施列表
    - GET /api/management/facility/{id}/ - 获取指定设施详情
    - POST /api/management/facility/ - 创建新的设施
    - PUT /api/management/facility/{id}/ - 完整更新设施（不包括location）
    - PATCH /api/management/facility/{id}/ - 部分更新设施（不包括location）
    - DELETE /api/management/facility/{id}/ - 删除指定设施
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_facility_serializer()
    
    def get_queryset(self):
        """获取所有设施"""
        return FacilityService.get_all_facilities()
    
    def list(self, request, *args, **kwargs):
        """获取所有设施列表"""
        facilities = FacilityService.get_all_facilities()
        serializer = self.get_serializer(facilities, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定设施详情"""
        facility = get_object_or_404(FacilityService.get_all_facilities(), pk=pk)
        serializer = self.get_serializer(facility)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的设施"""
        try:
            # 检查是否包含location属性，如果包含则移除
            data = request.data.copy()
            if 'location' in data:
                data.pop('location')
            
            facility = FacilityService.create_facility(data)
            serializer = self.get_serializer(facility)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新设施（不包括location）"""
        try:
            # 检查是否包含location属性，如果包含则返回错误
            if 'location' in request.data:
                return Response(
                    {'error': 'Location attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            facility = FacilityService.update_facility(pk, request.data)
            serializer = self.get_serializer(facility)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新设施（不包括location）"""
        try:
            # 检查是否包含location属性，如果包含则返回错误
            if 'location' in request.data:
                return Response(
                    {'error': 'Location attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            facility = FacilityService.update_facility(pk, request.data)
            serializer = self.get_serializer(facility)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """删除指定设施"""
        try:
            FacilityService.delete_facility(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.core.exceptions import ValidationError
from django.http import HttpRequest

from .services import AdminService
from .serializers import AdminRegisterSerializer, AdminLoginSerializer, AdminUpdateSerializer, AdminProfileSerializer
from core.models import Admin
from core.context import BaseContext


class AdminAuthMixin:
    """一个简单的用于检查管理员登录状态并加载 Admin 实例的 Mixin"""
    @staticmethod
    def get_admin_user(request: HttpRequest) -> Admin | None:
        admin_id = request.session.get('admin_id')
        if admin_id:
            try:
                # 使用 BaseContext 或 AdminContext 获取实例
                return BaseContext(Admin).get_by_id(admin_id)
            except Admin.DoesNotExist:
                del request.session['admin_id']  # 清理过期会话
                return None
        return None


class AdminAuthView(APIView):
    """
    处理管理员的注册、登录、注销
    POST /api/management/auth/register/
    POST /api/management/auth/login/
    POST /api/management/auth/logout/
    """
    service_class = AdminService

    def post(self, request, action):
        service = self.service_class()

        if action == 'register':
            serializer = AdminRegisterSerializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            try:
                admin = service.register_admin(**serializer.validated_data)
                return Response(AdminProfileSerializer(admin).data, status=status.HTTP_201_CREATED)
            except ValidationError as e:
                return Response({"error": e.message}, status=status.HTTP_400_BAD_REQUEST)

        elif action == 'login':
            serializer = AdminLoginSerializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            admin = service.login_admin(**serializer.validated_data)

            if admin:
                # 登录成功：在 session 中设置 ID
                request.session['admin_id'] = admin.id
                return Response(AdminProfileSerializer(admin).data, status=status.HTTP_200_OK)
            else:
                return Response({"error": "Invalid account or password"}, status=status.HTTP_401_UNAUTHORIZED)

        elif action == 'logout':
            if 'admin_id' in request.session:
                del request.session['admin_id']  # 清除 session
            return Response({"message": "Logout successful"}, status=status.HTTP_200_OK)

        else:
            return Response({"error": "Invalid action"}, status=status.HTTP_400_BAD_REQUEST)


# --- 个人信息接口 ---
class AdminProfileView(AdminAuthMixin, APIView):
    """
    处理管理员个人信息的获取和修改
    GET /api/management/profile/
    PUT/PATCH /api/management/profile/
    """
    service_class = AdminService
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.admin_user = None # 初始化实例属性
        
    def dispatch(self, request, *args, **kwargs):
        # 在处理请求前，先检查登录状态并加载 Admin 实例
        self.admin_user = self.get_admin_user(request)
        if not self.admin_user:
            return Response({"error": "Authentication credentials were not provided."},
                            status=status.HTTP_401_UNAUTHORIZED)
        return super().dispatch(request, *args, **kwargs)

    def get(self, request):
        """获取当前登录管理员的个人信息"""
        # self.admin_user 已在 dispatch 中加载并验证
        return Response(AdminProfileSerializer(self.admin_user).data)

    def put(self, request):
        """修改当前登录管理员的个人信息 (PUT/PATCH 通用)"""
        serializer = AdminUpdateSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        service = self.service_class()

        updated_admin = service.update_profile(
            admin_instance=self.admin_user,
            name=serializer.validated_data.get('name'),
            new_password=serializer.validated_data.get('new_password')
        )

        return Response(AdminProfileSerializer(updated_admin).data, status=status.HTTP_200_OK)


================================================================================
文件路径: python-backend\management\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\management\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\map\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\map\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig



class MapConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'map'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\map\context.py
--------------------------------------------------------------------------------

from core.models import Map, Storearea, Facility, Otherarea, Eventarea
from django.db.models import Q
from core.context import BaseContext


class MapContext(BaseContext):
    def __init__(self):
        super().__init__(Map)

    def get_map_with_building(self, map_id):
        """获取地图并预加载建筑信息"""
        try:
            return self.model.objects.select_related('building').get(pk=map_id)
        except self.model.DoesNotExist:
            return None

    @staticmethod
    def get_map_elements(map_obj):
        """一次性获取地图关联的所有元素 ID"""
        # 注意：这里只负责取数据，不负责格式化
        store_ids = map_obj.storeareamap_set.values_list('storearea_id', flat=True)
        facility_ids = map_obj.facilitymap_set.values_list('facility_id', flat=True)
        other_ids = map_obj.otherareamap_set.values_list('otherarea_id', flat=True)
        event_ids = map_obj.eventareamap_set.values_list('eventarea_id', flat=True)
        return store_ids, facility_ids, other_ids, event_ids

    def list_all_with_building(self):
        """获取所有地图列表，并预加载建筑信息"""
        return self.model.objects.select_related('building').all()

class ElementContext:
    """负责处理具体的商铺、设施等元素"""

    @staticmethod
    def get_stores_by_ids(ids):
        return Storearea.objects.filter(id__in=ids)

    @staticmethod
    def get_facilities_by_ids(ids):
        return Facility.objects.filter(id__in=ids)

    @staticmethod
    def get_others_by_ids(ids):
        return Otherarea.objects.filter(id__in=ids)

    @staticmethod
    def get_events_by_ids(ids):
        return Eventarea.objects.filter(id__in=ids)

    @staticmethod
    def search_globally(keyword):
        stores = Storearea.objects.filter(store_name__icontains=keyword)
        others = Otherarea.objects.filter(description__icontains=keyword, is_public=True)
        return stores, others


================================================================================
文件路径: python-backend\map\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from core.models import Map, Storearea, Facility, Otherarea, Eventarea
import json


# ==========================================
# 1. 子元素序列化器 (先定义，供 MapSerializer 调用)
# ==========================================

class OtherareaSerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Otherarea
        # 将 is_public 暴露出来，前端可以用不同颜色渲染
        fields = ['id', 'type', 'description', 'is_public',  'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.shape: return None
        return json.loads(obj.shape.geojson)


class StoreareaSerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Storearea
        fields = ['id', 'store_name', 'type', 'logo_url', 'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.shape: return None
        return json.loads(obj.shape.geojson)


class FacilitySerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Facility
        fields = ['id', 'type', 'description', 'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.location: return None
        return json.loads(obj.location.geojson)


class EventareaSerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Eventarea
        fields = ['id', 'description',  'type', 'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.shape: return None
        return json.loads(obj.shape.geojson)


# ==========================================
# 2. 地图聚合序列化器 (核心修改部分)
# ==========================================

class MapSerializer(serializers.ModelSerializer):
    """
    地图详情：包含该楼层的底图几何信息，以及关联的商铺、设施等。
    """
    building_name = serializers.CharField(source='building.name', read_only=True)
    detail_geojson = serializers.SerializerMethodField()

    # --- 关键修改开始 ---
    # 使用 source='temp_xxx' 对应 MapDisplayService 中挂载的属性名
    # read_only=True 表示这些字段只用于输出，不用于写入
    stores = StoreareaSerializer(source='temp_stores', many=True, read_only=True)
    facilities = FacilitySerializer(source='temp_facilities', many=True, read_only=True)
    other_areas = OtherareaSerializer(source='temp_others', many=True, read_only=True)
    events = EventareaSerializer(source='temp_events', many=True, read_only=True)

    # --- 关键修改结束 ---

    class Meta:
        model = Map
        fields = [
            'id',
            'building_id',
            'building_name',
            'floor_number',
            'detail_geojson',
            # 必须把新字段加入 fields 列表
            'stores',
            'facilities',
            'other_areas',
            'events'
        ]

    @staticmethod
    def get_detail_geojson(obj):
        """
        处理底图几何 (外轮廓 + 镂空)
        """
        if not obj.detail:
            return None

        # 保持原始坐标系 (SRID 2385)，方便前端计算米制距离
        # 如果需要经纬度，需在此处 clone().transform(4326)
        geometry = obj.detail.clone()
        return json.loads(geometry.geojson)


================================================================================
文件路径: python-backend\map\services.py
--------------------------------------------------------------------------------

from django.contrib.gis.geos import GEOSGeometry, Polygon
from typing import Tuple, List
from map.context import MapContext, ElementContext
import json
from django.contrib.gis.geos import GEOSGeometry


# ==========================================
# Part 1: 纯几何算法 (保持不变)
# ==========================================
class GeometryAlgorithms:
    @staticmethod
    def validate_shape_syntax(geometry: GEOSGeometry) -> Tuple[bool, str]:
        if geometry is None: return False, "Geometry is None"
        if not geometry.valid: return False, f"Invalid Geometry: {geometry.valid_reason}"
        if isinstance(geometry, Polygon) and geometry.empty: return False, "Polygon is empty"
        return True, "Valid"

    @staticmethod
    def get_distance_between_areas(shape1: GEOSGeometry, shape2: GEOSGeometry) -> float:
        """
        接口 3: 获取输入的两个区域之间的距离
        """
        if not shape1 or not shape2:
            return -1.0
        # distance() 计算的是两个几何体之间最近点的欧几里得距离
        # 单位取决于 SRID (2385 为米)
        return shape1.distance(shape2)

    @staticmethod
    def validate_holes_inside_shell(outer_shell: GEOSGeometry, holes: List[GEOSGeometry]) -> Tuple[bool, str]:
        """
        接口 2: 镂空本身有无超出外轮廓区域
        """
        if not outer_shell:
            return False, "Outer shell is missing"

        if not holes:
            return True, "No holes to validate"

        for i, hole in enumerate(holes, start=1):
            # hole 必须完全在 outer_shell 内部 (contains)
            # 任何一部分超出或仅仅是相交都算非法
            if not outer_shell.contains(hole):
                return False, f"Hole #{i} is outside or intersecting the map boundary."

        return True, "All holes are valid"

    @staticmethod
    def check_placement(new_shape, outer_shell, holes, existing_obstacles):
        if not outer_shell: return False, "Map shell missing"
        if not outer_shell.contains(new_shape): return False, "Area exceeds map outer boundary"
        for i, hole in enumerate(holes):
            if hole.intersects(new_shape): return False, f"Area intersects with map hole #{i + 1}"
        for existing_shape in existing_obstacles:
            if existing_shape and existing_shape.intersects(new_shape):
                return False, "Area overlaps with an existing area"
        return True, "Placement valid"


# ==========================================
# Part 2: 业务服务 (修改部分)
# ==========================================

class MapDisplayService:
    """
    地图显示与校验服务
    """

    def __init__(self):
        self.map_ctx = MapContext()
        self.elem_ctx = ElementContext()

    def get_full_map_details(self, map_id):
        map_obj = self.map_ctx.get_map_with_building(map_id)
        if not map_obj: return None

        s_ids, f_ids, o_ids, e_ids = self.map_ctx.get_map_elements(map_obj)

        map_obj.temp_stores = self.elem_ctx.get_stores_by_ids(s_ids)
        map_obj.temp_facilities = self.elem_ctx.get_facilities_by_ids(f_ids)
        map_obj.temp_others = self.elem_ctx.get_others_by_ids(o_ids)
        map_obj.temp_events = self.elem_ctx.get_events_by_ids(e_ids)

        return map_obj

    def validate_geometry(self, geometry, map_id, exclude_id=None, area_type=None):
        """
        几何校验业务流程
        """
        # 1. 几何语法校验
        is_valid, msg = GeometryAlgorithms.validate_shape_syntax(geometry)
        if not is_valid:
            return False, msg

        # 2. 获取地图数据
        map_obj = self.map_ctx.get_map_with_building(map_id)
        if not map_obj or not map_obj.detail:
            return False, "Map data not found or empty"

        # 解析外轮廓和镂空
        outer_shell = map_obj.detail[0]
        holes = list(map_obj.detail[1:]) if len(map_obj.detail) > 1 else []

        # 3. 获取所有障碍物 (修改点：在 Service 层组装数据)
        obstacles = self._collect_obstacles(map_obj, exclude_id, area_type)

        # 4. 调用算法进行物理放置校验
        return GeometryAlgorithms.check_placement(
            new_shape=geometry,
            outer_shell=outer_shell,
            holes=holes,
            existing_obstacles=obstacles
        )

    def _collect_obstacles(self, map_obj, exclude_id, area_type) -> List[GEOSGeometry]:
        """
        私有辅助方法：利用 MapContext 和 ElementContext 收集该地图上所有实体的形状
        """
        obstacles = []

        # 1. 从 MapContext 获取所有关联 ID
        s_ids, f_ids, o_ids, e_ids = self.map_ctx.get_map_elements(map_obj)

        # 辅助函数：处理排除逻辑
        def should_include(item_id, item_type):
            # 如果类型相同且 ID 相同，则排除（说明是正在编辑的那个对象）
            if area_type == item_type and str(item_id) == str(exclude_id):
                return False
            return True

        # 2. 从 ElementContext 获取对象并提取形状

        # A. 商铺 (Stores)
        stores = self.elem_ctx.get_stores_by_ids(s_ids)
        for s in stores:
            if should_include(s.id, 'store') and s.shape:
                obstacles.append(s.shape)

        # B. 设施 (Facilities) - 需要 Buffer 处理
        facilities = self.elem_ctx.get_facilities_by_ids(f_ids)
        for f in facilities:
            if should_include(f.id, 'facility') and f.location:
                # 设施通常是点，必须膨胀成多边形才能进行碰撞检测
                # 假设半径 0.5 米
                obstacles.append(f.location.buffer(0.5))

        # C. 其他区域 (Otherareas)
        others = self.elem_ctx.get_others_by_ids(o_ids)
        for o in others:
            if should_include(o.id, 'other') and o.shape:
                obstacles.append(o.shape)

        # D. 活动区域 (Events)
        events = self.elem_ctx.get_events_by_ids(e_ids)
        for e in events:
            if should_include(e.id, 'event') and e.shape and e.is_active:
                obstacles.append(e.shape)

        return obstacles

    def get_map_list(self):
        """
        获取地图列表概要
        """
        # 1. 从 Context 获取所有地图
        maps = self.map_ctx.list_all_with_building()

        # 2. 初始化空属性，防止 MapSerializer 报错
        # (因为列表页通常不需要加载 heavy 的商铺/设施数据，只看底图或基础信息)
        for map_obj in maps:
            map_obj.temp_stores = []
            map_obj.temp_facilities = []
            map_obj.temp_others = []
            map_obj.temp_events = []

        return maps

    def validate_batch(self, map_id, updates_list):
        """
        批量校验
        :param map_id: 地图ID
        :param updates_list: 预处理过的列表，每项包含 'geos_obj' (GEOSGeometry)
        :return: (is_valid, errors_list)
        """
        # 1. 获取地图底图 (外框和镂空)
        map_obj = self.map_ctx.get_map_with_building(map_id)
        if not map_obj or not map_obj.detail:
            return False, ["地图数据缺失"]

        outer_shell = map_obj.detail[0]
        holes = list(map_obj.detail[1:]) if len(map_obj.detail) > 1 else []

        # 2. 整理新数据 (不再需要解析 JSON，直接取对象)
        new_geometries = []
        updated_keys = set()

        for item in updates_list:
            # 直接获取 View 层解析好的几何对象
            shape = item['geos_obj']

            # 统一为多边形用于碰撞检测 (点 -> 圆)
            collision_shape = shape.buffer(0.3) if shape.geom_type == 'Point' else shape

            item_type = str(item.get('type')).lower()
            item_id = str(item.get('id'))

            new_geometries.append({
                'id': item_id,
                'type': item_type,
                'shape': collision_shape,
                'name': item.get('name', 'Unknown')
            })

            key = f"{item_type}-{item_id}"
            updated_keys.add(key)

        # 3. 从数据库获取“背景障碍物” (排除掉在 updated_keys 里的项)
        s_ids, f_ids, o_ids, e_ids = self.map_ctx.get_map_elements(map_obj)
        static_obstacles = []

        def add_static(objects, type_name):
            for obj in objects:
                key = f"{type_name}-{str(obj.id)}"
                if key not in updated_keys:
                    shape = getattr(obj, 'shape', None)
                    if type_name == 'facility':
                        loc = getattr(obj, 'location', None)
                        if loc: shape = loc.buffer(0.3)

                    if shape:
                        static_obstacles.append(shape)

        add_static(self.elem_ctx.get_stores_by_ids(s_ids), 'store')
        add_static(self.elem_ctx.get_facilities_by_ids(f_ids), 'facility')
        add_static(self.elem_ctx.get_others_by_ids(o_ids), 'other')
        active_events = [e for e in self.elem_ctx.get_events_by_ids(e_ids) if e.is_active]
        add_static(active_events, 'event')

        # 4. 执行校验
        errors = []

        for curr in new_geometries:
            curr_shape = curr['shape']

            # 4.1 边界检查
            if not outer_shell.contains(curr_shape):
                errors.append(f"[{curr['name']}] 超出地图边界")
                continue

            for hole in holes:
                if hole.intersects(curr_shape) and not hole.touches(curr_shape):
                    errors.append(f"[{curr['name']}] 进入了地图镂空/中庭区域")
                    break

            # 4.2 静态障碍物碰撞
            for obs in static_obstacles:
                if obs.intersects(curr_shape) and not obs.touches(curr_shape):
                    errors.append(f"[{curr['name']}] 与未修改的固定区域重叠")
                    break

            # 4.3 动态物体互撞 (A 撞 B)
            for other in new_geometries:
                if curr['id'] == other['id'] and curr['type'] == other['type']:
                    continue

                if curr['type'] == 'facility' and other['type'] == 'facility':
                    continue

                if other['shape'].intersects(curr_shape) and not other['shape'].touches(curr_shape):
                    if curr['id'] < other['id']:
                        errors.append(f"[{curr['name']}] 与 [{other['name']}] 重叠")
                    break

        if len(errors) > 0:
            return False, errors

        return True, []


================================================================================
文件路径: python-backend\map\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.
from rest_framework.test import APITestCase
from rest_framework import status
from django.urls import reverse
from django.contrib.gis.geos import Polygon, GeometryCollection
from core.models import Building, Map, Storearea, StoreareaMap


class MapViewSetTestCase(APITestCase):
    """
    测试 MapViewSet 的 list 和 retrieve 接口
    验证从数据库到 Service 再到 View 的数据流是否正常
    """

    def setUp(self):
        """
        测试数据准备：
        1. 创建 Building
        2. 创建 Map (带 GeometryCollection)
        3. 创建 Storearea (带 Polygon)
        4. 建立 Map 和 Storearea 的关联
        """
        # 1. 创建建筑
        self.building = Building.objects.create(
            name="测试万达广场",
            address="上海市杨浦区"
        )

        # 2. 创建地图底图几何 (SRID 2385)
        # 假设是一个 100x100 的正方形外轮廓
        outer_shell = Polygon(((0, 0), (0, 100), (100, 100), (100, 0), (0, 0)), srid=2385)
        # detail 字段是 GeometryCollection
        map_detail = GeometryCollection(outer_shell, srid=2385)

        self.map_obj = Map.objects.create(
            building=self.building,
            floor_number=1,
            detail=map_detail
        )

        # 3. 创建商铺
        # 在地图内部创建一个 10x10 的小方块商铺
        store_shape = Polygon(((10, 10), (10, 20), (20, 20), (20, 10), (10, 10)), srid=2385)
        self.store = Storearea.objects.create(
            store_name="测试海底捞",
            type=1,
            shape=store_shape,
            owner_name="张三",
            owner_phone="123456",
            is_active = True
        )

        # 4. 关联商铺到地图 (重要：否则 retrieve 接口不会返回该商铺)
        StoreareaMap.objects.create(
            map=self.map_obj,
            storearea=self.store
        )

        # 路由名称定义 (对应 urls.py 中的 router.register(..., basename='maps'))
        self.list_url = reverse('map-list')
        self.detail_url = reverse('map-detail', args=[self.map_obj.id])

    def test_list_maps(self):
        """
        测试获取地图列表 (GET /api/maps/)
        """
        response = self.client.get(self.list_url)

        # 1. 验证状态码
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        # 2. 验证返回数据类型是列表
        self.assertIsInstance(response.data, list)
        self.assertEqual(len(response.data), 1)

        # 3. 验证基础字段
        map_data = response.data[0]
        self.assertEqual(map_data['floor_number'], 1)
        self.assertEqual(map_data['building_name'], "测试万达广场")

        # 4. 验证列表接口是否正确处理了 temp_stores (应该为空列表或不报错)
        # 根据我们之前的 Service 逻辑，列表接口为了性能可能没有加载 stores，或者加载了空列表
        if 'stores' in map_data:
            self.assertIsInstance(map_data['stores'], list)

    def test_retrieve_map_success(self):
        """
        测试获取单张地图详情 (GET /api/maps/{id}/)
        核心：验证 Service 是否成功组装了 detail_geojson 和 stores
        """
        response = self.client.get(self.detail_url)

        # 1. 验证状态码
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        data = response.data

        # 2. 验证底图几何 (detail_geojson)
        self.assertIn('detail_geojson', data)
        self.assertEqual(data['detail_geojson']['type'], 'GeometryCollection')

        # 3. 验证关联元素 (stores)
        # 这是验证 MapDisplayService.get_full_map_details 逻辑的关键
        self.assertIn('stores', data)
        self.assertEqual(len(data['stores']), 1)

        store_data = data['stores'][0]
        self.assertEqual(store_data['store_name'], "测试海底捞")
        self.assertEqual(store_data['id'], self.store.id)

        # 验证商铺的几何是否被正确序列化为 GeoJSON
        self.assertIn('geometry', store_data)
        self.assertEqual(store_data['geometry']['type'], 'Polygon')

        # 4. 验证其他空列表字段是否存在 (facilities, events, etc.)
        self.assertIn('facilities', data)
        self.assertEqual(data['facilities'], [])  # setUp中没创建设施，应为空列表

    def test_retrieve_map_not_found(self):
        """
        测试获取不存在的地图 ID
        """
        non_existent_url = reverse('map-detail', args=[99999])
        response = self.client.get(non_existent_url)

        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)


================================================================================
文件路径: python-backend\map\views.py
--------------------------------------------------------------------------------

from rest_framework import viewsets, status
from rest_framework.views import APIView
from rest_framework.response import Response
from django.contrib.gis.geos import GEOSGeometry
import json

from .serializers import MapSerializer  # 序列化器依然需要，用于格式化输出
from map.services import MapDisplayService


class MapViewSet(viewsets.ViewSet):
    """
    只读 ViewSet，不继承 ModelViewSet
    """
    service_class = MapDisplayService

    def list(self, request):
        """GET /api/maps/"""
        service = self.service_class()

        # 1. 调用 Service 获取列表
        maps = service.get_map_list()

        # 2. 序列化返回
        # 注意：这里会返回所有地图的 GeoJSON，数据量可能较大
        # 实际生产中建议单独定义一个 SimpleMapSerializer (不含 detail_geojson) 用于列表
        serializer = MapSerializer(maps, many=True)

        return Response(serializer.data)

    def retrieve(self, request, pk=None):
        """GET /api/maps/{id}/"""
        service = self.service_class()

        # 1. 调用 Service 获取组装好的对象
        map_data = service.get_full_map_details(pk)

        if not map_data:
            return Response({"error": "Map not found"}, status=status.HTTP_404_NOT_FOUND)

        # 2. 使用 Serializer 格式化 Service 返回的数据
        # 注意：Serializer 内部字段 source='temp_stores' 需要对应 Service 挂载的属性
        serializer = MapSerializer(map_data)
        return Response(serializer.data)


class MapValidationView(APIView):
    """POST /api/maps/validate/"""
    service_class = MapDisplayService

    def post(self, request):
        service = self.service_class()

        # 1. 参数提取
        geometry_data = request.data.get('geometry')
        map_id = request.data.get('map_id')
        area_type = request.data.get('type')
        exclude_id = request.data.get('exclude_id')

        # 2. 数据预处理
        try:
            shape_str = json.dumps(geometry_data) if isinstance(geometry_data, dict) else geometry_data
            shape = GEOSGeometry(shape_str)
            if shape.srid != 2385: shape.srid = 2385
        except Exception:
            return Response({"error": "Invalid Geometry"}, status=400)

        # 3. 调用 Service 业务逻辑
        is_valid, reason = service.validate_geometry(shape, map_id, exclude_id, area_type)

        return Response({"valid": is_valid, "reason": reason})


class MapBatchValidationView(APIView):
    """POST /api/maps/validate_batch/ (批量校验)"""
    service_class = MapDisplayService

    def post(self, request):
        service = self.service_class()

        map_id = request.data.get('map_id')
        updates = request.data.get('updates', [])

        if not map_id:
            return Response({"error": "map_id is required"}, status=status.HTTP_400_BAD_REQUEST)

        # --- 数据预处理：在 View 层统一解析几何并修正 SRID ---
        processed_updates = []
        for i, item in enumerate(updates):
            try:
                # 1. 提取原始数据
                raw_geo = item.get('geometry') or item.get('location')
                if not raw_geo: continue

                # 2. 转字符串
                shape_str = json.dumps(raw_geo) if isinstance(raw_geo, dict) else raw_geo

                # 3. 解析几何
                shape = GEOSGeometry(shape_str)

                # 4. 强制修正 SRID (与 MapValidationView 保持一致)
                if shape.srid != 2385:
                    shape.srid = 2385

                # 5. 将处理好的 GEOSGeometry 对象注入 item
                # 使用一个新的 key 'geos_obj' 传递给 Service
                item['geos_obj'] = shape
                processed_updates.append(item)

            except Exception as e:
                # 如果解析失败，直接返回 400，中断处理
                return Response(
                    {"error": f"Invalid geometry at index {i} (ID: {item.get('id')}): {str(e)}"},
                    status=status.HTTP_400_BAD_REQUEST
                )

        # 调用 Service，传入包含 GEOSGeometry 对象的列表
        is_valid, errors = service.validate_batch(map_id, processed_updates)

        return Response({
            "valid": is_valid,
            "errors": errors
        })


================================================================================
文件路径: python-backend\map\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\map\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\python_backend\settings.py
--------------------------------------------------------------------------------

"""
Django settings for python_backend project.

Based on by 'django-admin startproject' using Django 2.1.2.

For more information on this file, see
https://docs.djangoproject.com/en/2.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/2.1/ref/settings/
"""

import os
import posixpath

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/2.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = '7306ec88-3719-40e9-88d4-2d6fdee59734'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ['*']

# Application references
# https://docs.djangoproject.com/en/2.1/ref/settings/#std:setting-INSTALLED_APPS
INSTALLED_APPS = [
    # Add your apps here to enable them
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.gis',
    'rest_framework',
    'django_filters',
    # 支持跨域请求
    'corsheaders',
    'core.apps.CoreConfig',
    'map.apps.MapConfig',
    'client.apps.ClientConfig',
    'management.apps.ManagementConfig',
    'search.apps.SearchConfig',
    'guide.apps.GuideConfig',
    'editor.apps.EditorConfig'
]

# Middleware framework
# https://docs.djangoproject.com/en/2.1/topics/http/middleware/
MIDDLEWARE = [
    # CORS middleware should be placed as high as possible
    'corsheaders.middleware.CorsMiddleware',
    # 注意：确保 CommonMiddleware 仍然在 CorsMiddleware 之后
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'python_backend.urls'

# Template configuration
# https://docs.djangoproject.com/en/2.1/topics/templates/
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'python_backend.wsgi.application'

# Database
# https://docs.djangoproject.com/en/2.1/ref/settings/#databases
DATABASES = {
    'default': {
        'ENGINE': 'django.contrib.gis.db.backends.postgis',
        'NAME': os.environ.get('POSTGRES_DB'),
        'USER': os.environ.get('POSTGRES_USER'),
        'PASSWORD': os.environ.get('POSTGRES_PASSWORD'),
        'HOST': 'postgres-db',
        'PORT': '5432',
    }
}

# Password validation
# https://docs.djangoproject.com/en/2.1/ref/settings/#auth-password-validators
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Internationalization
# https://docs.djangoproject.com/en/2.1/topics/i18n/
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_L10N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/2.1/howto/static-files/
STATIC_URL = '/static/'
STATIC_ROOT = posixpath.join(*(BASE_DIR.split(os.path.sep) + ['static']))

REST_FRAMEWORK = {
    # 默认权限设置：这里设置为默认需要登录才能访问，方便后续开发
    'DEFAULT_PERMISSION_CLASSES': [
        # 'rest_framework.permissions.IsAuthenticated',
        # 如果是开发初期想全部公开，可以改为:
        'rest_framework.permissions.AllowAny',
    ],

    # 默认认证方式
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
    ],

    # 默认分页设置 (推荐配置，防止大数据量查死数据库)
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,

    # 统一日期格式 (可选)
    'DATETIME_FORMAT': '%Y-%m-%d %H:%M:%S',
}

# CORS 设置（开发环境方便测试，生产请按需限制）
CORS_ALLOWED_ORIGINS = [
  "http://localhost:8080"
]
CORS_ALLOW_CREDENTIALS = True
# 可根据需要自定义允许的头、方法
# CORS_ALLOW_HEADERS = list(default_headers) + [
#     'your-custom-header',
# ]



================================================================================
文件路径: python-backend\python_backend\urls.py
--------------------------------------------------------------------------------

"""
python_backend URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/2.1/topics/http/urls/

Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""

# Uncomment next two lines to enable admin:
from django.contrib import admin
from django.urls import path,include
from rest_framework.routers import DefaultRouter
from map.views import MapViewSet, MapValidationView, MapBatchValidationView

from guide.views import RoutePlanView

from management.views import AdminAuthView, AdminProfileView


router = DefaultRouter()
router.register(r'maps', MapViewSet, basename='map')
urlpatterns = [
    path('search/', include('search.urls')),
    path('api/editor/', include('editor.urls')),
    path('api/management/', include('management.urls')),
    # Uncomment the next line to enable the admin:
    #path('admin/', admin.site.urls)
    path('api/maps/validate/', MapValidationView.as_view(), name='map-validate'),
    path('api/maps/validate_batch/', MapBatchValidationView.as_view(), name='map-validate-batch'),
    path('api/guide/route/',RoutePlanView.as_view(), name='route-plan'),
    path('api/', include(router.urls)),
    path('api/management/auth/<str:action>/', AdminAuthView.as_view(), name='admin-auth'),
    path('api/management/profile/', AdminProfileView.as_view(), name='admin-profile'),
    path('admin/', admin.site.urls),
    path('api/search/', include('search.urls')),
    # 其他URL配置...
]



================================================================================
文件路径: python-backend\python_backend\wsgi.py
--------------------------------------------------------------------------------

"""
WSGI config for python_backend project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

For more information, visit
https://docs.djangoproject.com/en/2.1/howto/deployment/wsgi/
"""

import os

import django
from django.core.wsgi import get_wsgi_application

os.environ.setdefault(
    'DJANGO_SETTINGS_MODULE',
    'python_backend.settings')
django.setup()

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
application = get_wsgi_application()



================================================================================
文件路径: python-backend\python_backend\__init__.py
--------------------------------------------------------------------------------

"""
Package for python_backend.
"""



================================================================================
文件路径: python-backend\search\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\search\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class SearchConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'search'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\search\context.py
--------------------------------------------------------------------------------

from django.apps import apps
from django.db.models import Q


class BaseSearchContext:
    """基础搜索上下文类"""

    def __init__(self, model_name):
        self.model_name = model_name
        self.model = apps.get_model('core', model_name)


class StoreareaContext(BaseSearchContext):
    """店铺区域上下文"""

    def __init__(self):
        super().__init__('Storearea')

    def get_by_id(self, storearea_id):
        """根据ID获取店铺区域"""
        try:
            return self.model.objects.get(id=storearea_id)
        except self.model.DoesNotExist:
            return None

    def search_by_name(self, name):
        """根据名称搜索店铺区域"""
        return self.model.objects.filter(
            store_name__icontains=name,
            is_active=True
        )

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选店铺区域"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_storearea_map_relations(self, storearea_id):
        """获取店铺区域的地图关联"""
        StoreareaMap = apps.get_model('core', 'StoreareaMap')
        return StoreareaMap.objects.filter(storearea_id=storearea_id)


class EventContext(BaseSearchContext):
    """活动上下文"""

    def __init__(self):
        super().__init__('Event')

    def get_by_id(self, event_id):
        """根据ID获取活动"""
        try:
            return self.model.objects.get(id=event_id)
        except self.model.DoesNotExist:
            return None

    def search_by_name(self, name):
        """根据名称搜索活动"""
        return self.model.objects.filter(
            event_name__icontains=name,
            is_active=True
        )

    def filter_active_events(self):
        """获取所有活跃活动"""
        return self.model.objects.filter(is_active=True)

    def get_event_storearea_relations(self, event_id):
        """获取活动的店铺区域关联"""
        EventStorearea = apps.get_model('core', 'EventStorearea')
        return EventStorearea.objects.filter(event_id=event_id)

    def get_event_eventarea_relations(self, event_id):
        """获取活动的活动区域关联"""
        EventEventarea = apps.get_model('core', 'EventEventarea')
        return EventEventarea.objects.filter(event_id=event_id)


class EventareaContext(BaseSearchContext):
    """活动区域上下文"""

    def __init__(self):
        super().__init__('Eventarea')

    def get_by_id(self, eventarea_id):
        """根据ID获取活动区域"""
        try:
            return self.model.objects.get(id=eventarea_id)
        except self.model.DoesNotExist:
            return None

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选活动区域"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_eventarea_map_relations(self, eventarea_id):
        """获取活动区域的地图关联"""
        EventareaMap = apps.get_model('core', 'EventareaMap')
        return EventareaMap.objects.filter(eventarea_id=eventarea_id)

    def get_eventarea_map_relations_by_map(self, map_id):
        """根据地图ID获取活动区域关联"""
        EventareaMap = apps.get_model('core', 'EventareaMap')
        return EventareaMap.objects.filter(map_id=map_id)


class FacilityContext(BaseSearchContext):
    """设施上下文"""

    def __init__(self):
        super().__init__('Facility')

    def get_by_id(self, facility_id):
        """根据ID获取设施"""
        try:
            return self.model.objects.get(id=facility_id)
        except self.model.DoesNotExist:
            return None

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选设施"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_facility_map_relations(self, facility_id):
        """获取设施的地图关联"""
        FacilityMap = apps.get_model('core', 'FacilityMap')
        return FacilityMap.objects.filter(facility_id=facility_id)

    def get_facility_map_relations_by_map(self, map_id):
        """根据地图ID获取设施关联"""
        FacilityMap = apps.get_model('core', 'FacilityMap')
        return FacilityMap.objects.filter(map_id=map_id)


class OtherareaContext(BaseSearchContext):
    """其他区域上下文"""

    def __init__(self):
        super().__init__('Otherarea')

    def get_by_id(self, otherarea_id):
        """根据ID获取其他区域"""
        try:
            return self.model.objects.get(id=otherarea_id)
        except self.model.DoesNotExist:
            return None

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选其他区域"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_otherarea_map_relations(self, otherarea_id):
        """获取其他区域的地图关联"""
        OtherareaMap = apps.get_model('core', 'OtherareaMap')
        return OtherareaMap.objects.filter(otherarea_id=otherarea_id)

    def get_otherarea_map_relations_by_map(self, map_id):
        """根据地图ID获取其他区域关联"""
        OtherareaMap = apps.get_model('core', 'OtherareaMap')
        return OtherareaMap.objects.filter(map_id=map_id)


class SearchElementContext:
    """搜索元素上下文，用于处理关联关系"""

    @staticmethod
    def get_storearea_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取店铺区域ID"""
        StoreareaMap = apps.get_model('core', 'StoreareaMap')
        Storearea = apps.get_model('core', 'Storearea')

        # 获取该地图的所有storearea关联
        storearea_maps = StoreareaMap.objects.filter(map_id=map_id)
        storearea_ids = [sm.storearea_id for sm in storearea_maps]

        # 如果提供了类型参数，则进一步过滤
        if type_id is not None:
            storeareas = Storearea.objects.filter(
                id__in=storearea_ids,
                type=type_id,
                is_active=True
            )
            storearea_ids = [storearea.id for storearea in storeareas]

        return storearea_ids

    @staticmethod
    def get_eventarea_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取活动区域ID"""
        EventareaMap = apps.get_model('core', 'EventareaMap')
        Eventarea = apps.get_model('core', 'Eventarea')

        eventarea_maps = EventareaMap.objects.filter(map_id=map_id)
        eventarea_ids = [em.eventarea_id for em in eventarea_maps]

        if type_id is not None:
            eventareas = Eventarea.objects.filter(
                id__in=eventarea_ids,
                type=type_id,
                is_active=True
            )
            eventarea_ids = [eventarea.id for eventarea in eventareas]

        return eventarea_ids

    @staticmethod
    def get_facility_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取设施ID"""
        FacilityMap = apps.get_model('core', 'FacilityMap')
        Facility = apps.get_model('core', 'Facility')

        facility_maps = FacilityMap.objects.filter(map_id=map_id)
        facility_ids = [fm.facility_id for fm in facility_maps]

        if type_id is not None:
            facilities = Facility.objects.filter(
                id__in=facility_ids,
                type=type_id,
                is_active=True
            )
            facility_ids = [facility.id for facility in facilities]

        return facility_ids

    @staticmethod
    def get_otherarea_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取其他区域ID"""
        OtherareaMap = apps.get_model('core', 'OtherareaMap')
        Otherarea = apps.get_model('core', 'Otherarea')

        otherarea_maps = OtherareaMap.objects.filter(map_id=map_id)
        otherarea_ids = [om.otherarea_id for om in otherarea_maps]

        if type_id is not None:
            otherareas = Otherarea.objects.filter(
                id__in=otherarea_ids,
                type=type_id,
                is_active=True
            )
            otherarea_ids = [otherarea.id for otherarea in otherareas]

        return otherarea_ids


================================================================================
文件路径: python-backend\search\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from django.apps import apps


# 使用延迟加载的方式定义序列化器
def get_storearea_serializer():
    Storearea = apps.get_model('core', 'Storearea')

    class StoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            fields = '__all__'

    return StoreareaSerializer


def get_event_serializer():
    Event = apps.get_model('core', 'Event')

    class EventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = '__all__'

    return EventSerializer


def get_eventarea_serializer():
    Eventarea = apps.get_model('core', 'Eventarea')

    class EventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            fields = '__all__'

    return EventareaSerializer


def get_facility_serializer():
    Facility = apps.get_model('core', 'Facility')

    class FacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            fields = '__all__'

    return FacilitySerializer


def get_otherarea_serializer():
    Otherarea = apps.get_model('core', 'Otherarea')

    class OtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            fields = '__all__'

    return OtherareaSerializer


def get_simple_storearea_serializer():
    Storearea = apps.get_model('core', 'Storearea')

    class SimpleStoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            fields = ['id', 'store_name', 'type']

    return SimpleStoreareaSerializer


def get_simple_event_serializer():
    Event = apps.get_model('core', 'Event')

    class SimpleEventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = ['id', 'event_name', 'start_date', 'end_date']

    return SimpleEventSerializer


def get_simple_eventarea_serializer():
    Eventarea = apps.get_model('core', 'Eventarea')

    class SimpleEventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            fields = ['id', 'organizer_name', 'type']

    return SimpleEventareaSerializer


def get_simple_facility_serializer():
    Facility = apps.get_model('core', 'Facility')

    class SimpleFacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            fields = ['id', 'type']

    return SimpleFacilitySerializer


def get_simple_otherarea_serializer():
    Otherarea = apps.get_model('core', 'Otherarea')

    class SimpleOtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            fields = ['id', 'type', 'is_public']

    return SimpleOtherareaSerializer



================================================================================
文件路径: python-backend\search\services.py
--------------------------------------------------------------------------------

from rest_framework import status
from django.apps import apps
from .context import (
    StoreareaContext, EventContext, EventareaContext,
    FacilityContext, OtherareaContext, SearchElementContext
)


class SearchService:
    """搜索服务"""

    def __init__(self):
        self.storearea_ctx = StoreareaContext()
        self.event_ctx = EventContext()
        self.eventarea_ctx = EventareaContext()
        self.facility_ctx = FacilityContext()
        self.otherarea_ctx = OtherareaContext()
        self.element_ctx = SearchElementContext()

    # ========== 店铺搜索功能 ==========

    def get_storearea_by_id(self, storearea_id):
        """获取ID为<>的商铺区域的所有信息"""
        storearea = self.storearea_ctx.get_by_id(storearea_id)
        if not storearea:
            return None, {'error': 'Storearea not found'}, status.HTTP_404_NOT_FOUND
        return storearea, None, None

    def search_storearea_by_name(self, name):
        """按名称寻找店铺区域"""
        if not name:
            return None, {'error': 'Name parameter is required'}, status.HTTP_400_BAD_REQUEST
        storeareas = self.storearea_ctx.search_by_name(name)
        return storeareas, None, None

    def list_storearea_by_type(self, type_param):
        """返回指定类型店铺区域列表"""
        if type_param:
            try:
                type_id = int(type_param)
                storeareas = self.storearea_ctx.filter_by_type(type_id=type_id)
                return storeareas, {'type': type_id}, None
            except ValueError:
                return None, {'error': 'Invalid type parameter'}, status.HTTP_400_BAD_REQUEST
        else:
            storeareas = self.storearea_ctx.filter_by_type()
            return storeareas, None, None

    def get_storearea_events(self, storearea_id):
        """返回指定店铺区域的所有活动ID列表"""
        storearea = self.storearea_ctx.get_by_id(storearea_id)
        if not storearea or not storearea.is_active:
            return None, {'error': 'Storearea not found'}, status.HTTP_404_NOT_FOUND

        EventStorearea = apps.get_model('core', 'EventStorearea')
        event_relations = EventStorearea.objects.filter(storearea_id=storearea_id)
        event_ids = [relation.event_id for relation in event_relations]

        return {'storearea_id': storearea_id, 'event_ids': event_ids}, None, None

    def get_storearea_map_ids(self, storearea_id):
        """获取storearea_id为<>的活动区域所属的map_id"""
        storearea_maps = self.storearea_ctx.get_storearea_map_relations(storearea_id)
        map_ids = [storearea_map.map_id for storearea_map in storearea_maps]
        return {'storearea_id': storearea_id, 'map_ids': map_ids}, None, None

    def get_storearea_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且type为<>的所有storearea的id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            storearea_ids = self.element_ctx.get_storearea_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'storearea_ids': storearea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_all_storearea_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有storearea_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            storearea_ids = self.element_ctx.get_storearea_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'storearea_ids': storearea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST

    # ========== 活动搜索功能 ==========

    def get_event_by_id(self, event_id):
        """按ID寻找活动"""
        event = self.event_ctx.get_by_id(event_id)
        if not event:
            return None, {'error': 'Event not found'}, status.HTTP_404_NOT_FOUND
        return event, None, None

    def search_event_by_name(self, name):
        """按名称寻找活动"""
        if not name:
            return None, {'error': 'Name parameter is required'}, status.HTTP_400_BAD_REQUEST
        events = self.event_ctx.search_by_name(name)
        return events, None, None

    def list_event_by_type(self, type_param):
        """返回指定类型活动列表"""
        events = self.event_ctx.filter_active_events()

        if type_param:
            try:
                type_id = int(type_param)
                EventEventarea = apps.get_model('core', 'EventEventarea')
                event_ids = EventEventarea.objects.filter(
                    eventarea__type=type_id
                ).values_list('event_id', flat=True).distinct()

                events = events.filter(id__in=event_ids)
                return events, {'type': type_id}, None
            except ValueError:
                return None, {'error': 'Invalid type parameter'}, status.HTTP_400_BAD_REQUEST
        else:
            return events, None, None

    def get_event_areas(self, event_id):
        """返回参加该活动的区域ID列表"""
        event = self.event_ctx.get_by_id(event_id)
        if not event:
            return None, {'error': 'Event not found'}, status.HTTP_404_NOT_FOUND

        storearea_relations = self.event_ctx.get_event_storearea_relations(event_id)
        storearea_ids = [relation.storearea_id for relation in storearea_relations]

        eventarea_relations = self.event_ctx.get_event_eventarea_relations(event_id)
        eventarea_ids = [relation.eventarea_id for relation in eventarea_relations]

        result = {
            'event_id': event_id,
            'storearea_ids': storearea_ids,
            'eventarea_ids': eventarea_ids,
            'all_area_ids': storearea_ids + eventarea_ids
        }
        return result, None, None

    # ========== 活动区域功能 ==========

    def get_eventarea_by_id(self, eventarea_id):
        """获取id为<>的活动区域的所有信息"""
        eventarea = self.eventarea_ctx.get_by_id(eventarea_id)
        if not eventarea:
            return None, {'error': 'Eventarea not found'}, status.HTTP_404_NOT_FOUND
        return eventarea, None, None

    def get_eventarea_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且 type为<>的所有eventarea的id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            eventarea_ids = self.element_ctx.get_eventarea_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'eventarea_ids': eventarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_eventarea_map_ids(self, eventarea_id):
        """获取eventarea_id为<>的活动区域所属的map_id"""
        eventarea_maps = self.eventarea_ctx.get_eventarea_map_relations(eventarea_id)
        map_ids = [eventarea_map.map_id for eventarea_map in eventarea_maps]
        return {'eventarea_id': eventarea_id, 'map_ids': map_ids}, None, None

    def get_all_eventarea_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有eventarea_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            eventarea_ids = self.element_ctx.get_eventarea_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'eventarea_ids': eventarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST

    # ========== 设施功能 ==========

    def get_facility_by_id(self, facility_id):
        """获取id为<>的设施的所有信息"""
        facility = self.facility_ctx.get_by_id(facility_id)
        if not facility:
            return None, {'error': 'Facility not found'}, status.HTTP_404_NOT_FOUND
        return facility, None, None

    def get_facility_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且type为<>的所有设施id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            facility_ids = self.element_ctx.get_facility_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'facility_ids': facility_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_facility_map_ids(self, facility_id):
        """获取facility_id为<>的活动区域所属的map_id"""
        facility_maps = self.facility_ctx.get_facility_map_relations(facility_id)
        map_ids = [facility_map.map_id for facility_map in facility_maps]
        return {'facility_id': facility_id, 'map_ids': map_ids}, None, None

    def get_all_facility_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有facility_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            facility_ids = self.element_ctx.get_facility_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'facility_ids': facility_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST

    # ========== 其他区域功能 ==========

    def get_otherarea_by_id(self, otherarea_id):
        """获取id为<>的其他区域的所有信息"""
        otherarea = self.otherarea_ctx.get_by_id(otherarea_id)
        if not otherarea:
            return None, {'error': 'Otherarea not found'}, status.HTTP_404_NOT_FOUND
        return otherarea, None, None

    def get_otherarea_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且type为<>的所有otherarea的id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            otherarea_ids = self.element_ctx.get_otherarea_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'otherarea_ids': otherarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_otherarea_map_ids(self, otherarea_id):
        """获取otherarea_id为<>的活动区域所属的map_id"""
        otherarea_maps = self.otherarea_ctx.get_otherarea_map_relations(otherarea_id)
        map_ids = [otherarea_map.map_id for otherarea_map in otherarea_maps]
        return {'otherarea_id': otherarea_id, 'map_ids': map_ids}, None, None

    def get_all_otherarea_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有otherarea_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            otherarea_ids = self.element_ctx.get_otherarea_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'otherarea_ids': otherarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST


================================================================================
文件路径: python-backend\search\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\search\urls.py
--------------------------------------------------------------------------------

from django.urls import path
from . import views

urlpatterns = [
    # Search店铺功能
    path('storearea/<int:storearea_id>/', views.storearea_by_id, name='storearea-by-id'),
    path('storearea/search/', views.storearea_search, name='storearea-search'),
    path('storearea/list/', views.storearea_list_by_type, name='storearea-list-by-type'),
    path('storearea/<int:storearea_id>/events/', views.storearea_events, name='storearea-events'),

    # 新增的店铺区域功能
    path('storearea/<int:storearea_id>/map/', views.storearea_map_ids, name='storearea-map-ids'),
    path('storearea/list/map/', views.storearea_ids_by_map_and_type, name='storearea-ids-by-map-type'),
    path('storearea/list/all_by_map/', views.all_storearea_ids_by_map, name='all-storearea-ids-by-map'),

    # Search活动功能
    path('event/<int:event_id>/', views.event_by_id, name='event-by-id'),
    path('event/search/', views.event_search, name='event-search'),
    path('event/list/', views.event_list_by_type, name='event-list-by-type'),
    path('event/<int:event_id>/areas/', views.event_areas, name='event-areas'),

    # 新增的活动区域功能
    path('eventarea/<int:eventarea_id>/', views.eventarea_by_id, name='eventarea-by-id'),
    path('eventarea/list/ids_by_map_type/', views.eventarea_ids_by_map_and_type, name='eventarea-ids-by-map-type'),
    path('eventarea/<int:eventarea_id>/map/', views.eventarea_map_ids, name='eventarea-map-ids'),
    path('eventarea/list/all_by_map/', views.all_eventarea_ids_by_map, name='all-eventarea-ids-by-map'),

    # 新增的设施功能
    path('facility/<int:facility_id>/', views.facility_by_id, name='facility-by-id'),
    path('facility/list/ids_by_map_type/', views.facility_ids_by_map_and_type, name='facility-ids-by-map-type'),
    path('facility/<int:facility_id>/map/', views.facility_map_ids, name='facility-map-ids'),
    path('facility/list/all_by_map/', views.all_facility_ids_by_map, name='all-facility-ids-by-map'),

    # 新增的其他区域功能
    path('otherarea/<int:otherarea_id>/', views.otherarea_by_id, name='otherarea-by-id'),
    path('otherarea/list/ids_by_map_type/', views.otherarea_ids_by_map_and_type, name='otherarea-ids-by-map-type'),
    path('otherarea/<int:otherarea_id>/map/', views.otherarea_map_ids, name='otherarea-map-ids'),
    path('otherarea/list/all_by_map/', views.all_otherarea_ids_by_map, name='all-otherarea-ids-by-map'),
]


================================================================================
文件路径: python-backend\search\views.py
--------------------------------------------------------------------------------

from rest_framework.decorators import api_view
from rest_framework.response import Response
from .services import SearchService
from .serializers import (
    get_storearea_serializer, get_simple_storearea_serializer,
    get_event_serializer, get_simple_event_serializer,
    get_eventarea_serializer, get_simple_eventarea_serializer,
    get_facility_serializer, get_simple_facility_serializer,
    get_otherarea_serializer, get_simple_otherarea_serializer
)

search_service = SearchService()


# ========== 店铺搜索功能 ==========

@api_view(['GET'])
def storearea_by_id(request, storearea_id):
    """获取id为<>的商铺区域的所有信息"""
    result, error, status_code = search_service.get_storearea_by_id(storearea_id)
    if error:
        return Response(error, status=status_code)

    StoreareaSerializer = get_storearea_serializer()
    serializer = StoreareaSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def storearea_search(request):
    """按名称寻找店铺区域"""
    name = request.GET.get('name', '').strip()
    result, error, status_code = search_service.search_storearea_by_name(name)
    if error:
        return Response(error, status=status_code)

    StoreareaSerializer = get_storearea_serializer()
    serializer = StoreareaSerializer(result, many=True)
    return Response(serializer.data)


@api_view(['GET'])
def storearea_list_by_type(request):
    """返回指定类型店铺区域列表"""
    type_param = request.GET.get('type', '').strip()
    result, extra, error = search_service.list_storearea_by_type(type_param)
    if error:
        return Response(error, status=extra)

    if type_param:
        StoreareaSerializer = get_storearea_serializer()
        serializer = StoreareaSerializer(result, many=True)
        response_data = {'type': extra['type'], 'storeareas': serializer.data}
    else:
        categorized = {}
        SimpleStoreareaSerializer = get_simple_storearea_serializer()
        for storearea in result:
            type_key = storearea.type or 0
            if type_key not in categorized:
                categorized[type_key] = []
            serializer = SimpleStoreareaSerializer(storearea)
            categorized[type_key].append(serializer.data)
        response_data = categorized

    return Response(response_data)


@api_view(['GET'])
def storearea_events(request, storearea_id):
    """返回指定店铺区域的所有活动ID列表"""
    result, error, status_code = search_service.get_storearea_events(storearea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def storearea_map_ids(request, storearea_id):
    """获取storearea_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_storearea_map_ids(storearea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def storearea_ids_by_map_and_type(request):
    """获取map_id为<> 且type为<>的所有storearea的id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_storearea_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_storearea_ids_by_map(request):
    """获取map_id为<>的地图对应的所有storearea_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_storearea_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 活动搜索功能 ==========

@api_view(['GET'])
def event_by_id(request, event_id):
    """按ID寻找活动"""
    result, error, status_code = search_service.get_event_by_id(event_id)
    if error:
        return Response(error, status=status_code)

    EventSerializer = get_event_serializer()
    serializer = EventSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def event_search(request):
    """按名称寻找活动"""
    name = request.GET.get('name', '').strip()
    result, error, status_code = search_service.search_event_by_name(name)
    if error:
        return Response(error, status=status_code)

    EventSerializer = get_event_serializer()
    serializer = EventSerializer(result, many=True)
    return Response(serializer.data)


@api_view(['GET'])
def event_list_by_type(request):
    """返回指定类型活动列表"""
    type_param = request.GET.get('type', '').strip()
    result, extra, error = search_service.list_event_by_type(type_param)
    if error:
        return Response(error, status=extra)

    if type_param:
        EventSerializer = get_event_serializer()
        serializer = EventSerializer(result, many=True)
        response_data = {'type': extra['type'], 'events': serializer.data}
    else:
        categorized = {}
        SimpleEventSerializer = get_simple_event_serializer()

        for event in result:
            # 获取该活动关联的所有Eventarea类型
            from django.apps import apps
            EventEventarea = apps.get_model('core', 'EventEventarea')
            eventarea_types = EventEventarea.objects.filter(
                event_id=event.id
            ).values_list('eventarea__type', flat=True).distinct()

            if not eventarea_types:
                type_key = 0
                if type_key not in categorized:
                    categorized[type_key] = []
                serializer = SimpleEventSerializer(event)
                categorized[type_key].append(serializer.data)
            else:
                for eventarea_type in eventarea_types:
                    type_key = eventarea_type or 0
                    if type_key not in categorized:
                        categorized[type_key] = []

                    serializer = SimpleEventSerializer(event)
                    categorized[type_key].append(serializer.data)

        response_data = categorized

    return Response(response_data)


@api_view(['GET'])
def event_areas(request, event_id):
    """返回参加该活动的区域ID列表"""
    result, error, status_code = search_service.get_event_areas(event_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 活动区域功能 ==========

@api_view(['GET'])
def eventarea_by_id(request, eventarea_id):
    """获取id为<>的活动区域的所有信息"""
    result, error, status_code = search_service.get_eventarea_by_id(eventarea_id)
    if error:
        return Response(error, status=status_code)

    EventareaSerializer = get_eventarea_serializer()
    serializer = EventareaSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def eventarea_ids_by_map_and_type(request):
    """获取map_id为<> 且 type为<>的所有eventarea的id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_eventarea_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def eventarea_map_ids(request, eventarea_id):
    """获取eventarea_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_eventarea_map_ids(eventarea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_eventarea_ids_by_map(request):
    """获取map_id为<>的地图对应的所有eventarea_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_eventarea_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 设施功能 ==========

@api_view(['GET'])
def facility_by_id(request, facility_id):
    """获取id为<>的设施的所有信息"""
    result, error, status_code = search_service.get_facility_by_id(facility_id)
    if error:
        return Response(error, status=status_code)

    FacilitySerializer = get_facility_serializer()
    serializer = FacilitySerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def facility_ids_by_map_and_type(request):
    """获取map_id为<> 且type为<>的所有设施id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_facility_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def facility_map_ids(request, facility_id):
    """获取facility_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_facility_map_ids(facility_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_facility_ids_by_map(request):
    """获取map_id为<>的地图对应的所有facility_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_facility_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 其他区域功能 ==========

@api_view(['GET'])
def otherarea_by_id(request, otherarea_id):
    """获取id为<>的其他区域的所有信息"""
    result, error, status_code = search_service.get_otherarea_by_id(otherarea_id)
    if error:
        return Response(error, status=status_code)

    OtherareaSerializer = get_otherarea_serializer()
    serializer = OtherareaSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def otherarea_ids_by_map_and_type(request):
    """获取map_id为<> 且type为<>的所有otherarea的id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_otherarea_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def otherarea_map_ids(request, otherarea_id):
    """获取otherarea_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_otherarea_map_ids(otherarea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_otherarea_ids_by_map(request):
    """获取map_id为<>的地图对应的所有otherarea_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_otherarea_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)



================================================================================
文件路径: python-backend\search\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\search\migrations\__init__.py
--------------------------------------------------------------------------------






================================================================================
文件路径: python-backend\manage.py
--------------------------------------------------------------------------------

#!/usr/bin/env python
"""
Command-line utility for administrative tasks.

# For more information about this file, visit
# https://docs.djangoproject.com/en/2.1/ref/django-admin/
"""

import os
import sys

import django

if __name__ == '__main__':
    os.environ.setdefault(
        'DJANGO_SETTINGS_MODULE',
        'python_backend.settings')
    django.setup()

    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)



================================================================================
文件路径: python-backend\requirements.txt
--------------------------------------------------------------------------------

Django==5.2.8
asgiref==3.10.0
pip==25.0.1
psycopg2-binary==2.9.11
sqlparse==0.5.3
tzdata==2025.2
virtualenv==12.1.1
djangorestframework==3.15.2
markdown==3.7
django-filter==24.3
django-cors-headers==4.0.0
ezdxf==1.1.0


================================================================================
文件路径: python-backend\client\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\client\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class ClientConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'client'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\client\models.py
--------------------------------------------------------------------------------

from django.db import models

# Create your models here.



================================================================================
文件路径: python-backend\client\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\client\views.py
--------------------------------------------------------------------------------

from django.shortcuts import render

# Create your views here.
from rest_framework import viewsets, status

from rest_framework.decorators import action

from rest_framework.response import Response


================================================================================
文件路径: python-backend\client\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\client\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\core\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\core\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig

class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core'


================================================================================
文件路径: python-backend\core\context.py
--------------------------------------------------------------------------------

from core.models import *
from django.db.models import Q

class BaseContext:
    """基础 CRUD Context"""
    def __init__(self, model):
        self.model = model

    def get_by_id(self, pk):
        try:
            return self.model.objects.get(pk=pk)
        except self.model.DoesNotExist:
            return None

    def list_all(self):
        return self.model.objects.all()

    def create(self, **kwargs):
        return self.model.objects.create(**kwargs)

    def update(self, instance, **kwargs):
        for key, value in kwargs.items():
            setattr(instance, key, value)
        instance.save()
        return instance

    def delete(self, instance):
        instance.delete()


================================================================================
文件路径: python-backend\core\models.py
--------------------------------------------------------------------------------

from django.contrib.gis.db import models

# Create your models here.
class Admin(models.Model):
    account = models.CharField(unique=True, max_length=64)
    password = models.CharField(max_length=256)
    name = models.CharField(max_length=64, blank=True, null=True)

    class Meta:
        db_table = 'admin'
        # managed = False


class Building(models.Model):
    name = models.CharField(unique=True, max_length=64)
    address = models.CharField(max_length=256)
    description = models.CharField(max_length=256, blank=True, null=True)

    class Meta:
        db_table = 'building'
        # managed = False


class Event(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    description = models.CharField(max_length=256, blank=True, null=True)
    event_name = models.CharField(max_length=64)
    start_date = models.DateTimeField()
    end_date = models.DateTimeField()
    image_url = models.CharField(max_length=256, blank=True, null=True)

    class Meta:
        db_table = 'event'
        # managed = False


class EventEventarea(models.Model):
    pk = models.CompositePrimaryKey('event_id', 'eventarea_id')
    event = models.ForeignKey(Event, on_delete=models.CASCADE)
    eventarea = models.ForeignKey('Eventarea', on_delete=models.CASCADE)

    class Meta:
        db_table = 'event_eventarea'
        # managed = False
        # unique_together = (('event', 'eventarea'),)


class EventStorearea(models.Model):
    pk = models.CompositePrimaryKey('event_id', 'storearea_id')
    event = models.ForeignKey(Event, on_delete=models.CASCADE)
    storearea = models.ForeignKey('Storearea', on_delete=models.CASCADE)

    class Meta:
        db_table = 'event_storearea'
        # unique_together = (('event', 'storearea'),)
        # managed = False


class Eventarea(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    shape = models.PolygonField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    organizer_name = models.CharField(max_length=64)
    organizer_phone = models.CharField(max_length=16)
    type = models.IntegerField(blank=True, null=True)

    class Meta:
        db_table = 'eventarea'
        # managed = False


class EventareaMap(models.Model):
    pk = models.CompositePrimaryKey('eventarea_id', 'map_id')
    eventarea = models.ForeignKey(Eventarea, on_delete=models.CASCADE)
    map = models.ForeignKey('Map', on_delete=models.CASCADE)

    class Meta:
        db_table = 'eventarea_map'
        # unique_together = (('eventarea', 'map'),)
        # managed = False


class Facility(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    location = models.PointField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    type = models.IntegerField()

    class Meta:
        db_table = 'facility'
        # managed = False


class FacilityMap(models.Model):
    pk = models.CompositePrimaryKey('facility_id', 'map_id')
    facility = models.ForeignKey(Facility, on_delete=models.CASCADE)
    map = models.ForeignKey('Map', on_delete=models.CASCADE)

    class Meta:
        db_table = 'facility_map'
        # unique_together = (('facility', 'map'),)
        # managed = False


class Map(models.Model):
    building = models.ForeignKey(Building, models.CASCADE)
    floor_number = models.IntegerField()
    detail = models.GeometryCollectionField(srid=2385)

    class Meta:
        db_table = 'map'
        unique_together = (('building', 'floor_number'),)
        # managed = False


class Otherarea(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    shape = models.PolygonField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    type = models.IntegerField()
    is_public = models.BooleanField(blank=True, null=True)

    class Meta:
        db_table = 'otherarea'
        # managed = False


class OtherareaMap(models.Model):
    pk = models.CompositePrimaryKey('otherarea_id', 'map_id')
    otherarea = models.ForeignKey(Otherarea, on_delete=models.CASCADE)
    map = models.ForeignKey(Map, on_delete=models.CASCADE)

    class Meta:
        db_table = 'otherarea_map'
        # managed = False
        # unique_together = (('otherarea', 'map'),)


class Storearea(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    shape = models.PolygonField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    store_name = models.CharField(max_length=64)
    owner_name = models.CharField(max_length=64)
    owner_phone = models.CharField(max_length=16)
    logo_url = models.CharField(max_length=256, blank=True, null=True)
    open_time = models.TimeField(blank=True, null=True)
    close_time = models.TimeField(blank=True, null=True)
    type = models.IntegerField(blank=True, null=True)
    api_url = models.CharField(max_length=256, blank=True, null=True)

    class Meta:
        db_table = 'storearea'
        # managed = False


class StoreareaMap(models.Model):
    pk = models.CompositePrimaryKey('storearea_id', 'map_id')
    storearea = models.ForeignKey(Storearea, on_delete=models.CASCADE)
    map = models.ForeignKey(Map, on_delete=models.CASCADE)

    class Meta:
        db_table = 'storearea_map'
        # unique_together = (('storearea', 'map'),)
        # managed = False


================================================================================
文件路径: python-backend\core\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\core\views.py
--------------------------------------------------------------------------------

from django.shortcuts import render

# Create your views here.



================================================================================
文件路径: python-backend\core\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\core\migrations\0001_initial.py
--------------------------------------------------------------------------------

# Generated by Django 5.2.8 on 2025-12-10 02:55

import django.contrib.gis.db.models.fields
import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Admin',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('account', models.CharField(max_length=64, unique=True)),
                ('password', models.CharField(max_length=256)),
                ('name', models.CharField(blank=True, max_length=64, null=True)),
            ],
            options={
                'db_table': 'admin',
            },
        ),
        migrations.CreateModel(
            name='Building',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=64, unique=True)),
                ('address', models.CharField(max_length=256)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
            ],
            options={
                'db_table': 'building',
            },
        ),
        migrations.CreateModel(
            name='Event',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('event_name', models.CharField(max_length=64)),
                ('start_date', models.DateTimeField()),
                ('end_date', models.DateTimeField()),
                ('image_url', models.CharField(blank=True, max_length=256, null=True)),
            ],
            options={
                'db_table': 'event',
            },
        ),
        migrations.CreateModel(
            name='Eventarea',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('shape', django.contrib.gis.db.models.fields.PolygonField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('organizer_name', models.CharField(max_length=64)),
                ('organizer_phone', models.CharField(max_length=16)),
                ('type', models.IntegerField(blank=True, null=True)),
            ],
            options={
                'db_table': 'eventarea',
            },
        ),
        migrations.CreateModel(
            name='Facility',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('location', django.contrib.gis.db.models.fields.PointField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('type', models.IntegerField()),
            ],
            options={
                'db_table': 'facility',
            },
        ),
        migrations.CreateModel(
            name='Otherarea',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('shape', django.contrib.gis.db.models.fields.PolygonField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('type', models.IntegerField()),
                ('is_public', models.BooleanField(blank=True, null=True)),
            ],
            options={
                'db_table': 'otherarea',
            },
        ),
        migrations.CreateModel(
            name='Storearea',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('shape', django.contrib.gis.db.models.fields.PolygonField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('store_name', models.CharField(max_length=64)),
                ('owner_name', models.CharField(max_length=64)),
                ('owner_phone', models.CharField(max_length=16)),
                ('logo_url', models.CharField(blank=True, max_length=256, null=True)),
                ('open_time', models.TimeField(blank=True, null=True)),
                ('close_time', models.TimeField(blank=True, null=True)),
                ('type', models.IntegerField(blank=True, null=True)),
                ('api_url', models.CharField(blank=True, max_length=256, null=True)),
            ],
            options={
                'db_table': 'storearea',
            },
        ),
        migrations.CreateModel(
            name='EventEventarea',
            fields=[
                ('pk', models.CompositePrimaryKey('event_id', 'eventarea_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('event', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.event')),
                ('eventarea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.eventarea')),
            ],
            options={
                'db_table': 'event_eventarea',
            },
        ),
        migrations.CreateModel(
            name='Map',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('floor_number', models.IntegerField()),
                ('detail', django.contrib.gis.db.models.fields.GeometryCollectionField(srid=2385)),
                ('building', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.building')),
            ],
            options={
                'db_table': 'map',
                'unique_together': {('building', 'floor_number')},
            },
        ),
        migrations.CreateModel(
            name='FacilityMap',
            fields=[
                ('pk', models.CompositePrimaryKey('facility_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('facility', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.facility')),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
            ],
            options={
                'db_table': 'facility_map',
            },
        ),
        migrations.CreateModel(
            name='EventareaMap',
            fields=[
                ('pk', models.CompositePrimaryKey('eventarea_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('eventarea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.eventarea')),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
            ],
            options={
                'db_table': 'eventarea_map',
            },
        ),
        migrations.CreateModel(
            name='OtherareaMap',
            fields=[
                ('pk', models.CompositePrimaryKey('otherarea_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
                ('otherarea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.otherarea')),
            ],
            options={
                'db_table': 'otherarea_map',
            },
        ),
        migrations.CreateModel(
            name='EventStorearea',
            fields=[
                ('pk', models.CompositePrimaryKey('event_id', 'storearea_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('event', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.event')),
                ('storearea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.storearea')),
            ],
            options={
                'db_table': 'event_storearea',
            },
        ),
        migrations.CreateModel(
            name='StoreareaMap',
            fields=[
                ('pk', models.CompositePrimaryKey('storearea_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
                ('storearea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.storearea')),
            ],
            options={
                'db_table': 'storearea_map',
            },
        ),
    ]



================================================================================
文件路径: python-backend\core\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\editor\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\editor\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class EditorConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'editor'



================================================================================
文件路径: python-backend\editor\context.py
--------------------------------------------------------------------------------

from django.contrib.gis.geos import GEOSGeometry
from core.models import (
    Event,
    Storearea,
    StoreareaMap,
    EventStorearea,
    EventEventarea,
    Eventarea,
    EventareaMap,
    Otherarea,
    OtherareaMap,
    Facility,
    FacilityMap
)


class StoreareaContext:
    """
    店铺区域（Storearea）的数据访问层
    负责与数据库交互，仅提供shape属性相关的操作
    """

    @staticmethod
    def get_all():
        """获取所有店铺区域"""
        return Storearea.objects.all()

    @staticmethod
    def get_by_id(storearea_id):
        """根据ID获取店铺区域"""
        return Storearea.objects.filter(id=storearea_id).first()

    @staticmethod
    def create(shape, map_id=None):
        """创建新的店铺区域，并可选绑定到指定地图"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            # 这样无论是WKT还是GeoJSON格式，都会使用正确的SRID
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        storearea = Storearea.objects.create(shape=shape_geom)
        # 绑定到地图
        if map_id is not None:
            StoreareaMap.objects.create(storearea=storearea, map_id=map_id)
        return storearea

    @staticmethod
    def update_shape(storearea_id, shape):
        """更新店铺区域的形状"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        Storearea.objects.filter(id=storearea_id).update(shape=shape_geom)
        return StoreareaContext.get_by_id(storearea_id)

    @staticmethod
    def delete(storearea_id):
        """删除店铺区域"""
        Storearea.objects.filter(id=storearea_id).delete()

    @staticmethod
    def get_events_by_storearea(storearea_id):
        """获取店铺关联的所有活动ID"""
        event_relations = EventStorearea.objects.filter(storearea_id=storearea_id)
        return [relation.event_id for relation in event_relations]


class EventContext:
    """
    活动（Event）的数据访问层
    负责与数据库交互，仅提供shape属性相关的操作
    """

    @staticmethod
    def get_all():
        """获取所有活动"""
        return Event.objects.all()

    @staticmethod
    def get_by_id(event_id):
        """根据ID获取活动"""
        return Event.objects.filter(id=event_id).first()



    @staticmethod
    def get_storeareas_by_event(event_id):
        """获取活动关联的所有店铺区域ID"""
        storearea_relations = EventStorearea.objects.filter(event_id=event_id)
        return [relation.storearea_id for relation in storearea_relations]

    @staticmethod
    def get_eventareas_by_event(event_id):
        """获取活动关联的所有活动区域ID"""
        eventarea_relations = EventEventarea.objects.filter(event_id=event_id)
        return [relation.eventarea_id for relation in eventarea_relations]

    @staticmethod
    def add_storearea_relation(event_id, storearea_id):
        """添加活动与店铺区域的关联关系"""
        return EventStorearea.objects.get_or_create(event_id=event_id, storearea_id=storearea_id)

    @staticmethod
    def remove_storearea_relation(event_id, storearea_id):
        """移除活动与店铺区域的关联关系"""
        return EventStorearea.objects.filter(event_id=event_id, storearea_id=storearea_id).delete()

    @staticmethod
    def add_eventarea_relation(event_id, eventarea_id):
        """添加活动与活动区域的关联关系"""
        return EventEventarea.objects.get_or_create(event_id=event_id, eventarea_id=eventarea_id)

    @staticmethod
    def remove_eventarea_relation(event_id, eventarea_id):
        """移除活动与活动区域的关联关系"""
        return EventEventarea.objects.filter(event_id=event_id, eventarea_id=eventarea_id).delete()


class EventareaContext:
    """
    活动区域（Eventarea）的数据访问层
    负责与数据库交互，提供基本的CRUD操作
    """

    @staticmethod
    def get_all():
        """获取所有活动区域"""
        return Eventarea.objects.all()

    @staticmethod
    def get_by_id(eventarea_id):
        """根据ID获取活动区域"""
        return Eventarea.objects.filter(id=eventarea_id).first()

    @staticmethod
    def create(shape, map_id=None):
        """创建新的活动区域，并可选绑定到指定地图"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        eventarea = Eventarea.objects.create(shape=shape_geom)
        if map_id is not None:
            EventareaMap.objects.create(eventarea=eventarea, map_id=map_id)
        return eventarea

    @staticmethod
    def update_shape(eventarea_id, shape):
        """更新活动区域的形状"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        Eventarea.objects.filter(id=eventarea_id).update(shape=shape_geom)
        return EventareaContext.get_by_id(eventarea_id)

    @staticmethod
    def delete(eventarea_id):
        """删除活动区域"""
        Eventarea.objects.filter(id=eventarea_id).delete()


class OtherareaContext:
    """
    其他区域（Otherarea）的数据访问层
    负责与数据库交互，提供基本的CRUD操作
    """

    @staticmethod
    def get_all():
        """获取所有其他区域"""
        return Otherarea.objects.all()

    @staticmethod
    def get_by_id(otherarea_id):
        """根据ID获取其他区域"""
        return Otherarea.objects.filter(id=otherarea_id).first()

    @staticmethod
    def create(shape, map_id=None, type_val=None):
        """创建新的其他区域，并可选绑定到指定地图"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        otherarea = Otherarea.objects.create(
            shape=shape_geom,
            type=type_val if type_val is not None else 0  # 默认 0，避免 NOT NULL 约束报错
        )
        if map_id is not None:
            OtherareaMap.objects.create(otherarea=otherarea, map_id=map_id)
        return otherarea

    @staticmethod
    def update_shape(otherarea_id, shape):
        """更新其他区域的形状"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        Otherarea.objects.filter(id=otherarea_id).update(shape=shape_geom)
        return OtherareaContext.get_by_id(otherarea_id)

    @staticmethod
    def delete(otherarea_id):
        """删除其他区域"""
        Otherarea.objects.filter(id=otherarea_id).delete()


class FacilityContext:
    """
    设施（Facility）的数据访问层
    """

    @staticmethod
    def get_all():
        return Facility.objects.all()

    @staticmethod
    def get_by_id(facility_id):
        return Facility.objects.filter(id=facility_id).first()

    @staticmethod
    def create(location, map_id=None, type_val=None):
        try:
            loc_geom = GEOSGeometry(location)
            if loc_geom.srid != 2385:
                loc_geom.srid = 2385
        except Exception as e:
            raise ValueError(f"Invalid spatial data: {str(e)}")

        facility = Facility.objects.create(
            location=loc_geom,
            type=type_val if type_val is not None else 0
        )
        if map_id is not None:
            FacilityMap.objects.create(facility=facility, map_id=map_id)
        return facility

    @staticmethod
    def update_location(facility_id, location):
        """更新设施位置"""
        try:
            loc_geom = GEOSGeometry(location)
            if loc_geom.srid != 2385:
                loc_geom.srid = 2385
        except Exception as e:
            raise ValueError(f"Invalid spatial data: {str(e)}")

        Facility.objects.filter(id=facility_id).update(location=loc_geom)
        return FacilityContext.get_by_id(facility_id)

    @staticmethod
    def delete(facility_id):
        Facility.objects.filter(id=facility_id).delete()


================================================================================
文件路径: python-backend\editor\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from django.apps import apps


def get_storearea_serializer():
    """获取 Storearea 序列化器"""
    Storearea = apps.get_model('core', 'Storearea')

    class StoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            fields = '__all__'
            # 由于使用了 managed=False，需要明确指定字段
            # 但 ModelSerializer 会自动从模型获取字段

    return StoreareaSerializer


def get_event_serializer():
    """获取 Event 序列化器"""
    Event = apps.get_model('core', 'Event')

    class EventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = '__all__'

    return EventSerializer


def get_eventarea_serializer():
    """获取活动区域序列化器"""
    Eventarea = apps.get_model('core', 'Eventarea')
    
    class EventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            fields = '__all__'
    
    return EventareaSerializer


def get_otherarea_serializer():
    """获取其他区域序列化器"""
    Otherarea = apps.get_model('core', 'Otherarea')
    
    class OtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            fields = '__all__'
    
    return OtherareaSerializer


def get_facility_serializer():
    """获取设施序列化器"""
    Facility = apps.get_model('core', 'Facility')

    class FacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            fields = '__all__'

    return FacilitySerializer

def get_map_serializer():
    Map = apps.get_model('core', 'Map')
    class MapSerializer(serializers.ModelSerializer):
        class Meta:
            model = Map
            fields = '__all__'
    return MapSerializer


================================================================================
文件路径: python-backend\editor\services.py
--------------------------------------------------------------------------------

from .context import StoreareaContext, EventContext, EventareaContext, OtherareaContext,FacilityContext
from map.context import MapContext
from django.contrib.gis.geos import GeometryCollection, Polygon, Point
from django.db import transaction
import ezdxf
import io


class StoreareaService:
    """
    店铺区域（Storearea）的业务层
    负责处理业务逻辑，调用数据访问层方法，仅处理shape属性相关操作
    """

    @staticmethod
    def get_all_storeareas():
        """获取所有店铺区域"""
        return StoreareaContext.get_all()

    @staticmethod
    def get_storearea_by_id(storearea_id):
        """根据ID获取店铺区域"""
        return StoreareaContext.get_by_id(storearea_id)

    @staticmethod
    def create_storearea(shape, map_id=None):
        """创建新的店铺区域，并可选绑定到指定地图"""
        return StoreareaContext.create(shape, map_id)

    @staticmethod
    def update_shape(storearea_id, shape):
        """更新店铺区域的形状"""
        # 可以在这里添加业务逻辑验证
        return StoreareaContext.update_shape(storearea_id, shape)

    @staticmethod
    def delete_storearea(storearea_id):
        """删除店铺区域"""
        # 可以在这里添加业务逻辑验证
        return StoreareaContext.delete(storearea_id)

    @staticmethod
    def get_events_for_storearea(storearea_id):
        """获取店铺关联的所有活动ID"""
        return StoreareaContext.get_events_by_storearea(storearea_id)


class EventService:
    """
    活动（Event）的业务层
    负责处理业务逻辑，调用数据访问层方法，仅处理shape属性相关操作
    """

    @staticmethod
    def get_all_events():
        """获取所有活动"""
        return EventContext.get_all()

    @staticmethod
    def get_event_by_id(event_id):
        """根据ID获取活动"""
        return EventContext.get_by_id(event_id)



    @staticmethod
    def get_areas_for_event(event_id):
        """获取活动关联的所有区域ID（包括店铺区域和活动区域）"""
        storearea_ids = EventContext.get_storeareas_by_event(event_id)
        eventarea_ids = EventContext.get_eventareas_by_event(event_id)
        return {
            'storearea_ids': storearea_ids,
            'eventarea_ids': eventarea_ids,
            'all_area_ids': storearea_ids + eventarea_ids
        }

    @staticmethod
    def add_storearea_to_event(event_id, storearea_id):
        """添加活动与店铺区域的关联关系"""
        # 可以在这里添加业务逻辑验证（如检查活动和店铺是否存在等）
        return EventContext.add_storearea_relation(event_id, storearea_id)

    @staticmethod
    def remove_storearea_from_event(event_id, storearea_id):
        """移除活动与店铺区域的关联关系"""
        # 可以在这里添加业务逻辑验证
        return EventContext.remove_storearea_relation(event_id, storearea_id)

    @staticmethod
    def add_eventarea_to_event(event_id, eventarea_id):
        """添加活动与活动区域的关联关系"""
        # 可以在这里添加业务逻辑验证（如检查活动和活动区域是否存在等）
        return EventContext.add_eventarea_relation(event_id, eventarea_id)

    @staticmethod
    def remove_eventarea_from_event(event_id, eventarea_id):
        """移除活动与活动区域的关联关系"""
        # 可以在这里添加业务逻辑验证
        return EventContext.remove_eventarea_relation(event_id, eventarea_id)


class EventareaService:
    """
    活动区域（Eventarea）的业务层
    负责处理业务逻辑，调用数据访问层方法
    注意：在editor模块中只处理shape属性的更新
    """

    @staticmethod
    def get_all_eventareas():
        """获取所有活动区域"""
        return EventareaContext.get_all()

    @staticmethod
    def get_eventarea_by_id(eventarea_id):
        """根据ID获取活动区域"""
        return EventareaContext.get_by_id(eventarea_id)

    @staticmethod
    def create_eventarea(shape, map_id=None):
        """创建新的活动区域，并可选绑定到指定地图"""
        return EventareaContext.create(shape, map_id)

    @staticmethod
    def update_eventarea_shape(eventarea_id, shape):
        """更新活动区域的形状"""
        # 可以在这里添加业务逻辑验证（如形状有效性检查等）
        return EventareaContext.update_shape(eventarea_id, shape)

    @staticmethod
    def delete_eventarea(eventarea_id):
        """删除活动区域"""
        # 可以在这里添加业务逻辑验证
        return EventareaContext.delete(eventarea_id)


class OtherareaService:
    """
    其他区域（Otherarea）的业务层
    负责处理业务逻辑，调用数据访问层方法
    注意：在editor模块中只处理shape属性的更新
    """

    @staticmethod
    def get_all_otherareas():
        """获取所有其他区域"""
        return OtherareaContext.get_all()

    @staticmethod
    def get_otherarea_by_id(otherarea_id):
        """根据ID获取其他区域"""
        return OtherareaContext.get_by_id(otherarea_id)

    @staticmethod
    def create_otherarea(shape, map_id=None, type_val=None):
        """创建新的其他区域，并可选绑定到指定地图"""
        return OtherareaContext.create(shape, map_id, type_val)

    @staticmethod
    def update_otherarea_shape(otherarea_id, shape):
        """更新其他区域的形状"""
        # 可以在这里添加业务逻辑验证（如形状有效性检查等）
        return OtherareaContext.update_shape(otherarea_id, shape)

    @staticmethod
    def delete_otherarea(otherarea_id):
        """删除其他区域"""
        # 可以在这里添加业务逻辑验证
        return OtherareaContext.delete(otherarea_id)

class FacilityService:
    """
    设施（Facility）的业务层
    """
    @staticmethod
    def get_all_facilities():
        return FacilityContext.get_all()

    @staticmethod
    def get_facility_by_id(facility_id):
        return FacilityContext.get_by_id(facility_id)

    @staticmethod
    def create_facility(location, map_id=None, type_val=None):
        return FacilityContext.create(location, map_id, type_val)

    @staticmethod
    def update_facility_location(facility_id, location):
        return FacilityContext.update_location(facility_id, location)

    @staticmethod
    def delete_facility(facility_id):
        return FacilityContext.delete(facility_id)


class MapEditorService:
    """
    地图编辑服务：处理地图及关联要素的创建、导入
    """

    # 定义 CAD 图层名称到业务类型的映射
    LAYER_MAPPING = {
        'FLOOR_OUTLINE': 'floor',  # 底图外框
        'VOIDS': 'hole',  # 底图镂空
        'AREA_STORE': 'storearea',  # 店铺区域
        'AREA_EVENT': 'eventarea',  # 活动区域
        'AREA_OTHER': 'otherarea',  # 其他区域
        'FACILITIES': 'facility'  # 设施
    }

    @staticmethod
    def create_map(building_id, floor_number, file=None):
        map_ctx = MapContext()

        # 1. 业务校验
        if map_ctx.check_exists(building_id, floor_number):
            raise ValueError("该建筑的此楼层已存在地图")

        try:
            with transaction.atomic():
                # 2. 解析 DXF 数据
                if file:
                    dxf_data = MapEditorService._parse_dxf_layers(file)
                else:
                    # 手动模式默认数据
                    dxf_data = {
                        'floor': Polygon(((0, 0), (0, 100), (100, 100), (100, 0), (0, 0)), srid=2385),
                        'holes': [],
                        'storearea': [],
                        'eventarea': [],
                        'otherarea': [],
                        'facility': []
                    }

                # 3. 组装并创建 Map (底图)
                # 将外框和镂空组合成 GeometryCollection
                if not dxf_data['floor']:
                    raise ValueError("DXF 中未找到 FLOOR_OUTLINE 图层或有效的闭合外轮廓")

                # 组合 list: [外框, 洞1, 洞2...]
                map_geometry_list = [dxf_data['floor']] + dxf_data['holes']
                map_geometry = GeometryCollection(map_geometry_list, srid=2385)

                # 调用 Context 创建地图
                new_map = map_ctx.create_map_record(building_id, floor_number, map_geometry)

                # 4. 创建关联实体 (调用 editor.context 中的各 Context)
                # 注意：editor.context.create 方法通常只接收 shape/location 和 map_id

                # A. 创建店铺
                for shape in dxf_data['storearea']:
                    # 这里可以根据需求生成默认名称，例如 "导入的店铺"
                    StoreareaContext.create(shape=shape, map_id=new_map.id)

                # B. 创建活动区
                for shape in dxf_data['eventarea']:
                    EventareaContext.create(shape=shape, map_id=new_map.id)

                # C. 创建其他区域
                for shape in dxf_data['otherarea']:
                    # type_val 默认为 0
                    OtherareaContext.create(shape=shape, map_id=new_map.id, type_val=0)

                # D. 创建设施 (点)
                for location in dxf_data['facility']:
                    # FacilityContext.create 接收 Point 对象
                    FacilityContext.create(location=location, map_id=new_map.id, type_val=0)

                return new_map

        except Exception as e:
            # 捕获异常并回滚事务（由 transaction.atomic 自动处理回滚，这里重新抛出以便 View 层捕获）
            raise ValueError(f"创建地图失败: {str(e)}")

    @staticmethod
    def _parse_dxf_layers(uploaded_file):
        """
        解析 DXF 文件，按图层分类提取几何数据
        """
        try:
            # === 修复逻辑开始 ===
            # 1. 如果传入的是纯字节(bytes)，封装成 BytesIO 流
            if isinstance(uploaded_file, bytes):
                uploaded_file = io.BytesIO(uploaded_file)

            # 2. 如果是流对象，确保指针在开头
            if hasattr(uploaded_file, 'seek'):
                uploaded_file.seek(0)

            # 3. 读取 DXF (此时 uploaded_file 必定是流对象，拥有 readline 方法)
            doc = ezdxf.read(uploaded_file)
            # === 修复逻辑结束 ===

            msp = doc.modelspace()

            result = {
                'floor': None,
                'holes': [],
                'storearea': [],
                'eventarea': [],
                'otherarea': [],
                'facility': []
            }

            # 遍历所有实体
            for entity in msp:
                # 增加容错：有些实体可能没有 layer 属性
                if not hasattr(entity.dxf, 'layer'):
                    continue

                layer_name = entity.dxf.layer.upper()

                if layer_name not in MapEditorService.LAYER_MAPPING:
                    continue

                target_type = MapEditorService.LAYER_MAPPING[layer_name]

                # --- 处理多边形 (区域/楼层) ---
                if entity.dxftype() == 'LWPOLYLINE':
                    if not entity.closed:
                        continue  # 忽略未闭合的线

                    points = []
                    # 坐标转换：毫米 -> 米
                    for p in entity.get_points():
                        points.append((p[0] / 1000.0, p[1] / 1000.0))

                    # 确保首尾闭合
                    if points[0] != points[-1]:
                        points.append(points[0])

                    if len(points) >= 4:
                        poly = Polygon(points, srid=2385)

                        if target_type == 'floor':
                            # 假设图纸里只有一个最大的框是地板，如果有多个，暂取第一个或覆盖
                            if result['floor'] is None:
                                result['floor'] = poly
                            else:
                                # 如果有多个 FLOOR_OUTLINE，简单的逻辑是看谁面积大
                                if poly.area > result['floor'].area:
                                    result['floor'] = poly
                        elif target_type == 'hole':
                            result['holes'].append(poly)
                        elif target_type in ['storearea', 'eventarea', 'otherarea']:
                            result[target_type].append(poly)

                # --- 处理点/圆 (设施) ---
                elif entity.dxftype() in ['CIRCLE', 'POINT']:
                    if target_type == 'facility':
                        x, y = 0, 0
                        if entity.dxftype() == 'CIRCLE':
                            # 圆取圆心
                            center = entity.dxf.center
                            x, y = center.x / 1000.0, center.y / 1000.0
                        else:
                            # 点取坐标
                            loc = entity.dxf.location
                            x, y = loc.x / 1000.0, loc.y / 1000.0

                        point = Point(x, y, srid=2385)
                        result['facility'].append(point)

            return result

        except Exception as e:
            # 增加一些调试信息
            import traceback
            traceback.print_exc()
            raise ValueError(f"DXF 解析内部错误: {str(e)}")


================================================================================
文件路径: python-backend\editor\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\editor\urls.py
--------------------------------------------------------------------------------

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

# 创建路由器并注册视图集
router = DefaultRouter()
router.register(r'storearea', views.StoreareaViewSet, basename='editor_storearea')
router.register(r'event', views.EventViewSet, basename='editor_event')
router.register(r'eventarea', views.EventareaViewSet, basename='editor_eventarea')
router.register(r'otherarea', views.OtherareaViewSet, basename='editor_otherarea')
router.register(r'facility', views.FacilityViewSet, basename='editor_facility')
router.register(r'map', views.MapEditorViewSet, basename='editor_map')

urlpatterns = [
    # 包含路由器生成的所有URL
    path('', include(router.urls)),
]




================================================================================
文件路径: python-backend\editor\views.py
--------------------------------------------------------------------------------

import base64
import io
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from django.shortcuts import get_object_or_404
from rest_framework.parsers import JSONParser
from .serializers import get_storearea_serializer, get_event_serializer, get_eventarea_serializer, get_otherarea_serializer, get_facility_serializer, get_map_serializer
from .services import StoreareaService, EventService, EventareaService, OtherareaService, FacilityService, MapEditorService


class StoreareaViewSet(viewsets.ModelViewSet):
    """
    店铺区域（Storearea）的视图集
    
    注意：在editor模块中只处理shape属性的更新，其他属性在management中实现
    
    支持的操作：
    - GET /api/editor/storearea/ - 获取所有店铺区域列表
    - GET /api/editor/storearea/{id}/ - 获取指定店铺区域详情
    - POST /api/editor/storearea/ - 创建店铺区域（仅支持shape属性）
    - PATCH /api/editor/storearea/{id}/ - 部分更新店铺区域（仅支持shape属性）
    - DELETE /api/editor/storearea/{id}/ - 删除店铺区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_storearea_serializer()
    
    def get_queryset(self):
        """获取所有店铺区域"""
        return StoreareaService.get_all_storeareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有店铺区域列表"""
        storeareas = StoreareaService.get_all_storeareas()
        serializer = self.get_serializer(storeareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定店铺区域详情"""
        storearea = get_object_or_404(StoreareaService.get_all_storeareas(), pk=pk)
        serializer = self.get_serializer(storearea)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新店铺区域"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """部分更新店铺区域（仅支持shape属性）"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be updated in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        storearea = get_object_or_404(StoreareaService.get_all_storeareas(), pk=pk)
        shape = request.data.get('shape')
        
        updated_storearea = StoreareaService.update_shape(pk, shape)
        serializer = self.get_serializer(updated_storearea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建店铺区域（仅支持shape属性），并绑定到指定地图"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be provided when creating storearea in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        shape = request.data.get('shape')
        map_id = request.data.get('map_id')
        new_storearea = StoreareaService.create_storearea(shape, map_id)
        serializer = self.get_serializer(new_storearea)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    def destroy(self, request, pk=None):
        """删除店铺区域"""
        StoreareaService.delete_storearea(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)
    
    @action(detail=True, methods=['get'])
    def events(self, request, pk=None):
        """获取店铺关联的所有活动ID"""
        event_ids = StoreareaService.get_events_for_storearea(pk)
        return Response({
            'storearea_id': pk,
            'event_ids': event_ids
        })


class EventViewSet(viewsets.ModelViewSet):
    """
    活动（Event）的视图集
    
    注意：Event模型没有shape字段，因此不支持shape属性更新

    支持的操作：
    - GET /api/editor/event/ - 获取所有活动列表
    - GET /api/editor/event/{id}/ - 获取指定活动详情
    - GET /api/editor/event/{id}/areas/ - 获取活动关联的所有区域ID
    - POST/DELETE /api/editor/event/{id}/storeareas/ - 管理活动与店铺区域的关联关系
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_event_serializer()
    
    def get_queryset(self):
        """获取所有活动"""
        return EventService.get_all_events()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动列表"""
        events = EventService.get_all_events()
        serializer = self.get_serializer(events, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动详情"""
        event = get_object_or_404(EventService.get_all_events(), pk=pk)
        serializer = self.get_serializer(event)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新活动"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """不允许在editor模块中更新活动"""
        return Response(
            {'error': 'Update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def create(self, request, *args, **kwargs):
        """不允许在editor模块中创建活动"""
        return Response(
            {'error': 'Create not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def destroy(self, request, pk=None):
        """不允许在editor模块中删除活动"""
        return Response(
            {'error': 'Delete not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    @action(detail=True, methods=['get'])
    def areas(self, request, pk=None):
        """获取活动关联的所有区域ID（包括店铺区域和活动区域）"""
        areas = EventService.get_areas_for_event(pk)
        return Response({
            'event_id': pk,
            'storearea_ids': areas['storearea_ids'],
            'eventarea_ids': areas['eventarea_ids'],
            'all_area_ids': areas['all_area_ids']
        })
    
    @action(detail=True, methods=['post', 'delete'])
    def storeareas(self, request, pk=None):
        """管理活动与店铺区域的关联关系"""
        if request.method == 'POST':
            # 添加关联
            storearea_id = request.data.get('storearea_id')
            if not storearea_id:
                return Response(
                    {'error': 'storearea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            relation, created = EventService.add_storearea_to_event(pk, storearea_id)
            
            if created:
                return Response(
                    {'message': 'Relation created successfully'},
                    status=status.HTTP_201_CREATED
                )
            else:
                return Response(
                    {'message': 'Relation already exists'},
                    status=status.HTTP_200_OK
                )
        
        elif request.method == 'DELETE':
            # 删除关联
            storearea_id = request.data.get('storearea_id')
            if not storearea_id:
                return Response(
                    {'error': 'storearea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            deleted_count, _ = EventService.remove_storearea_from_event(pk, storearea_id)
            
            if deleted_count > 0:
                return Response(
                    {'message': 'Relation deleted successfully'},
                    status=status.HTTP_204_NO_CONTENT
                )
            else:
                return Response(
                    {'error': 'Relation not found'},
                    status=status.HTTP_404_NOT_FOUND
                )


class EventareaViewSet(viewsets.ModelViewSet):
    """
    活动区域（Eventarea）的视图集
    
    注意：在editor模块中只处理shape属性的更新，其他属性在management中实现
    
    支持的操作：
    - GET /api/editor/eventarea/ - 获取所有活动区域列表
    - GET /api/editor/eventarea/{id}/ - 获取指定活动区域详情
    - POST /api/editor/eventarea/ - 创建活动区域（仅支持shape属性）
    - PATCH /api/editor/eventarea/{id}/ - 部分更新活动区域（仅支持shape属性）
    - DELETE /api/editor/eventarea/{id}/ - 删除活动区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_eventarea_serializer()
    
    def get_queryset(self):
        """获取所有活动区域"""
        return EventareaService.get_all_eventareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动区域列表"""
        eventareas = EventareaService.get_all_eventareas()
        serializer = self.get_serializer(eventareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动区域详情"""
        eventarea = get_object_or_404(EventareaService.get_all_eventareas(), pk=pk)
        serializer = self.get_serializer(eventarea)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新活动区域"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """部分更新活动区域（仅支持shape属性）"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be updated in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        eventarea = get_object_or_404(EventareaService.get_all_eventareas(), pk=pk)
        shape = request.data.get('shape')
        
        updated_eventarea = EventareaService.update_eventarea_shape(pk, shape)
        serializer = self.get_serializer(updated_eventarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建活动区域（仅支持shape属性），并绑定到指定地图"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be provided when creating eventarea in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        shape = request.data.get('shape')
        map_id = request.data.get('map_id')
        new_eventarea = EventareaService.create_eventarea(shape, map_id)
        serializer = self.get_serializer(new_eventarea)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    def destroy(self, request, pk=None):
        """删除活动区域"""
        EventareaService.delete_eventarea(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)


class OtherareaViewSet(viewsets.ModelViewSet):
    """
    其他区域（Otherarea）的视图集
    
    注意：在editor模块中只处理shape属性的更新，其他属性在management中实现
    
    支持的操作：
    - GET /api/editor/otherarea/ - 获取所有其他区域列表
    - GET /api/editor/otherarea/{id}/ - 获取指定其他区域详情
    - POST /api/editor/otherarea/ - 创建其他区域（仅支持shape属性）
    - PATCH /api/editor/otherarea/{id}/ - 部分更新其他区域（仅支持shape属性）
    - DELETE /api/editor/otherarea/{id}/ - 删除其他区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_otherarea_serializer()
    
    def get_queryset(self):
        """获取所有其他区域"""
        return OtherareaService.get_all_otherareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有其他区域列表"""
        otherareas = OtherareaService.get_all_otherareas()
        serializer = self.get_serializer(otherareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定其他区域详情"""
        otherarea = get_object_or_404(OtherareaService.get_all_otherareas(), pk=pk)
        serializer = self.get_serializer(otherarea)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新其他区域"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """部分更新其他区域（仅支持shape属性）"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be updated in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        otherarea = get_object_or_404(OtherareaService.get_all_otherareas(), pk=pk)
        shape = request.data.get('shape')
        
        updated_otherarea = OtherareaService.update_otherarea_shape(pk, shape)
        serializer = self.get_serializer(updated_otherarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建其他区域（仅支持shape属性），并绑定到指定地图"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be provided when creating otherarea in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        shape = request.data.get('shape')
        map_id = request.data.get('map_id')
        type_val = request.data.get('type')
        new_otherarea = OtherareaService.create_otherarea(shape, map_id, type_val)
        serializer = self.get_serializer(new_otherarea)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    def destroy(self, request, pk=None):
        """删除其他区域"""
        OtherareaService.delete_otherarea(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)
    
    @action(detail=True, methods=['post', 'delete'])
    def eventareas(self, request, pk=None):
        """管理活动与活动区域的关联关系"""
        if request.method == 'POST':
            # 添加关联
            eventarea_id = request.data.get('eventarea_id')
            if not eventarea_id:
                return Response(
                    {'error': 'eventarea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            relation, created = EventService.add_eventarea_to_event(pk, eventarea_id)
            
            if created:
                return Response(
                    {'message': 'Relation created successfully'},
                    status=status.HTTP_201_CREATED
                )
            else:
                return Response(
                    {'message': 'Relation already exists'},
                    status=status.HTTP_200_OK
                )
        
        elif request.method == 'DELETE':
            # 删除关联
            eventarea_id = request.data.get('eventarea_id')
            if not eventarea_id:
                return Response(
                    {'error': 'eventarea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            deleted_count, _ = EventService.remove_eventarea_from_event(pk, eventarea_id)
            
            if deleted_count > 0:
                return Response(
                    {'message': 'Relation deleted successfully'},
                    status=status.HTTP_204_NO_CONTENT
                )
            else:
                return Response(
                    {'error': 'Relation not found'},
                    status=status.HTTP_404_NOT_FOUND
                )


class FacilityViewSet(viewsets.ModelViewSet):
    """
    设施（Facility）的视图集
    支持操作：更新位置 (PATCH)
    """

    def get_serializer_class(self):
        return get_facility_serializer()

    def get_queryset(self):
        return FacilityService.get_all_facilities()

    def list(self, request, *args, **kwargs):
        facilities = FacilityService.get_all_facilities()
        serializer = self.get_serializer(facilities, many=True)
        return Response(serializer.data)

    def retrieve(self, request, pk=None):
        facility = get_object_or_404(FacilityService.get_all_facilities(), pk=pk)
        serializer = self.get_serializer(facility)
        return Response(serializer.data)

    def partial_update(self, request, pk=None):
        """部分更新设施（仅支持 location 属性）"""
        if 'location' not in request.data:
            return Response(
                {'error': 'Only location attribute can be updated in editor module'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # 检查 ID 是否存在
        get_object_or_404(FacilityService.get_all_facilities(), pk=pk)

        location = request.data.get('location')
        updated_facility = FacilityService.update_facility_location(pk, location)
        serializer = self.get_serializer(updated_facility)
        return Response(serializer.data)

    def create(self, request, *args, **kwargs):
        if 'location' not in request.data:
            return Response(
                {'error': 'Location is required'}, status=status.HTTP_400_BAD_REQUEST
            )

        location = request.data.get('location')
        map_id = request.data.get('map_id')
        type_val = request.data.get('type')

        new_facility = FacilityService.create_facility(location, map_id, type_val)
        serializer = self.get_serializer(new_facility)
        return Response(serializer.data, status=status.HTTP_201_CREATED)

    def destroy(self, request, pk=None):
        FacilityService.delete_facility(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)


class MapEditorViewSet(viewsets.ViewSet):
    """
    地图创建与编辑视图
    POST /api/editor/map/
    """
    # 既然前端改用 JSON，这里只需要 JSONParser
    parser_classes = (JSONParser,)

    def create(self, request):
        building_id = request.data.get('building_id')
        floor_number = request.data.get('floor_number')

        # 获取 Base64 字符串 (格式通常为 "data:application/dxf;base64,......")
        file_data_url = request.data.get('file_data')

        if not building_id or not floor_number:
            return Response({"error": "缺少建筑ID或楼层号"}, status=status.HTTP_400_BAD_REQUEST)

        dxf_file_stream = None
        if file_data_url:
            try:
                # 1. 分离头部 (如果有) 和 内容
                if ',' in file_data_url:
                    header, data_str = file_data_url.split(',', 1)
                else:
                    data_str = file_data_url

                # 2. Base64 解码
                file_bytes = base64.b64decode(data_str)

                # 3. 转为二进制流 (BytesIO 实现了 read() 方法，ezdxf 可直接读取)
                dxf_file_stream = io.BytesIO(file_bytes)
                # 为了让 ezdxf 读取文本模式更安全，有时需要 TextIOWrapper，
                # 但 ezdxf.read() 通常也能处理 bytes。我们先传 bytes stream。

            except Exception as e:
                return Response({"error": f"文件解析失败: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            # 调用 Service (Service 逻辑无需修改，它只关心传入的对象有 read() 方法)
            new_map = MapEditorService.create_map(building_id, floor_number, dxf_file_stream)

            Serializer = get_map_serializer()
            return Response(Serializer(new_map).data, status=status.HTTP_201_CREATED)

        except ValueError as e:
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)


================================================================================
文件路径: python-backend\editor\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\editor\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\guide\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\guide\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class GuideConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'guide'



================================================================================
文件路径: python-backend\guide\context.py
--------------------------------------------------------------------------------

from django.contrib.gis.geos import Polygon, Point
from typing import Tuple, List, Optional

# 导入所有涉及的模型
from core.models import Map, Storearea, Eventarea, Otherarea, Facility, StoreareaMap, EventareaMap, OtherareaMap, \
    FacilityMap


class GuideContext:  # 不继承 BaseContext
    """
    导航模块数据上下文
    职责：只负责从数据库提取几何数据，不负责路径计算逻辑
    """

    @staticmethod
    def get_map_geometry_data(map_id: int) -> Tuple[Optional[Polygon], List[Polygon], List[Polygon]]:
        """
        一次性获取地图的边界、原始镂空以及所有障碍物

        :param map_id: 地图 ID
        :return: (outer_shell, holes, obstacles)
        """
        # 1. 获取地图底图对象
        try:
            map_obj = Map.objects.get(pk=map_id)
        except Map.DoesNotExist:
            return None, [], []

        # 2. 解析地图底图 (GeometryCollection)
        # detail[0] 通常是地板外轮廓 (Polygon)
        # detail[1:] 是地板内部的镂空 (Polygon list)
        if not map_obj.detail or len(map_obj.detail) == 0:
            return None, [], []

        outer_shell = map_obj.detail[0]
        # 确保它是 Polygon，防止脏数据
        if not isinstance(outer_shell, Polygon):
            return None, [], []

        holes = []
        # 可能有镂空，也可能没有镂空
        if len(map_obj.detail) > 1:
            holes = list(map_obj.detail[1:])

        # 3. 获取所有业务层面的障碍物
        # 将所有障碍物统一合并到一个列表中返回
        obstacles = []

        # --- A. 获取商铺区域 (Polygon) ---
        stores = Storearea.objects.filter(
            storeareamap__map_id=map_id,
            shape__isnull=False
        ).values_list('shape', flat=True)
        obstacles.extend(stores)

        # --- B. 获取活动区域 (Polygon) ---
        events = Eventarea.objects.filter(
            eventareamap__map_id=map_id,
            shape__isnull=False
        ).values_list('shape', flat=True)
        obstacles.extend(events)

        # --- C. 获取其他区域 (Polygon) ---
        others = Otherarea.objects.filter(
            otherareamap__map_id=map_id,
            shape__isnull=False
        ).values_list('shape', flat=True)
        obstacles.extend(others)

        # --- D. 获取设施 (Point -> Polygon) ---
        facilities = Facility.objects.filter(
            facilitymap__map_id=map_id,
            location__isnull=False
        ).values_list('location', flat=True)
        # 将设施点膨胀后放入障碍物列表
        for point in facilities:
            # buffer(0.5) 表示以点为中心，半径 0.5 米的圆
            if isinstance(point, Point):
                obstacles.append(point.buffer(0.5))

        return outer_shell, holes, obstacles



================================================================================
文件路径: python-backend\guide\services.py
--------------------------------------------------------------------------------

# import networkx as nx
# from django.contrib.gis.geos import Point, LineString
# from map.context import MapContext
# from map.services import MapServices  # 复用校验逻辑
#
#
# class GuideService:
#
#     def __init__(self, map_id: int):
#         self.map_id = map_id
#         # 通过 Context 获取数据
#         self.outer_shell, self.holes = MapContext.get_map_geometry(map_id)
#         # 获取所有障碍物 (Map镂空 + 实体店铺 + 设施)
#         # 这里的 obstacles 是纯几何对象列表
#         self.obstacles = list(self.holes) + MapContext.get_all_obstacles(map_id)
#
#     # --- 接口 5: 完善导航接口 ---
#     def find_path(self, start_point: Point, end_point: Point):
#         """
#         计算单楼层内的两点路径
#         """
#         if not self.outer_shell:
#             return {"success": False, "message": "Map not initialized"}
#
#         # 0. 校验起终点合法性 (复用 MapService 的逻辑)
#         # 注意：这里我们假设 MapService 是无状态的工具类
#         valid_start, msg_start = MapService.check_area_placement(start_point, self.map_id)
#         # 对终点的检查可能需要放宽（因为终点可能就在店铺门口），这里暂时严格检查
#         valid_end, msg_end = MapService.check_area_placement(end_point, self.map_id)
#
#         if not valid_start:
#             return {"success": False, "message": f"Start point invalid: {msg_start}"}
#         # 如果终点是店铺，check_area_placement 会报错（因为和店铺重合），
#         # 实际逻辑中应该判断终点是否在障碍物内部，如果在内部，应该“弹出”到最近的可行走点。
#         # 此处简化，假设输入点已经处理过。
#
#         # 1. 构建可见性图 (Visibility Graph)
#         graph = nx.Graph()
#
#         # 节点包括：起点、终点、所有障碍物的顶点
#         nodes = [start_point, end_point]
#         for obs in self.obstacles:
#             # 获取多边形外环坐标 (去除最后一个重复点)
#             coords = obs.exterior.coords[:-1]
#             nodes.extend([Point(c, srid=2385) for c in coords])
#
#         # 2. 构建边
#         # 优化：仅在节点数较少时使用全连接 O(N^2)
#         node_ids = range(len(nodes))
#
#         for i in node_ids:
#             graph.add_node(i, pos=(nodes[i].x, nodes[i].y))
#
#         for i in node_ids:
#             for j in range(i + 1, len(nodes)):
#                 p1 = nodes[i]
#                 p2 = nodes[j]
#
#                 if self._is_line_of_sight_clear(p1, p2):
#                     dist = p1.distance(p2)
#                     graph.add_edge(i, j, weight=dist)
#
#         # 3. 计算 Dijkstra
#         try:
#             path_indices = nx.dijkstra_path(graph, source=0, target=1)
#             path_coords = [(nodes[i].x, nodes[i].y) for i in path_indices]
#
#             return {
#                 "success": True,
#                 "distance": nx.dijkstra_path_length(graph, source=0, target=1),
#                 "path": LineString(path_coords, srid=2385),
#                 "steps": path_coords
#             }
#         except nx.NetworkXNoPath:
#             return {
#                 "success": False,
#                 "message": "No walkable path found."
#             }
#
#     def _is_line_of_sight_clear(self, p1: Point, p2: Point) -> bool:
#         """
#         私有方法：判断视线是否被阻挡
#         """
#         line = LineString(p1, p2)
#
#         # 必须在外轮廓内
#         if not self.outer_shell.contains(line):
#             return False
#
#         # 不能穿过任何障碍物
#         for obstacle in self.obstacles:
#             # 使用 relation 或者 intersection 判断
#             if obstacle.intersects(line) and not obstacle.touches(line):
#                 return False
#         return True

from django.contrib.gis.geos import Point, LineString, Polygon
from typing import Tuple, List, Optional
import math
import heapq

# Context 导入
from guide.context import GuideContext


class GridSystem:
    """
    辅助类：网格系统类
    负责将世界坐标(Geo)转换为离散的网格坐标(Grid)
    并管理障碍物矩阵
    """

    def __init__(self, boundary_polygon: Polygon, resolution: float = 0.5):
        """
        :param boundary_polygon: 地图的外轮廓
        :param resolution: 网格精度，例如 0.5 表示每个网格格子 0.5x0.5 米
        """
        self.resolution = resolution
        self.boundary = boundary_polygon
        # 获取多边形 boundary_polygon 的最小最大坐标
        self.min_x, self.min_y, self.max_x, self.max_y = boundary_polygon.extent
        # 计算网格系统的 x方向、 y方向各自的格子总数
        self.width = int(math.ceil((self.max_x - self.min_x) / resolution))  # 这个方法 ceil 是向上取整
        self.height = int(math.ceil((self.max_y - self.min_y) / resolution))
        # 障碍物集合，存储不可行走的网格坐标元组 (gx, gy)
        self.obstacles = set()

    def world_to_grid(self, x: float, y: float) -> Tuple[int, int]:
        """将世界坐标转为网格坐标"""
        gx = int((x - self.min_x) / self.resolution)  # int() 是向下取整
        gy = int((y - self.min_y) / self.resolution)
        return gx, gy

    def grid_to_world(self, gx: int, gy: int) -> Tuple[float, float]:
        """将网格坐标中心转为世界坐标"""
        wx = self.min_x + (gx + 0.5) * self.resolution  # 这里是加上半格的意思，不是加上 0.5 米
        wy = self.min_y + (gy + 0.5) * self.resolution
        return wx, wy

    def mark_obstacles(self, geometry_list: List[Polygon]):
        """
        向 self.obstacles 集合中存储障碍物占据的格子坐标
        某个障碍物占据了哪些格子
        逆向思维：判断这个格子是否在这个障碍物多边形内
        """
        for poly in geometry_list:
            # 1. 性能优化：不要扫描全图，只扫描障碍物所在的那个矩形区域（Bounding Box）
            # poly.extent 返回 (min_x, min_y, max_x, max_y)
            min_x, min_y, max_x, max_y = poly.extent

            # 2. 把这个矩形区域的四个角，转换成网格坐标
            # min_gx, min_gy 是左下角格子的索引
            # max_gx, max_gy 是右上角格子的索引
            min_gx, min_gy = self.world_to_grid(min_x, min_y)
            max_gx, max_gy = self.world_to_grid(max_x, max_y)

            # 3. 修正边界，防止算出负数或者超出地图宽度的索引
            min_gx = max(0, min_gx)
            min_gy = max(0, min_gy)
            max_gx = min(self.width, max_gx + 1)  # +1 是为了保证循环能覆盖到边缘
            max_gy = min(self.height, max_gy + 1)

            # 4. 循环遍历这个小区域内的每一个格子
            for gx in range(min_gx, max_gx):
                for gy in range(min_gy, max_gy):
                    # 算出这个格子中心点在地图上的真实坐标 (wx, wy)
                    wx, wy = self.grid_to_world(gx, gy)

                    # 创建一个临时的点对象
                    cell_center = Point(wx, wy, srid=2385)

                    # 5. 关键判断：如果这个格子的中心点碰到了障碍物，这个格子就是不可走的
                    # intersects() 表示“相交”或“重叠”
                    if poly.intersects(cell_center):
                        self.obstacles.add((gx, gy))

    def is_walkable(self, gx: int, gy: int) -> bool:
        """检查网格点是否在地图内且不是障碍物"""
        # 1. 数组边界检查，严格小于 self.width，因为 self.width 是上取整
        if not (0 <= gx < self.width and 0 <= gy < self.height):
            return False
        # 2. 障碍物检查
        if (gx, gy) in self.obstacles:
            return False
        # 3. 地图边界检查
        # 算出这个格子中心的真实世界坐标
        wx, wy = self.grid_to_world(gx, gy)
        # 构造一个临时的点对象
        point = Point(wx, wy, srid=2385)
        # contains() 表示如果点在多边形内部返回 True，在外部返回 False
        if not self.boundary.contains(point):
            return False

        return True


class RoutePlanService:
    """
    路径规划业务服务层
    """

    def __init__(self):
        # 创建上下文对象
        self.ctx = GuideContext()

    def validate_request_params(self, map_id, start_data, end_data) -> Tuple[bool, str]:
        """
        在View中使用的，对Request请求参数的校验逻辑
        """
        # 1. 必填项校验
        if map_id is None:
            return False, "Missing parameter: map_id"
        if not start_data or not end_data:
            return False, "Missing parameter: start or end coordinates"

        # 2. 字典结构校验
        if not isinstance(start_data, dict) or not isinstance(end_data, dict):
            return False, "Coordinates must be JSON objects with x and y"

        # 3. 坐标数值校验
        try:
            float(start_data.get('x'))
            float(start_data.get('y'))
            float(end_data.get('x'))
            float(end_data.get('y'))
        except (ValueError, TypeError):
            return False, "Coordinates x and y must be valid numbers"

        return True, "Request params are valid"

    def calculate_route(self, map_id: int, start_pt: Point, end_pt: Point) -> Optional[LineString]:
        """
        主入口：计算路径
        """
        # 1. 获取地图几何数据 (调用 Context)
        # 期望返回:
        # outer_shell: Polygon (地图地板轮廓)
        # holes: List[Polygon] (地图本身镂空)
        # obstacles: List[Geometry] (商铺、活动区、其他区域、膨胀后的设施)
        outer_shell, holes, obstacles = self.ctx.get_map_geometry_data(map_id)

        if not outer_shell:
            raise ValueError(f"Map #{map_id} outer_shell missing")

        # 2. 初始化网格系统 (Grid System)
        # 设定分辨率为 0.5 米 (可根据性能需求调整)
        grid_sys = GridSystem(outer_shell, resolution=0.5)

        # 3. 网格化障碍物
        # 将 holes 和 obstacles 合并处理
        all_obstacles = holes + obstacles
        grid_sys.mark_obstacles(all_obstacles)

        # 4. 起点、终点坐标转换
        start_node = grid_sys.world_to_grid(start_pt.x, start_pt.y)
        end_node = grid_sys.world_to_grid(end_pt.x, end_pt.y)

        # 5. 校验起终点有效性
        if not grid_sys.is_walkable(*start_node):
            raise ValueError("Start node is not walkable")
        if not grid_sys.is_walkable(*end_node):
            raise ValueError("End node is not walkable")

        # 6. 执行 A* 算法，返回网格坐标的列表
        path_nodes = self._run_astar(start_node, end_node, grid_sys)

        if not path_nodes:
            return None

        # 7. 结果转换 (Grid Nodes -> Geo LineString)
        # 将网格路径转回世界坐标的折线
        return self._construct_linestring(path_nodes, grid_sys)

    def _run_astar(self, start_node: Tuple[int, int], end_node: Tuple[int, int], grid: GridSystem) \
            -> List[Tuple[int, int]]:
        """
        A* 算法核心逻辑
        :param start_node: (gx, gy) 起点
        :param end_node: (gx, gy) 终点
        :param grid: 网格系统对象，用于判断可行走性
        :return: [(x1, y1), (x2, y2), ...] 路径列表，如果找不到路径返回 None
        """
        # 1. 初始化 open_set (优先队列)，存放 (f_score, node)，可能的扩展节点
        # f_score = g_score + h_score
        open_set = []
        heapq.heappush(open_set, (0, start_node))

        # 2. 初始化记录字典
        # came_from: 记录路径回溯，key=当前节点, value=父节点
        came_from = {}

        # g_score: 从起点到当前节点的实际代价。默认无穷大。
        g_score = {start_node: 0.0}

        # f_score: 预估总代价。默认无穷大。
        # f_score[start_node] = h(start_node, end)
        f_score = {start_node: self._heuristic(start_node, end_node)}

        # 定义移动方向和对应的代价
        # (dx, dy, cost)
        sqrt2 = math.sqrt(2)
        movements = [
            (0, 1, 1.0), (0, -1, 1.0), (1, 0, 1.0), (-1, 0, 1.0),  # 上下右左
            (1, 1, sqrt2), (1, -1, sqrt2), (-1, 1, sqrt2), (-1, -1, sqrt2)  # 对角线
        ]

        # 3. 主循环，当 open_set 非空
        while open_set:
            # 取出 f_score 最小的节点
            current_f, current = heapq.heappop(open_set)

            # --- 成功到达终点 ---
            if current == end_node:
                return self._reconstruct_path(came_from, current)

            # 遍历 8 个邻居
            for dx, dy, move_cost in movements:
                neighbor = (current[0] + dx, current[1] + dy)

                # --- 核心判断：如果邻居不可走则跳过 ---
                if not grid.is_walkable(*neighbor):
                    continue

                # 计算经过当前节点到达邻居的 tentative_g (临时G值)
                tentative_g = g_score[current] + move_cost

                # 如果临时G值小于该邻居之前的G值，或者之前没访问过该邻居 (字典里找不到 neighbor 这个 key，就返回 inf)
                if tentative_g < g_score.get(neighbor, float('inf')):
                    # 更新记录
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g

                    # 计算 f 值 = g + h
                    new_f = tentative_g + self._heuristic(neighbor, end_node)
                    f_score[neighbor] = new_f

                    # 加入优先队列等待处理
                    heapq.heappush(open_set, (new_f, neighbor))

        # 循环结束仍未找到终点
        return None

    def _reconstruct_path(self, came_from: dict, current: Tuple[int, int]) -> List[Tuple[int, int]]:
        """
        私有辅助方法：从终点回溯到起点，重建路径
        """
        total_path = [current]
        while current in came_from:
            current = came_from[current]
            total_path.append(current)

        # 因为是从终点往回找的，所以要反转列表
        return total_path[::-1]

    def _heuristic(self, node_a: Tuple[int, int], node_b: Tuple[int, int]) -> float:
        """
        启发函数 (对角距离)
        """
        delta_x = abs(node_a[0] - node_b[0])
        delta_y = abs(node_a[1] - node_b[1])
        h_value = delta_x + delta_y + (math.sqrt(2) - 2) * min(delta_x, delta_y)
        return h_value

    def _construct_linestring(self, path_nodes: List[Tuple[int, int]], grid: GridSystem) -> LineString:
        """
        将网格节点序列转换为 PostGIS LineString 对象
        """
        points = []
        for gx, gy in path_nodes:
            wx, wy = grid.grid_to_world(gx, gy)
            points.append((wx, wy))

        return LineString(points, srid=2385)



================================================================================
文件路径: python-backend\guide\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase
from unittest.mock import MagicMock, patch
from django.contrib.gis.geos import Polygon, Point, LineString
from guide.services import RoutePlanService, GridSystem
from rest_framework.test import APITestCase
from rest_framework import status
from django.contrib.gis.geos import Polygon, GeometryCollection, Point
from core.models import Map, Building, Storearea, StoreareaMap


class GridSystemTestCase(TestCase):
    """
    测试 GridSystem 类的底层逻辑 (坐标转换、障碍物标记、边界检查)
    """

    def setUp(self):
        # 创建一个 10x10 的正方形地图 (SRID=2385)
        # 坐标范围: (0,0) -> (10,10)
        self.boundary = Polygon(((0, 0), (0, 10), (10, 10), (10, 0), (0, 0)), srid=2385)
        # 分辨率设为 1.0 米，方便计算 (网格大小 10x10)
        self.grid = GridSystem(self.boundary, resolution=1.0)

    def test_coordinate_conversion(self):
        """测试世界坐标与网格坐标的相互转换"""
        # 测试 world_to_grid (向下取整)
        # 坐标 (1.5, 1.5) 应该落在 (1, 1) 格子
        gx, gy = self.grid.world_to_grid(1.5, 1.5)
        self.assertEqual((gx, gy), (1, 1))

        # 测试 grid_to_world (取中心点)
        # 格子 (1, 1) 的中心应该是 (1.5, 1.5)
        wx, wy = self.grid.grid_to_world(1, 1)
        self.assertEqual((wx, wy), (1.5, 1.5))

    def test_mark_obstacles(self):
        """测试障碍物栅格化逻辑"""
        # 创建一个位于地图中心的障碍物 (4,4) 到 (6,6)
        obstacle = Polygon(((4, 4), (4, 6), (6, 6), (6, 4), (4, 4)), srid=2385)

        self.grid.mark_obstacles([obstacle])

        # 检查障碍物内部的点 (5, 5) -> 不可走
        self.assertFalse(self.grid.is_walkable(5, 5))

        # 检查障碍物边缘的点 (网格化后可能会占据边缘)
        # (4, 4) 根据 intersects 判定通常会被占据
        self.assertFalse(self.grid.is_walkable(4, 4))

        # 检查开阔区域的点 (1, 1) -> 可走
        self.assertTrue(self.grid.is_walkable(1, 1))

    def test_boundary_check_complex_shape(self):
        """
        测试不规则形状地图的边界检查 (L型地图)
        验证 is_walkable 中的 boundary.contains 逻辑
        """
        # 创建一个 L 型多边形 (缺口在右上角)
        # (0,0) -> (0,10) -> (5,10) -> (5,5) -> (10,5) -> (10,0) -> (0,0)
        l_shape_wkt = "POLYGON((0 0, 0 10, 5 10, 5 5, 10 5, 10 0, 0 0))"
        l_shape = Polygon.from_ewkt(l_shape_wkt)
        l_shape.srid = 2385

        grid = GridSystem(l_shape, resolution=1.0)

        # 1. 测试在地图内的点 (2, 2)
        self.assertTrue(grid.is_walkable(2, 2))

        # 2. 测试在 L 型缺口处的点 (8, 8)
        # 虽然 (8, 8) 在 GridSystem 的数组索引范围内 (width=10, height=10)
        # 但它在物理上位于大楼外部
        self.assertFalse(grid.is_walkable(8, 8))


class RoutePlanServiceTestCase(TestCase):
    """
    测试 A* 算法服务层逻辑
    使用 Mock 屏蔽 Context/数据库 操作
    """

    def setUp(self):
        self.service = RoutePlanService()
        # 基础地图: 20x20 米的正方形
        self.map_boundary = Polygon(((0, 0), (0, 20), (20, 20), (20, 0), (0, 0)), srid=2385)

    @patch('guide.services.GuideContext')
    def test_simple_straight_path(self, MockContext):
        """测试无障碍物的直线路径"""
        # --- Mock 设置 ---
        mock_ctx_instance = MockContext.return_value
        # 返回: (外框, 镂空[], 障碍物[])
        mock_ctx_instance.get_map_geometry_data.return_value = (self.map_boundary, [], [])

        # 替换 service 中的 ctx
        self.service.ctx = mock_ctx_instance

        # --- 执行测试 ---
        start = Point(2, 2, srid=2385)
        end = Point(18, 18, srid=2385)

        # 运行算法
        route = self.service.calculate_route(map_id=1, start_pt=start, end_pt=end)

        # --- 断言 ---
        self.assertIsInstance(route, LineString)
        # 直线距离约为 22.62 米
        # A* 也是走的对角线，长度应该非常接近直线距离
        self.assertAlmostEqual(route.length, start.distance(end), delta=1.0)

    @patch('guide.services.GuideContext')
    def test_obstacle_avoidance(self, MockContext):
        """测试绕行逻辑：起点和终点中间有一堵墙，必须从缺口绕过去"""
        # --- Mock 设置 ---
        mock_ctx_instance = MockContext.return_value

        # 定义障碍物：一堵带缺口的墙
        # 墙的范围：y轴 9到11，x轴 5到20。
        # 这意味着 x轴 0到5 的区域是空的（缺口），路径只能从这里通过。
        wall_with_gap = Polygon(((5, 9), (5, 11), (20, 11), (20, 9), (5, 9)), srid=2385)

        # 模拟 Context 返回：地图边界、无镂空、以及上面定义的障碍物
        mock_ctx_instance.get_map_geometry_data.return_value = (
            self.map_boundary,
            [],
            [wall_with_gap]
        )
        self.service.ctx = mock_ctx_instance

        # --- 执行测试 ---
        # 起点(10, 2) -> 终点(10, 18)
        # 直线连线会被墙挡住 (墙在 y=9~11, x=5~20)
        start = Point(10, 2, srid=2385)
        end = Point(10, 18, srid=2385)

        route = self.service.calculate_route(1, start, end)

        # --- 断言 ---
        self.assertIsNotNone(route)

        # 1. 验证路径长度：肯定大于直线距离 (16米)
        # 直线距离 = 18 - 2 = 16
        self.assertTrue(route.length > 16.0)

        # 2. 验证路径走向：必须经过左侧缺口
        # 获取路径上所有点的 x 坐标
        coords = route.coords
        min_x_in_path = min(p[0] for p in coords)

        # 因为墙是从 x=5 开始的，所以要想过去，路径中至少有一个点的 x 必须小于 5 (或者接近 5)
        # 我们这里断言 < 6.0 是为了留一点网格化精度的余量
        self.assertLess(min_x_in_path, 6.0)

    @patch('guide.services.GuideContext')
    def test_unreachable_target(self, MockContext):
        """测试终点被完全包围无法到达的情况"""
        mock_ctx_instance = MockContext.return_value

        # 障碍物完全包围终点 (10, 10)
        box = Polygon(((8, 8), (8, 12), (12, 12), (12, 8), (8, 8)), srid=2385)

        mock_ctx_instance.get_map_geometry_data.return_value = (self.map_boundary, [], [box])
        self.service.ctx = mock_ctx_instance

        start = Point(2, 2, srid=2385)
        end = Point(10, 10, srid=2385)  # 在盒子里面

        # 预期抛出 ValueError (因为 End node is not walkable)
        # 或者如果 End node 勉强算 walkable 但无法到达，则返回 None
        # 根据 services.py 逻辑，先检查 is_walkable

        # 由于障碍物占位，End point 所在的网格会被标记为 obstacle
        with self.assertRaises(ValueError) as cm:
            self.service.calculate_route(1, start, end)

        self.assertIn("End node is not walkable", str(cm.exception))


class GuideIntegrationTestCase(APITestCase):
    """
    第二步：集成测试
    测试 Views -> Services -> Context -> DB 的完整链路
    """

    def setUp(self):
        # 1. 创建基础建筑 (外键依赖)
        self.building = Building.objects.create(
            name="Test Mall",
            address="123 Test St"
        )

        # 2. 创建地图 (Map)
        # 地图是一个 20x20 的正方形
        # 注意：Map 的 detail 字段是 GeometryCollection
        boundary = Polygon(((0, 0), (0, 20), (20, 20), (20, 0), (0, 0)), srid=2385)
        gc = GeometryCollection(boundary, srid=2385)

        self.map_obj = Map.objects.create(
            building=self.building,
            floor_number=1,
            detail=gc
        )

        # 3. 创建一个商铺 (障碍物)
        # 商铺挡在地图中间 (8,8) 到 (12,12)
        store_shape = Polygon(((8, 8), (8, 12), (12, 12), (12, 8), (8, 8)), srid=2385)
        self.store = Storearea.objects.create(
            store_name="Blocker Store",
            owner_name="Test Owner",
            owner_phone="123",
            shape=store_shape,
            is_active=True  # 确保是激活状态
        )

        # 4. 关联商铺和地图 (建立中间表关系)
        # 注意：根据你的 models.py，StoreareaMap 有两个外键
        StoreareaMap.objects.create(
            storearea=self.store,
            map=self.map_obj
        )

        # API URL (需要你在 urls.py 中配置好，这里假设路径是 /api/guide/route/)
        self.url = '/api/guide/route/'

    def test_route_api_success(self):
        """测试完整的 API 调用流程"""
        # 起点 (2,2)，终点 (18,18)
        # 中间有商铺挡路，应该能规划出路径
        payload = {
            "map_id": self.map_obj.id,
            "start": {"x": 2.0, "y": 2.0},
            "end": {"x": 18.0, "y": 18.0}
        }

        response = self.client.post(self.url, payload, format='json')

        # 1. 验证状态码 200
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        # 2. 验证返回数据结构
        data = response.data
        self.assertIn("route", data)
        self.assertIn("distance", data)
        self.assertIsInstance(data["route"], dict)  # GeoJSON 对象
        self.assertIsInstance(data["route"]["coordinates"], list)

        # 3. 验证距离是否合理 (直线约22米，绕路肯定大于22米)
        self.assertTrue(data["distance"] > 22.0)

        # 打印一下结果看看
        print(f"\n[Integration Test] Route Distance: {data['distance']} meters")

    def test_api_missing_params(self):
        """测试参数缺失情况"""
        payload = {"map_id": self.map_obj.id}  # 缺少 start/end
        response = self.client.post(self.url, payload, format='json')
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

    def test_api_invalid_coordinates(self):
        """测试无效坐标 (起点在墙里)"""
        # 起点 (10, 10) 正好在刚才创建的 Storearea 内部
        payload = {
            "map_id": self.map_obj.id,
            "start": {"x": 10.0, "y": 10.0},
            "end": {"x": 18.0, "y": 18.0}
        }
        response = self.client.post(self.url, payload, format='json')

        # 预期报错：Start node is not walkable
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn("error", response.data)


================================================================================
文件路径: python-backend\guide\views.py
--------------------------------------------------------------------------------

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.contrib.gis.geos import Point
import json

# 导入服务类
from .services import RoutePlanService


class RoutePlanView(APIView):
    """
    POST /api/guide/route/
    接收起点终点坐标，返回路径规划结果
    """
    service_class = RoutePlanService

    def post(self, request):
        service = self.service_class()

        # 读取前端传参
        # 前端传参示例: {"map_id": 1, "start": {"x": 10.0, "y": 20.0}, "end": {"x": 50.0, "y": 60.0}}
        map_id = request.data.get('map_id')
        start_data = request.data.get('start')
        end_data = request.data.get('end')

        # 这一步负责检查参数是否存在、格式是否正确、坐标是否可转换为浮点数
        # 我们不需要在这里写 if-else，全交给 Service
        is_valid, error_msg = service.validate_request_params(map_id, start_data, end_data)

        if not is_valid:
            return Response({"error": error_msg}, status=status.HTTP_400_BAD_REQUEST)

        try:
            # 经过上面的校验，这里可以放心转换，不用担心 KeyError 或 TypeError
            start_point = Point(float(start_data['x']), float(start_data['y']), srid=2385)
            end_point = Point(float(end_data['x']), float(end_data['y']), srid=2385)

        except Exception as e:
            # 极端异常情况
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)

        try:
            # 预期 service 返回一个 LineString 对象
            route_geometry = service.calculate_route(map_id, start_point, end_point)

            if not route_geometry:
                return Response({"error": "Route not found or unreachable"}, status=status.HTTP_404_NOT_FOUND)

            # 构造返回
            response_data = {
                # json.loads(route_geometry.geojson) 将 GeoJSON 字符串转为 Python 字典/列表
                "route": json.loads(route_geometry.geojson),
                # route_geometry.length 自动计算米制长度，然后保留 2 位小数
                "distance": round(route_geometry.length, 2)
            }

            return Response(response_data)

        except Exception as e:
            # 捕获如算法内部抛出的业务异常
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)


================================================================================
文件路径: python-backend\guide\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\guide\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\management\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\management\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class ManagementConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'management'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\management\context.py
--------------------------------------------------------------------------------

from core.models import Eventarea, Otherarea, Event, Storearea, Facility,Admin
from core.context import BaseContext

class EventareaContext:
    """
    活动区域（Eventarea）的数据访问层
    
    提供与Eventarea模型相关的数据操作方法
    """
    
    @staticmethod
    def get_all_eventareas():
        """
        获取所有活动区域
        
        Returns:
            QuerySet: 活动区域的查询集
        """
        return Eventarea.objects.all()
    
    @staticmethod
    def get_eventarea_by_id(eventarea_id):
        """
        根据ID获取活动区域
        
        Args:
            eventarea_id: 活动区域ID
        
        Returns:
            Eventarea: 活动区域对象
        """
        return Eventarea.objects.get(id=eventarea_id)
    
    @staticmethod
    def create_eventarea(data):
        """
        创建新的活动区域
        
        Args:
            data: 活动区域数据
        
        Returns:
            Eventarea: 创建的活动区域对象
        """
        return Eventarea.objects.create(**data)
    
    @staticmethod
    def update_eventarea(eventarea_id, data):
        """
        更新活动区域
        
        Args:
            eventarea_id: 活动区域ID
            data: 更新数据
        
        Returns:
            Eventarea: 更新后的活动区域对象
        """
        eventarea = Eventarea.objects.get(id=eventarea_id)
        for key, value in data.items():
            setattr(eventarea, key, value)
        eventarea.save()
        return eventarea
    
    @staticmethod
    def delete_eventarea(eventarea_id):
        """
        删除活动区域
        
        Args:
            eventarea_id: 活动区域ID
        """
        Eventarea.objects.filter(id=eventarea_id).delete()


class EventContext:
    """
    活动（Event）的数据访问层
    
    提供与Event模型相关的数据操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """
    
    @staticmethod
    def get_all_events():
        """
        获取所有活动
        
        Returns:
            QuerySet: 活动的查询集
        """
        return Event.objects.all()
    
    @staticmethod
    def get_event_by_id(event_id):
        """
        根据ID获取活动
        
        Args:
            event_id: 活动ID
        
        Returns:
            Event: 活动对象
        """
        return Event.objects.get(id=event_id)
    
    @staticmethod
    def create_event(data):
        """
        创建新的活动
        
        Args:
            data: 活动数据
        
        Returns:
            Event: 创建的活动对象
        """
        return Event.objects.create(**data)
    
    @staticmethod
    def update_event(event_id, data):
        """
        更新活动
        
        Args:
            event_id: 活动ID
            data: 更新数据
        
        Returns:
            Event: 更新后的活动对象
        """
        event = Event.objects.get(id=event_id)
        for key, value in data.items():
            setattr(event, key, value)
        event.save()
        return event
    
    @staticmethod
    def delete_event(event_id):
        """
        删除活动
        
        Args:
            event_id: 活动ID
        """
        Event.objects.filter(id=event_id).delete()


class StoreareaContext:
    """
    店铺区域（Storearea）的数据访问层
    
    提供与Storearea模型相关的数据操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """
    
    @staticmethod
    def get_all_storeareas():
        """
        获取所有店铺区域
        
        Returns:
            QuerySet: 店铺区域的查询集
        """
        return Storearea.objects.all()
    
    @staticmethod
    def get_storearea_by_id(storearea_id):
        """
        根据ID获取店铺区域
        
        Args:
            storearea_id: 店铺区域ID
        
        Returns:
            Storearea: 店铺区域对象
        """
        return Storearea.objects.get(id=storearea_id)
    
    @staticmethod
    def create_storearea(data):
        """
        创建新的店铺区域
        
        Args:
            data: 店铺区域数据
        
        Returns:
            Storearea: 创建的店铺区域对象
        """
        return Storearea.objects.create(**data)
    
    @staticmethod
    def update_storearea(storearea_id, data):
        """
        更新店铺区域
        
        Args:
            storearea_id: 店铺区域ID
            data: 更新数据
        
        Returns:
            Storearea: 更新后的店铺区域对象
        """
        storearea = Storearea.objects.get(id=storearea_id)
        for key, value in data.items():
            setattr(storearea, key, value)
        storearea.save()
        return storearea
    
    @staticmethod
    def delete_storearea(storearea_id):
        """
        删除店铺区域
        
        Args:
            storearea_id: 店铺区域ID
        """
        Storearea.objects.filter(id=storearea_id).delete()


class OtherareaContext:
    """
    其他区域（Otherarea）的数据访问层
    
    提供与Otherarea模型相关的数据操作方法
    """
    
    @staticmethod
    def get_all_otherareas():
        """
        获取所有其他区域
        
        Returns:
            QuerySet: 其他区域的查询集
        """
        return Otherarea.objects.all()
    
    @staticmethod
    def get_otherarea_by_id(otherarea_id):
        """
        根据ID获取其他区域
        
        Args:
            otherarea_id: 其他区域ID
        
        Returns:
            Otherarea: 其他区域对象
        """
        return Otherarea.objects.get(id=otherarea_id)
    
    @staticmethod
    def create_otherarea(data):
        """
        创建新的其他区域
        
        Args:
            data: 其他区域数据
        
        Returns:
            Otherarea: 创建的其他区域对象
        """
        return Otherarea.objects.create(**data)
    
    @staticmethod
    def update_otherarea(otherarea_id, data):
        """
        更新其他区域
        
        Args:
            otherarea_id: 其他区域ID
            data: 更新数据
        
        Returns:
            Otherarea: 更新后的其他区域对象
        """
        otherarea = Otherarea.objects.get(id=otherarea_id)
        for key, value in data.items():
            setattr(otherarea, key, value)
        otherarea.save()
        return otherarea
    
    @staticmethod
    def delete_otherarea(otherarea_id):
        """
        删除其他区域
        
        Args:
            otherarea_id: 其他区域ID
        """
        Otherarea.objects.filter(id=otherarea_id).delete()


class FacilityContext:
    """
    设施（Facility）的数据访问层
    
    提供与Facility模型相关的数据操作方法
    注意：location属性由editor模块处理
    """
    
    @staticmethod
    def get_all_facilities():
        """
        获取所有设施
        
        Returns:
            QuerySet: 设施的查询集
        """
        return Facility.objects.all()
    
    @staticmethod
    def get_facility_by_id(facility_id):
        """
        根据ID获取设施
        
        Args:
            facility_id: 设施ID
        
        Returns:
            Facility: 设施对象
        """
        return Facility.objects.get(id=facility_id)
    
    @staticmethod
    def create_facility(data):
        """
        创建新的设施
        
        Args:
            data: 设施数据
        
        Returns:
            Facility: 创建的设施对象
        """
        return Facility.objects.create(**data)
    
    @staticmethod
    def update_facility(facility_id, data):
        """
        更新设施
        
        Args:
            facility_id: 设施ID
            data: 更新数据
        
        Returns:
            Facility: 更新后的设施对象
        """
        facility = Facility.objects.get(id=facility_id)
        for key, value in data.items():
            setattr(facility, key, value)
        facility.save()
        return facility
    
    @staticmethod
    def delete_facility(facility_id):
        """
        删除设施
        
        Args:
            facility_id: 设施ID
        """
        Facility.objects.filter(id=facility_id).delete()

class AdminContext(BaseContext):
    """针对 Admin 模型的基础 CRUD 和查询操作"""
    def __init__(self):
        super().__init__(Admin)

    def get_by_account(self, account: str) -> Admin | None:
        """根据账号名获取 Admin 实例"""
        try:
            return self.model.objects.get(account=account)
        except self.model.DoesNotExist:
            return None


================================================================================
文件路径: python-backend\management\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from django.apps import apps
from core.models import Admin

def get_eventarea_serializer():
    """获取活动区域序列化器"""
    Eventarea = apps.get_model('core', 'Eventarea')
    
    class EventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            exclude = ['shape']
    
    return EventareaSerializer


def get_otherarea_serializer():
    """获取其他区域序列化器"""
    Otherarea = apps.get_model('core', 'Otherarea')
    
    class OtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            exclude = ['shape']
    
    return OtherareaSerializer


def get_event_serializer():
    """获取Event模型的序列化器"""
    Event = apps.get_model('core', 'Event')
    
    class EventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = '__all__'
    
    return EventSerializer


def get_storearea_serializer():
    """获取Storearea模型的序列化器"""
    Storearea = apps.get_model('core', 'Storearea')
    
    class StoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            exclude = ['shape']
    
    return StoreareaSerializer


def get_facility_serializer():
    """获取Facility模型的序列化器"""
    Facility = apps.get_model('core', 'Facility')
    
    class FacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            exclude = ['location']
    
    return FacilitySerializer

# Input Serializers (用于接收前端数据)
class AdminRegisterSerializer(serializers.Serializer):
    """管理员注册输入"""
    account = serializers.CharField(max_length=64)
    password = serializers.CharField(max_length=128, write_only=True)
    name = serializers.CharField(max_length=64, required=False, allow_blank=True)

class AdminLoginSerializer(serializers.Serializer):
    """管理员登录输入"""
    account = serializers.CharField(max_length=64)
    password = serializers.CharField(max_length=128, write_only=True) # write_only: 密码只用于输入，不用于输出

class AdminUpdateSerializer(serializers.Serializer):
    """管理员修改信息输入 (用于 PUT / PATCH)"""
    name = serializers.CharField(max_length=64, required=False, allow_blank=True)
    # 允许修改密码，但必须使用新的字段名 new_password
    new_password = serializers.CharField(max_length=128, required=False, write_only=True)

# Output Serializer (用于返回 Admin 实例信息)
class AdminProfileSerializer(serializers.ModelSerializer):
    """管理员信息的输出格式 (不暴露密码)"""
    class Meta:
        model = Admin
        fields = ['id', 'account', 'name']
        read_only_fields = ['id', 'account'] # 账号和ID不能通过这个接口修改


================================================================================
文件路径: python-backend\management\services.py
--------------------------------------------------------------------------------

from .context import EventareaContext, OtherareaContext, EventContext, StoreareaContext, FacilityContext, AdminContext
from core.models import Admin
from django.contrib.auth.hashers import make_password, check_password
from django.core.exceptions import ValidationError


class AdminService:
    """负责管理员的注册、登录和个人信息修改的业务逻辑"""

    def __init__(self):
        self.ctx = AdminContext()

    def register_admin(self, account: str, password: str, name: str | None = None) -> Admin:
        """注册新管理员"""
        if self.ctx.get_by_account(account):
            raise ValidationError("Admin account already exists.")

        # 1. 密码哈希 (SECURITY CRITICAL)
        hashed_password = make_password(password)

        # 2. 创建实例
        admin_instance = self.ctx.create(
            account=account,
            password=hashed_password,
            name=name
        )
        return admin_instance

    def login_admin(self, account: str, password: str) -> Admin | None:
        """验证管理员登录凭证"""
        admin_instance = self.ctx.get_by_account(account)

        # 1. 检查实例是否存在
        if not admin_instance:
            return None  # 账号不存在

        # 2. 检查密码是否匹配 (使用 check_password 验证哈希值)
        if check_password(password, admin_instance.password):
            return admin_instance  # 登录成功

        return None  # 密码错误

    def update_profile(self, admin_instance: Admin, name: str | None, new_password: str | None) -> Admin:
        """更新管理员信息 (姓名和/或密码)"""
        update_data = {}

        if name is not None:
            update_data['name'] = name

        if new_password:
            # 3. 如果有新密码，哈希后再更新
            update_data['password'] = make_password(new_password)

        return self.ctx.update(admin_instance, **update_data)


class EventareaService:
    """
    活动区域（Eventarea）的业务逻辑层

    提供与Eventarea模型相关的业务逻辑处理方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_eventareas():
        """
        获取所有活动区域

        Returns:
            QuerySet: 活动区域的查询集
        """
        return EventareaContext.get_all_eventareas()

    @staticmethod
    def get_eventarea_by_id(eventarea_id):
        """
        根据ID获取活动区域

        Args:
            eventarea_id: 活动区域ID

        Returns:
            Eventarea: 活动区域对象
        """
        return EventareaContext.get_eventarea_by_id(eventarea_id)

    @staticmethod
    def create_eventarea(data):
        """
        创建新的活动区域

        Args:
            data: 活动区域数据

        Returns:
            Eventarea: 创建的活动区域对象
        """
        # 业务逻辑验证
        # 1. 验证数据完整性
        required_fields = ['is_active', 'description', 'organizer_name', 'organizer_phone', 'type']
        for field in required_fields:
            if field not in data:
                raise ValueError(f"Field '{field}' is required")

        # 2. 验证电话号码格式
        # 这里可以添加更复杂的电话号码验证逻辑
        if len(data['organizer_phone']) < 10:
            raise ValueError("Phone number must be at least 10 characters long")

        # 3. 验证类型是否合法
        valid_types = ['exhibition', 'concert', 'meeting', 'other']  # 根据实际需求调整
        if data['type'] not in valid_types:
            raise ValueError(f"Invalid type. Valid types are: {', '.join(valid_types)}")

        # 4. 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        return EventareaContext.create_eventarea(data)

    @staticmethod
    def update_eventarea(eventarea_id, data):
        """
        更新活动区域

        Args:
            eventarea_id: 活动区域ID
            data: 更新数据

        Returns:
            Eventarea: 更新后的活动区域对象
        """
        # 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        # 如果有其他业务逻辑验证，可以在这里添加

        return EventareaContext.update_eventarea(eventarea_id, data)

    @staticmethod
    def delete_eventarea(eventarea_id):
        """
        删除活动区域

        Args:
            eventarea_id: 活动区域ID
        """
        # 业务逻辑验证
        # 1. 验证活动区域是否存在
        eventarea = EventareaContext.get_eventarea_by_id(eventarea_id)

        # 2. 验证是否有相关联的活动
        if eventarea.event_set.exists():
            raise ValueError("Cannot delete eventarea with associated events")

        return EventareaContext.delete_eventarea(eventarea_id)


class OtherareaService:
    """
    其他区域（Otherarea）的业务逻辑层

    提供与Otherarea模型相关的业务逻辑处理方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_otherareas():
        """
        获取所有其他区域

        Returns:
            QuerySet: 其他区域的查询集
        """
        return OtherareaContext.get_all_otherareas()

    @staticmethod
    def get_otherarea_by_id(otherarea_id):
        """
        根据ID获取其他区域

        Args:
            otherarea_id: 其他区域ID

        Returns:
            Otherarea: 其他区域对象
        """
        return OtherareaContext.get_otherarea_by_id(otherarea_id)

    @staticmethod
    def create_otherarea(data):
        """
        创建新的其他区域

        Args:
            data: 其他区域数据

        Returns:
            Otherarea: 创建的其他区域对象
        """
        # 业务逻辑验证
        # 1. 验证数据完整性
        required_fields = ['is_active', 'description', 'type', 'is_public']
        for field in required_fields:
            if field not in data:
                raise ValueError(f"Field '{field}' is required")

        # 2. 验证类型是否合法
        valid_types = ['restroom', 'parking', 'entrance', 'exit', 'staircase', 'elevator', 'other']  # 根据实际需求调整
        if data['type'] not in valid_types:
            raise ValueError(f"Invalid type. Valid types are: {', '.join(valid_types)}")

        # 3. 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        return OtherareaContext.create_otherarea(data)

    @staticmethod
    def update_otherarea(otherarea_id, data):
        """
        更新其他区域

        Args:
            otherarea_id: 其他区域ID
            data: 更新数据

        Returns:
            Otherarea: 更新后的其他区域对象
        """
        # 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        # 如果有其他业务逻辑验证，可以在这里添加

        return OtherareaContext.update_otherarea(otherarea_id, data)

    @staticmethod
    def delete_otherarea(otherarea_id):
        """
        删除其他区域

        Args:
            otherarea_id: 其他区域ID
        """
        # 业务逻辑验证
        # 1. 验证其他区域是否存在
        otherarea = OtherareaContext.get_otherarea_by_id(otherarea_id)

        # 2. 可以添加其他验证逻辑

        return OtherareaContext.delete_otherarea(otherarea_id)


class EventService:
    """
    活动（Event）的业务逻辑层

    提供与Event模型相关的业务逻辑操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_events():
        """
        获取所有活动

        Returns:
            QuerySet: 活动的查询集
        """
        return EventContext.get_all_events()

    @staticmethod
    def get_event_by_id(event_id):
        """
        根据ID获取活动

        Args:
            event_id: 活动ID

        Returns:
            Event: 活动对象
        """
        return EventContext.get_event_by_id(event_id)

    @staticmethod
    def create_event(data):
        """
        创建新的活动

        Args:
            data: 活动数据

        Returns:
            Event: 创建的活动对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 业务逻辑验证
        # 这里可以添加更多的业务逻辑验证

        return EventContext.create_event(data)

    @staticmethod
    def update_event(event_id, data):
        """
        更新活动

        Args:
            event_id: 活动ID
            data: 更新数据

        Returns:
            Event: 更新后的活动对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 业务逻辑验证
        # 这里可以添加更多的业务逻辑验证

        return EventContext.update_event(event_id, data)

    @staticmethod
    def delete_event(event_id):
        """
        删除活动

        Args:
            event_id: 活动ID
        """
        EventContext.delete_event(event_id)


class StoreareaService:
    """
    店铺区域（Storearea）的业务逻辑层

    提供与Storearea模型相关的业务逻辑操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_storeareas():
        """
        获取所有店铺区域

        Returns:
            QuerySet: 店铺区域的查询集
        """
        return StoreareaContext.get_all_storeareas()

    @staticmethod
    def get_storearea_by_id(storearea_id):
        """
        根据ID获取店铺区域

        Args:
            storearea_id: 店铺区域ID

        Returns:
            Storearea: 店铺区域对象
        """
        return StoreareaContext.get_storearea_by_id(storearea_id)

    @staticmethod
    def create_storearea(data):
        """
        创建新的店铺区域

        Args:
            data: 店铺区域数据

        Returns:
            Storearea: 创建的店铺区域对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 业务逻辑验证
        # 这里可以添加更多的业务逻辑验证

        return StoreareaContext.create_storearea(data)

    @staticmethod
    def update_storearea(storearea_id, data):
        """
        更新店铺区域

        Args:
            storearea_id: 店铺区域ID
            data: 更新数据

        Returns:
            Storearea: 更新后的店铺区域对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 业务逻辑验证
        # 这里可以添加更多的业务逻辑验证

        return StoreareaContext.update_storearea(storearea_id, data)

    @staticmethod
    def delete_storearea(storearea_id):
        """
        删除店铺区域
        
        Args:
            storearea_id: 店铺区域ID
        """
        StoreareaContext.delete_storearea(storearea_id)


class FacilityService:
    """
    设施（Facility）的业务逻辑层
    
    提供与Facility模型相关的业务逻辑处理方法
    注意：location属性由editor模块处理
    """

    @staticmethod
    def get_all_facilities():
        """
        获取所有设施
        
        Returns:
            QuerySet: 设施的查询集
        """
        return FacilityContext.get_all_facilities()

    @staticmethod
    def get_facility_by_id(facility_id):
        """
        根据ID获取设施
        
        Args:
            facility_id: 设施ID
        
        Returns:
            Facility: 设施对象
        """
        return FacilityContext.get_facility_by_id(facility_id)

    @staticmethod
    def create_facility(data):
        """
        创建新的设施
        
        Args:
            data: 设施数据
        
        Returns:
            Facility: 创建的设施对象
        """
        # 业务逻辑验证
        # 1. 验证数据完整性
        required_fields = ['is_active', 'description', 'type']
        for field in required_fields:
            if field not in data:
                raise ValueError(f"Field '{field}' is required")

        # 2. 验证类型是否合法（根据实际需求调整）
        # 这里假设type是整数类型，表示不同的设施类型

        # 3. 如果提供了location属性，将其移除（location属性由editor模块处理）
        if 'location' in data:
            data.pop('location')

        return FacilityContext.create_facility(data)

    @staticmethod
    def update_facility(facility_id, data):
        """
        更新设施
        
        Args:
            facility_id: 设施ID
            data: 更新数据
        
        Returns:
            Facility: 更新后的设施对象
        """
        # 如果提供了location属性，将其移除（location属性由editor模块处理）
        if 'location' in data:
            data.pop('location')

        # 如果有其他业务逻辑验证，可以在这里添加

        return FacilityContext.update_facility(facility_id, data)

    @staticmethod
    def delete_facility(facility_id):
        """
        删除设施
        
        Args:
            facility_id: 设施ID
        """
        # 业务逻辑验证
        # 1. 验证设施是否存在
        facility = FacilityContext.get_facility_by_id(facility_id)

        # 2. 可以添加其他验证逻辑

        return FacilityContext.delete_facility(facility_id)


================================================================================
文件路径: python-backend\management\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.
from rest_framework.test import APITestCase
from rest_framework import status
from django.urls import reverse
from core.models import Admin
from django.contrib.auth.hashers import check_password, make_password


class AdminAuthAPITestCase(APITestCase):
    """
    测试管理员注册、登录、注销接口 (AdminAuthView)
    """

    def setUp(self):
        # 预先定义好路由名称
        self.register_url = reverse('admin-auth', kwargs={'action': 'register'})
        self.login_url = reverse('admin-auth', kwargs={'action': 'login'})
        self.logout_url = reverse('admin-auth', kwargs={'action': 'logout'})
        self.profile_url = reverse('admin-profile')  # 档案管理路由

        # 注册一个测试管理员供后续登录测试使用
        self.account = "testuser"
        self.password = "password123"
        self.admin = Admin.objects.create(
            account=self.account,
            password=make_password(self.password),  # 注意: 这里是明文，在测试中我们会手动进行哈希检查
            name="Original Name"
        )
        # # 注意: 真实的 AdminService.register_admin 会自动哈希密码，但这里我们绕过 Service 直接创建，
        # # 所以必须手动设置哈希后的密码才能通过 login 测试。
        # self.admin.password = check_password(self.password, 'fake_hash')  # 任意哈希值
        # self.admin.save()

    # ------------------ 注册 (Register) 测试 ------------------

    def test_register_success(self):
        """测试成功注册新管理员"""
        data = {"account": "newadmin", "password": "newpassword456", "name": "New Admin"}
        response = self.client.post(self.register_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Admin.objects.count(), 2)
        self.assertEqual(response.data['account'], 'newadmin')

        # 验证密码是否被哈希存储
        new_admin = Admin.objects.get(account='newadmin')
        self.assertTrue(check_password("newpassword456", new_admin.password))

    def test_register_duplicate_account(self):
        """测试注册时账号重复"""
        data = {"account": self.account, "password": "somepassword", "name": "Duplicate User"}
        response = self.client.post(self.register_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('account already exists', response.data['error'].lower())
        self.assertEqual(Admin.objects.count(), 1)  # 确认没有创建新用户

    # ------------------ 登录 (Login) 测试 ------------------

    def test_login_success(self):
        """测试成功登录"""
        data = {"account": self.account, "password": self.password}
        response = self.client.post(self.login_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['account'], self.account)
        # 验证 Session 是否被正确设置 (检查响应中的 session key)
        self.assertIn('sessionid', response.cookies)
        self.assertTrue(self.client.session.get('admin_id'))

    def test_login_failure_wrong_password(self):
        """测试密码错误导致登录失败"""
        data = {"account": self.account, "password": "wrongpassword"}
        response = self.client.post(self.login_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertIn('Invalid account or password', response.data['error'])

    def test_login_failure_non_existent_account(self):
        """测试账号不存在导致登录失败"""
        data = {"account": "nonexistent", "password": "anypassword"}
        response = self.client.post(self.login_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertIn('Invalid account or password', response.data['error'])

    # ------------------ 注销 (Logout) 测试 ------------------

    def test_logout_success(self):
        """测试成功注销"""
        # 先登录以设置 Session
        self.client.post(self.login_url, {"account": self.account, "password": self.password}, format='json')

        # 执行注销
        response = self.client.post(self.logout_url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        # 验证 Session 是否被清除
        self.assertIsNone(self.client.session.get('admin_id'))


class AdminProfileAPITestCase(APITestCase):
    """
    测试管理员档案管理接口 (AdminProfileView)
    """

    def setUp(self):
        self.login_url = reverse('admin-auth', kwargs={'action': 'login'})
        self.profile_url = reverse('admin-profile')

        self.account = "profileuser"
        self.password = "profilepass"

        # 手动创建 Admin 实例,确保密码哈希
        hashed_password = make_password(self.password)
        self.admin = Admin.objects.create(
            account=self.account,
            password=hashed_password,
            name="Profile Target"
        )

        # 登录并获取 Session Cookie
        self.client.post(self.login_url, {"account": self.account, "password": self.password}, format='json')
        # self.admin = Admin.objects.get(account=self.account)  # 获取实例

    # ------------------ 权限 (Authorization) 测试 ------------------

    def test_profile_requires_authentication(self):
        """测试未登录用户无法访问 Profile 接口"""
        self.client.logout()  # 清除 Session
        response_get = self.client.get(self.profile_url, format='json')
        response_put = self.client.put(self.profile_url, {"name": "fail"}, format='json')

        self.assertEqual(response_get.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertEqual(response_put.status_code, status.HTTP_401_UNAUTHORIZED)

    # ------------------ 获取信息 (GET) 测试 ------------------

    def test_get_profile_success(self):
        """测试成功获取个人信息"""
        response = self.client.get(self.profile_url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['account'], self.account)
        self.assertEqual(response.data['name'], "Profile Target")
        self.assertNotIn('password', response.data)  # 确保密码没有被泄露

    # ------------------ 修改信息 (PUT/PATCH) 测试 ------------------

    def test_update_name_success(self):
        """测试成功修改姓名"""
        new_name = "Updated User Name"
        response = self.client.put(self.profile_url, {"name": new_name}, format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['name'], new_name)

        # 验证数据库中的值已更新
        self.admin.refresh_from_db()
        self.assertEqual(self.admin.name, new_name)

    def test_update_password_success(self):
        """测试成功修改密码"""
        new_password = "verysecurepassword"
        response = self.client.put(self.profile_url, {"new_password": new_password}, format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['account'], self.account)

        # 验证新的密码能否用于登录
        self.admin.refresh_from_db()
        self.assertTrue(check_password(new_password, self.admin.password))

        # 验证旧密码失效
        self.assertFalse(check_password(self.password, self.admin.password))

    def test_update_both_success(self):
        """测试同时修改姓名和密码"""
        new_name = "Final Name"
        new_password = "FinalPassword"

        response = self.client.put(self.profile_url,
                                   {"name": new_name, "new_password": new_password},
                                   format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['name'], new_name)

        # 验证数据库
        self.admin.refresh_from_db()
        self.assertEqual(self.admin.name, new_name)
        self.assertTrue(check_password(new_password, self.admin.password))


================================================================================
文件路径: python-backend\management\urls.py
--------------------------------------------------------------------------------

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import EventareaViewSet, OtherareaViewSet, EventViewSet, StoreareaViewSet, FacilityViewSet

# 创建路由器并注册视图集
router = DefaultRouter()
router.register(r'eventarea', EventareaViewSet, basename='management_eventarea')
router.register(r'otherarea', OtherareaViewSet, basename='management_otherarea')
router.register(r'event', EventViewSet, basename='management_event')
router.register(r'storearea', StoreareaViewSet, basename='management_storearea')
router.register(r'facility', FacilityViewSet, basename='management_facility')

urlpatterns = [
    # 包含路由器生成的所有URL
    path('', include(router.urls)),
]



================================================================================
文件路径: python-backend\management\views.py
--------------------------------------------------------------------------------

from rest_framework import viewsets, status
from rest_framework.response import Response
from django.shortcuts import get_object_or_404
from .serializers import get_eventarea_serializer, get_otherarea_serializer, get_event_serializer, get_storearea_serializer, get_facility_serializer
from .services import EventareaService, OtherareaService, EventService, StoreareaService, FacilityService


class EventareaViewSet(viewsets.ModelViewSet):
    """
    活动区域（Eventarea）的视图集
    
    注意：
    - 在management模块中处理除shape属性外的所有其他属性
    - shape属性的操作由editor模块处理
    - 不允许修改shape属性
    
    支持的操作：
    - GET /api/management/eventarea/ - 获取所有活动区域列表
    - GET /api/management/eventarea/{id}/ - 获取指定活动区域详情
    - POST /api/management/eventarea/ - 创建新的活动区域
    - PUT /api/management/eventarea/{id}/ - 完整更新活动区域（不包括shape）
    - PATCH /api/management/eventarea/{id}/ - 部分更新活动区域（不包括shape）
    - DELETE /api/management/eventarea/{id}/ - 删除指定活动区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_eventarea_serializer()
    
    def get_queryset(self):
        """获取所有活动区域"""
        return EventareaService.get_all_eventareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动区域列表"""
        eventareas = EventareaService.get_all_eventareas()
        serializer = self.get_serializer(eventareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动区域详情"""
        eventarea = get_object_or_404(EventareaService.get_all_eventareas(), pk=pk)
        serializer = self.get_serializer(eventarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的活动区域"""
        try:
            # 检查是否包含shape属性，如果包含则移除
            data = request.data.copy()
            if 'shape' in data:
                data.pop('shape')
            
            eventarea = EventareaService.create_eventarea(data)
            serializer = self.get_serializer(eventarea)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新活动区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            eventarea = EventareaService.update_eventarea(pk, request.data)
            serializer = self.get_serializer(eventarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新活动区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            eventarea = EventareaService.update_eventarea(pk, request.data)
            serializer = self.get_serializer(eventarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """删除指定活动区域"""
        try:
            EventareaService.delete_eventarea(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class OtherareaViewSet(viewsets.ModelViewSet):
    """
    其他区域（Otherarea）的视图集
    
    注意：
    - 在management模块中处理除shape属性外的所有其他属性
    - shape属性的操作由editor模块处理
    - 不允许修改shape属性
    
    支持的操作：
    - GET /api/management/otherarea/ - 获取所有其他区域列表
    - GET /api/management/otherarea/{id}/ - 获取指定其他区域详情
    - POST /api/management/otherarea/ - 创建新的其他区域
    - PUT /api/management/otherarea/{id}/ - 完整更新其他区域（不包括shape）
    - PATCH /api/management/otherarea/{id}/ - 部分更新其他区域（不包括shape）
    - DELETE /api/management/otherarea/{id}/ - 删除指定其他区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_otherarea_serializer()
    
    def get_queryset(self):
        """获取所有其他区域"""
        return OtherareaService.get_all_otherareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有其他区域列表"""
        otherareas = OtherareaService.get_all_otherareas()
        serializer = self.get_serializer(otherareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定其他区域详情"""
        otherarea = get_object_or_404(OtherareaService.get_all_otherareas(), pk=pk)
        serializer = self.get_serializer(otherarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的其他区域"""
        try:
            # 检查是否包含shape属性，如果包含则移除
            data = request.data.copy()
            if 'shape' in data:
                data.pop('shape')
            
            otherarea = OtherareaService.create_otherarea(data)
            serializer = self.get_serializer(otherarea)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新其他区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            otherarea = OtherareaService.update_otherarea(pk, request.data)
            serializer = self.get_serializer(otherarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新其他区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            otherarea = OtherareaService.update_otherarea(pk, request.data)
            serializer = self.get_serializer(otherarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """删除指定其他区域"""
        try:
            OtherareaService.delete_otherarea(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class EventViewSet(viewsets.ModelViewSet):
    """
    活动（Event）的视图集
    
    支持的操作：
    - GET /api/management/event/ - 获取所有活动列表
    - GET /api/management/event/{id}/ - 获取指定活动详情
    - POST /api/management/event/ - 创建新的活动
    - PUT /api/management/event/{id}/ - 完整更新活动
    - PATCH /api/management/event/{id}/ - 部分更新活动
    - DELETE /api/management/event/{id}/ - 删除指定活动
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_event_serializer()
    
    def get_queryset(self):
        """获取所有活动"""
        return EventService.get_all_events()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动列表"""
        events = EventService.get_all_events()
        serializer = self.get_serializer(events, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动详情"""
        event = get_object_or_404(EventService.get_all_events(), pk=pk)
        serializer = self.get_serializer(event)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的活动"""
        try:
            event = EventService.create_event(request.data)
            serializer = self.get_serializer(event)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新活动"""
        try:
            event = EventService.update_event(pk, request.data)
            serializer = self.get_serializer(event)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新活动"""
        try:
            event = EventService.update_event(pk, request.data)
            serializer = self.get_serializer(event)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """删除指定活动"""
        try:
            EventService.delete_event(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class StoreareaViewSet(viewsets.ModelViewSet):
    """
    店铺区域（Storearea）的视图集
    
    注意：
    - 不处理shape属性，该属性由editor模块处理
    
    支持的操作：
    - GET /api/management/storearea/ - 获取所有店铺区域列表
    - GET /api/management/storearea/{id}/ - 获取指定店铺区域详情
    - POST /api/management/storearea/ - 创建新的店铺区域
    - PUT /api/management/storearea/{id}/ - 完整更新店铺区域（不包括shape）
    - PATCH /api/management/storearea/{id}/ - 部分更新店铺区域（不包括shape）
    - DELETE /api/management/storearea/{id}/ - 删除指定店铺区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_storearea_serializer()
    
    def get_queryset(self):
        """获取所有店铺区域"""
        return StoreareaService.get_all_storeareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有店铺区域列表"""
        storeareas = StoreareaService.get_all_storeareas()
        serializer = self.get_serializer(storeareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定店铺区域详情"""
        storearea = get_object_or_404(StoreareaService.get_all_storeareas(), pk=pk)
        serializer = self.get_serializer(storearea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的店铺区域"""
        try:
            # 检查是否包含shape属性，如果包含则移除
            data = request.data.copy()
            if 'shape' in data:
                data.pop('shape')
            
            storearea = StoreareaService.create_storearea(data)
            serializer = self.get_serializer(storearea)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新店铺区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            storearea = StoreareaService.update_storearea(pk, request.data)
            serializer = self.get_serializer(storearea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新店铺区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            storearea = StoreareaService.update_storearea(pk, request.data)
            serializer = self.get_serializer(storearea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """
        删除指定店铺区域
        """
        try:
            StoreareaService.delete_storearea(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class FacilityViewSet(viewsets.ModelViewSet):
    """
    设施（Facility）的视图集
    
    注意：
    - 在management模块中处理除location属性外的所有其他属性
    - location属性的操作由editor模块处理
    - 不允许修改location属性
    
    支持的操作：
    - GET /api/management/facility/ - 获取所有设施列表
    - GET /api/management/facility/{id}/ - 获取指定设施详情
    - POST /api/management/facility/ - 创建新的设施
    - PUT /api/management/facility/{id}/ - 完整更新设施（不包括location）
    - PATCH /api/management/facility/{id}/ - 部分更新设施（不包括location）
    - DELETE /api/management/facility/{id}/ - 删除指定设施
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_facility_serializer()
    
    def get_queryset(self):
        """获取所有设施"""
        return FacilityService.get_all_facilities()
    
    def list(self, request, *args, **kwargs):
        """获取所有设施列表"""
        facilities = FacilityService.get_all_facilities()
        serializer = self.get_serializer(facilities, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定设施详情"""
        facility = get_object_or_404(FacilityService.get_all_facilities(), pk=pk)
        serializer = self.get_serializer(facility)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的设施"""
        try:
            # 检查是否包含location属性，如果包含则移除
            data = request.data.copy()
            if 'location' in data:
                data.pop('location')
            
            facility = FacilityService.create_facility(data)
            serializer = self.get_serializer(facility)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新设施（不包括location）"""
        try:
            # 检查是否包含location属性，如果包含则返回错误
            if 'location' in request.data:
                return Response(
                    {'error': 'Location attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            facility = FacilityService.update_facility(pk, request.data)
            serializer = self.get_serializer(facility)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新设施（不包括location）"""
        try:
            # 检查是否包含location属性，如果包含则返回错误
            if 'location' in request.data:
                return Response(
                    {'error': 'Location attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            facility = FacilityService.update_facility(pk, request.data)
            serializer = self.get_serializer(facility)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """删除指定设施"""
        try:
            FacilityService.delete_facility(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.core.exceptions import ValidationError
from django.http import HttpRequest

from .services import AdminService
from .serializers import AdminRegisterSerializer, AdminLoginSerializer, AdminUpdateSerializer, AdminProfileSerializer
from core.models import Admin
from core.context import BaseContext


class AdminAuthMixin:
    """一个简单的用于检查管理员登录状态并加载 Admin 实例的 Mixin"""
    @staticmethod
    def get_admin_user(request: HttpRequest) -> Admin | None:
        admin_id = request.session.get('admin_id')
        if admin_id:
            try:
                # 使用 BaseContext 或 AdminContext 获取实例
                return BaseContext(Admin).get_by_id(admin_id)
            except Admin.DoesNotExist:
                del request.session['admin_id']  # 清理过期会话
                return None
        return None


class AdminAuthView(APIView):
    """
    处理管理员的注册、登录、注销
    POST /api/management/auth/register/
    POST /api/management/auth/login/
    POST /api/management/auth/logout/
    """
    service_class = AdminService

    def post(self, request, action):
        service = self.service_class()

        if action == 'register':
            serializer = AdminRegisterSerializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            try:
                admin = service.register_admin(**serializer.validated_data)
                return Response(AdminProfileSerializer(admin).data, status=status.HTTP_201_CREATED)
            except ValidationError as e:
                return Response({"error": e.message}, status=status.HTTP_400_BAD_REQUEST)

        elif action == 'login':
            serializer = AdminLoginSerializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            admin = service.login_admin(**serializer.validated_data)

            if admin:
                # 登录成功：在 session 中设置 ID
                request.session['admin_id'] = admin.id
                return Response(AdminProfileSerializer(admin).data, status=status.HTTP_200_OK)
            else:
                return Response({"error": "Invalid account or password"}, status=status.HTTP_401_UNAUTHORIZED)

        elif action == 'logout':
            if 'admin_id' in request.session:
                del request.session['admin_id']  # 清除 session
            return Response({"message": "Logout successful"}, status=status.HTTP_200_OK)

        else:
            return Response({"error": "Invalid action"}, status=status.HTTP_400_BAD_REQUEST)


# --- 个人信息接口 ---
class AdminProfileView(AdminAuthMixin, APIView):
    """
    处理管理员个人信息的获取和修改
    GET /api/management/profile/
    PUT/PATCH /api/management/profile/
    """
    service_class = AdminService
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.admin_user = None # 初始化实例属性
        
    def dispatch(self, request, *args, **kwargs):
        # 在处理请求前，先检查登录状态并加载 Admin 实例
        self.admin_user = self.get_admin_user(request)
        if not self.admin_user:
            return Response({"error": "Authentication credentials were not provided."},
                            status=status.HTTP_401_UNAUTHORIZED)
        return super().dispatch(request, *args, **kwargs)

    def get(self, request):
        """获取当前登录管理员的个人信息"""
        # self.admin_user 已在 dispatch 中加载并验证
        return Response(AdminProfileSerializer(self.admin_user).data)

    def put(self, request):
        """修改当前登录管理员的个人信息 (PUT/PATCH 通用)"""
        serializer = AdminUpdateSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        service = self.service_class()

        updated_admin = service.update_profile(
            admin_instance=self.admin_user,
            name=serializer.validated_data.get('name'),
            new_password=serializer.validated_data.get('new_password')
        )

        return Response(AdminProfileSerializer(updated_admin).data, status=status.HTTP_200_OK)


================================================================================
文件路径: python-backend\management\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\management\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\map\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\map\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig



class MapConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'map'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\map\context.py
--------------------------------------------------------------------------------

from core.models import Map, Storearea, Facility, Otherarea, Eventarea
from django.db.models import Q
from core.context import BaseContext


class MapContext(BaseContext):
    def __init__(self):
        super().__init__(Map)

    def get_map_with_building(self, map_id):
        """获取地图并预加载建筑信息"""
        try:
            return self.model.objects.select_related('building').get(pk=map_id)
        except self.model.DoesNotExist:
            return None

    @staticmethod
    def get_map_elements(map_obj):
        """一次性获取地图关联的所有元素 ID"""
        # 注意：这里只负责取数据，不负责格式化
        store_ids = map_obj.storeareamap_set.values_list('storearea_id', flat=True)
        facility_ids = map_obj.facilitymap_set.values_list('facility_id', flat=True)
        other_ids = map_obj.otherareamap_set.values_list('otherarea_id', flat=True)
        event_ids = map_obj.eventareamap_set.values_list('eventarea_id', flat=True)
        return store_ids, facility_ids, other_ids, event_ids

    def list_all_with_building(self):
        """获取所有地图列表，并预加载建筑信息"""
        return self.model.objects.select_related('building').all()

    def check_exists(self, building_id, floor_number):
        """检查特定楼层是否存在"""
        return self.model.objects.filter(building_id=building_id, floor_number=floor_number).exists()

    def create_map_record(self, building_id, floor_number, geometry):
        """创建地图记录"""
        return self.create(
            building_id=building_id,
            floor_number=floor_number,
            detail=geometry
        )

class ElementContext:
    """负责处理具体的商铺、设施等元素"""

    @staticmethod
    def get_stores_by_ids(ids):
        return Storearea.objects.filter(id__in=ids)

    @staticmethod
    def get_facilities_by_ids(ids):
        return Facility.objects.filter(id__in=ids)

    @staticmethod
    def get_others_by_ids(ids):
        return Otherarea.objects.filter(id__in=ids)

    @staticmethod
    def get_events_by_ids(ids):
        return Eventarea.objects.filter(id__in=ids)

    @staticmethod
    def search_globally(keyword):
        stores = Storearea.objects.filter(store_name__icontains=keyword)
        others = Otherarea.objects.filter(description__icontains=keyword, is_public=True)
        return stores, others


================================================================================
文件路径: python-backend\map\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from core.models import Map, Storearea, Facility, Otherarea, Eventarea
import json


# ==========================================
# 1. 子元素序列化器 (先定义，供 MapSerializer 调用)
# ==========================================

class OtherareaSerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Otherarea
        # 将 is_public 暴露出来，前端可以用不同颜色渲染
        fields = ['id', 'type', 'description', 'is_public',  'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.shape: return None
        return json.loads(obj.shape.geojson)


class StoreareaSerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Storearea
        fields = ['id', 'store_name', 'type', 'logo_url', 'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.shape: return None
        return json.loads(obj.shape.geojson)


class FacilitySerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Facility
        fields = ['id', 'type', 'description', 'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.location: return None
        return json.loads(obj.location.geojson)


class EventareaSerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Eventarea
        fields = ['id', 'description',  'type', 'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.shape: return None
        return json.loads(obj.shape.geojson)


# ==========================================
# 2. 地图聚合序列化器 (核心修改部分)
# ==========================================

class MapSerializer(serializers.ModelSerializer):
    """
    地图详情：包含该楼层的底图几何信息，以及关联的商铺、设施等。
    """
    building_name = serializers.CharField(source='building.name', read_only=True)
    detail_geojson = serializers.SerializerMethodField()

    # --- 关键修改开始 ---
    # 使用 source='temp_xxx' 对应 MapDisplayService 中挂载的属性名
    # read_only=True 表示这些字段只用于输出，不用于写入
    stores = StoreareaSerializer(source='temp_stores', many=True, read_only=True)
    facilities = FacilitySerializer(source='temp_facilities', many=True, read_only=True)
    other_areas = OtherareaSerializer(source='temp_others', many=True, read_only=True)
    events = EventareaSerializer(source='temp_events', many=True, read_only=True)

    # --- 关键修改结束 ---

    class Meta:
        model = Map
        fields = [
            'id',
            'building_id',
            'building_name',
            'floor_number',
            'detail_geojson',
            # 必须把新字段加入 fields 列表
            'stores',
            'facilities',
            'other_areas',
            'events'
        ]

    @staticmethod
    def get_detail_geojson(obj):
        """
        处理底图几何 (外轮廓 + 镂空)
        """
        if not obj.detail:
            return None

        # 保持原始坐标系 (SRID 2385)，方便前端计算米制距离
        # 如果需要经纬度，需在此处 clone().transform(4326)
        geometry = obj.detail.clone()
        return json.loads(geometry.geojson)


================================================================================
文件路径: python-backend\map\services.py
--------------------------------------------------------------------------------

from django.contrib.gis.geos import GEOSGeometry, Polygon
from typing import Tuple, List
from map.context import MapContext, ElementContext
import json
from django.contrib.gis.geos import GEOSGeometry


# ==========================================
# Part 1: 纯几何算法 (保持不变)
# ==========================================
class GeometryAlgorithms:
    @staticmethod
    def validate_shape_syntax(geometry: GEOSGeometry) -> Tuple[bool, str]:
        if geometry is None: return False, "Geometry is None"
        if not geometry.valid: return False, f"Invalid Geometry: {geometry.valid_reason}"
        if isinstance(geometry, Polygon) and geometry.empty: return False, "Polygon is empty"
        return True, "Valid"

    @staticmethod
    def get_distance_between_areas(shape1: GEOSGeometry, shape2: GEOSGeometry) -> float:
        """
        接口 3: 获取输入的两个区域之间的距离
        """
        if not shape1 or not shape2:
            return -1.0
        # distance() 计算的是两个几何体之间最近点的欧几里得距离
        # 单位取决于 SRID (2385 为米)
        return shape1.distance(shape2)

    @staticmethod
    def validate_holes_inside_shell(outer_shell: GEOSGeometry, holes: List[GEOSGeometry]) -> Tuple[bool, str]:
        """
        接口 2: 镂空本身有无超出外轮廓区域
        """
        if not outer_shell:
            return False, "Outer shell is missing"

        if not holes:
            return True, "No holes to validate"

        for i, hole in enumerate(holes, start=1):
            # hole 必须完全在 outer_shell 内部 (contains)
            # 任何一部分超出或仅仅是相交都算非法
            if not outer_shell.contains(hole):
                return False, f"Hole #{i} is outside or intersecting the map boundary."

        return True, "All holes are valid"

    @staticmethod
    def check_placement(new_shape, outer_shell, holes, existing_obstacles):
        if not outer_shell: return False, "Map shell missing"
        if not outer_shell.contains(new_shape): return False, "Area exceeds map outer boundary"
        for i, hole in enumerate(holes):
            if hole.intersects(new_shape): return False, f"Area intersects with map hole #{i + 1}"
        for existing_shape in existing_obstacles:
            if existing_shape and existing_shape.intersects(new_shape):
                return False, "Area overlaps with an existing area"
        return True, "Placement valid"


# ==========================================
# Part 2: 业务服务 (修改部分)
# ==========================================

class MapDisplayService:
    """
    地图显示与校验服务
    """

    def __init__(self):
        self.map_ctx = MapContext()
        self.elem_ctx = ElementContext()

    def get_full_map_details(self, map_id):
        map_obj = self.map_ctx.get_map_with_building(map_id)
        if not map_obj: return None

        s_ids, f_ids, o_ids, e_ids = self.map_ctx.get_map_elements(map_obj)

        map_obj.temp_stores = self.elem_ctx.get_stores_by_ids(s_ids)
        map_obj.temp_facilities = self.elem_ctx.get_facilities_by_ids(f_ids)
        map_obj.temp_others = self.elem_ctx.get_others_by_ids(o_ids)
        map_obj.temp_events = self.elem_ctx.get_events_by_ids(e_ids)

        return map_obj

    def validate_geometry(self, geometry, map_id, exclude_id=None, area_type=None):
        """
        几何校验业务流程
        """
        # 1. 几何语法校验
        is_valid, msg = GeometryAlgorithms.validate_shape_syntax(geometry)
        if not is_valid:
            return False, msg

        # 2. 获取地图数据
        map_obj = self.map_ctx.get_map_with_building(map_id)
        if not map_obj or not map_obj.detail:
            return False, "Map data not found or empty"

        # 解析外轮廓和镂空
        outer_shell = map_obj.detail[0]
        holes = list(map_obj.detail[1:]) if len(map_obj.detail) > 1 else []

        # 3. 获取所有障碍物 (修改点：在 Service 层组装数据)
        obstacles = self._collect_obstacles(map_obj, exclude_id, area_type)

        # 4. 调用算法进行物理放置校验
        return GeometryAlgorithms.check_placement(
            new_shape=geometry,
            outer_shell=outer_shell,
            holes=holes,
            existing_obstacles=obstacles
        )

    def _collect_obstacles(self, map_obj, exclude_id, area_type) -> List[GEOSGeometry]:
        """
        私有辅助方法：利用 MapContext 和 ElementContext 收集该地图上所有实体的形状
        """
        obstacles = []

        # 1. 从 MapContext 获取所有关联 ID
        s_ids, f_ids, o_ids, e_ids = self.map_ctx.get_map_elements(map_obj)

        # 辅助函数：处理排除逻辑
        def should_include(item_id, item_type):
            # 如果类型相同且 ID 相同，则排除（说明是正在编辑的那个对象）
            if area_type == item_type and str(item_id) == str(exclude_id):
                return False
            return True

        # 2. 从 ElementContext 获取对象并提取形状

        # A. 商铺 (Stores)
        stores = self.elem_ctx.get_stores_by_ids(s_ids)
        for s in stores:
            if should_include(s.id, 'store') and s.shape:
                obstacles.append(s.shape)

        # B. 设施 (Facilities) - 需要 Buffer 处理
        facilities = self.elem_ctx.get_facilities_by_ids(f_ids)
        for f in facilities:
            if should_include(f.id, 'facility') and f.location:
                # 设施通常是点，必须膨胀成多边形才能进行碰撞检测
                # 假设半径 0.5 米
                obstacles.append(f.location.buffer(0.5))

        # C. 其他区域 (Otherareas)
        others = self.elem_ctx.get_others_by_ids(o_ids)
        for o in others:
            if should_include(o.id, 'other') and o.shape:
                obstacles.append(o.shape)

        # D. 活动区域 (Events)
        events = self.elem_ctx.get_events_by_ids(e_ids)
        for e in events:
            if should_include(e.id, 'event') and e.shape and e.is_active:
                obstacles.append(e.shape)

        return obstacles

    def get_map_list(self):
        """
        获取地图列表概要
        """
        # 1. 从 Context 获取所有地图
        maps = self.map_ctx.list_all_with_building()

        # 2. 初始化空属性，防止 MapSerializer 报错
        # (因为列表页通常不需要加载 heavy 的商铺/设施数据，只看底图或基础信息)
        for map_obj in maps:
            map_obj.temp_stores = []
            map_obj.temp_facilities = []
            map_obj.temp_others = []
            map_obj.temp_events = []

        return maps

    def validate_batch(self, map_id, updates_list):
        """
        批量校验
        :param map_id: 地图ID
        :param updates_list: 预处理过的列表，每项包含 'geos_obj' (GEOSGeometry)
        :return: (is_valid, errors_list)
        """
        # 1. 获取地图底图 (外框和镂空)
        map_obj = self.map_ctx.get_map_with_building(map_id)
        if not map_obj or not map_obj.detail:
            return False, ["地图数据缺失"]

        outer_shell = map_obj.detail[0]
        holes = list(map_obj.detail[1:]) if len(map_obj.detail) > 1 else []

        # 2. 整理新数据 (不再需要解析 JSON，直接取对象)
        new_geometries = []
        updated_keys = set()

        for item in updates_list:
            # 直接获取 View 层解析好的几何对象
            shape = item['geos_obj']

            # 统一为多边形用于碰撞检测 (点 -> 圆)
            collision_shape = shape.buffer(0.3) if shape.geom_type == 'Point' else shape

            item_type = str(item.get('type')).lower()
            item_id = str(item.get('id'))

            new_geometries.append({
                'id': item_id,
                'type': item_type,
                'shape': collision_shape,
                'name': item.get('name', 'Unknown')
            })

            key = f"{item_type}-{item_id}"
            updated_keys.add(key)

        # 3. 从数据库获取“背景障碍物” (排除掉在 updated_keys 里的项)
        s_ids, f_ids, o_ids, e_ids = self.map_ctx.get_map_elements(map_obj)
        static_obstacles = []

        def add_static(objects, type_name):
            for obj in objects:
                key = f"{type_name}-{str(obj.id)}"
                if key not in updated_keys:
                    shape = getattr(obj, 'shape', None)
                    if type_name == 'facility':
                        loc = getattr(obj, 'location', None)
                        if loc: shape = loc.buffer(0.3)

                    if shape:
                        static_obstacles.append(shape)

        add_static(self.elem_ctx.get_stores_by_ids(s_ids), 'store')
        add_static(self.elem_ctx.get_facilities_by_ids(f_ids), 'facility')
        add_static(self.elem_ctx.get_others_by_ids(o_ids), 'other')
        active_events = [e for e in self.elem_ctx.get_events_by_ids(e_ids) if e.is_active]
        add_static(active_events, 'event')

        # 4. 执行校验
        errors = []

        for curr in new_geometries:
            curr_shape = curr['shape']

            # 4.1 边界检查
            if not outer_shell.contains(curr_shape):
                errors.append(f"[{curr['name']}] 超出地图边界")
                continue

            for hole in holes:
                if hole.intersects(curr_shape) and not hole.touches(curr_shape):
                    errors.append(f"[{curr['name']}] 进入了地图镂空/中庭区域")
                    break

            # 4.2 静态障碍物碰撞
            for obs in static_obstacles:
                if obs.intersects(curr_shape) and not obs.touches(curr_shape):
                    errors.append(f"[{curr['name']}] 与未修改的固定区域重叠")
                    break

            # 4.3 动态物体互撞 (A 撞 B)
            for other in new_geometries:
                if curr['id'] == other['id'] and curr['type'] == other['type']:
                    continue

                if curr['type'] == 'facility' and other['type'] == 'facility':
                    continue

                if other['shape'].intersects(curr_shape) and not other['shape'].touches(curr_shape):
                    if curr['id'] < other['id']:
                        errors.append(f"[{curr['name']}] 与 [{other['name']}] 重叠")
                    break

        if len(errors) > 0:
            return False, errors

        return True, []


================================================================================
文件路径: python-backend\map\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.
from rest_framework.test import APITestCase
from rest_framework import status
from django.urls import reverse
from django.contrib.gis.geos import Polygon, GeometryCollection
from core.models import Building, Map, Storearea, StoreareaMap


class MapViewSetTestCase(APITestCase):
    """
    测试 MapViewSet 的 list 和 retrieve 接口
    验证从数据库到 Service 再到 View 的数据流是否正常
    """

    def setUp(self):
        """
        测试数据准备：
        1. 创建 Building
        2. 创建 Map (带 GeometryCollection)
        3. 创建 Storearea (带 Polygon)
        4. 建立 Map 和 Storearea 的关联
        """
        # 1. 创建建筑
        self.building = Building.objects.create(
            name="测试万达广场",
            address="上海市杨浦区"
        )

        # 2. 创建地图底图几何 (SRID 2385)
        # 假设是一个 100x100 的正方形外轮廓
        outer_shell = Polygon(((0, 0), (0, 100), (100, 100), (100, 0), (0, 0)), srid=2385)
        # detail 字段是 GeometryCollection
        map_detail = GeometryCollection(outer_shell, srid=2385)

        self.map_obj = Map.objects.create(
            building=self.building,
            floor_number=1,
            detail=map_detail
        )

        # 3. 创建商铺
        # 在地图内部创建一个 10x10 的小方块商铺
        store_shape = Polygon(((10, 10), (10, 20), (20, 20), (20, 10), (10, 10)), srid=2385)
        self.store = Storearea.objects.create(
            store_name="测试海底捞",
            type=1,
            shape=store_shape,
            owner_name="张三",
            owner_phone="123456",
            is_active = True
        )

        # 4. 关联商铺到地图 (重要：否则 retrieve 接口不会返回该商铺)
        StoreareaMap.objects.create(
            map=self.map_obj,
            storearea=self.store
        )

        # 路由名称定义 (对应 urls.py 中的 router.register(..., basename='maps'))
        self.list_url = reverse('map-list')
        self.detail_url = reverse('map-detail', args=[self.map_obj.id])

    def test_list_maps(self):
        """
        测试获取地图列表 (GET /api/maps/)
        """
        response = self.client.get(self.list_url)

        # 1. 验证状态码
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        # 2. 验证返回数据类型是列表
        self.assertIsInstance(response.data, list)
        self.assertEqual(len(response.data), 1)

        # 3. 验证基础字段
        map_data = response.data[0]
        self.assertEqual(map_data['floor_number'], 1)
        self.assertEqual(map_data['building_name'], "测试万达广场")

        # 4. 验证列表接口是否正确处理了 temp_stores (应该为空列表或不报错)
        # 根据我们之前的 Service 逻辑，列表接口为了性能可能没有加载 stores，或者加载了空列表
        if 'stores' in map_data:
            self.assertIsInstance(map_data['stores'], list)

    def test_retrieve_map_success(self):
        """
        测试获取单张地图详情 (GET /api/maps/{id}/)
        核心：验证 Service 是否成功组装了 detail_geojson 和 stores
        """
        response = self.client.get(self.detail_url)

        # 1. 验证状态码
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        data = response.data

        # 2. 验证底图几何 (detail_geojson)
        self.assertIn('detail_geojson', data)
        self.assertEqual(data['detail_geojson']['type'], 'GeometryCollection')

        # 3. 验证关联元素 (stores)
        # 这是验证 MapDisplayService.get_full_map_details 逻辑的关键
        self.assertIn('stores', data)
        self.assertEqual(len(data['stores']), 1)

        store_data = data['stores'][0]
        self.assertEqual(store_data['store_name'], "测试海底捞")
        self.assertEqual(store_data['id'], self.store.id)

        # 验证商铺的几何是否被正确序列化为 GeoJSON
        self.assertIn('geometry', store_data)
        self.assertEqual(store_data['geometry']['type'], 'Polygon')

        # 4. 验证其他空列表字段是否存在 (facilities, events, etc.)
        self.assertIn('facilities', data)
        self.assertEqual(data['facilities'], [])  # setUp中没创建设施，应为空列表

    def test_retrieve_map_not_found(self):
        """
        测试获取不存在的地图 ID
        """
        non_existent_url = reverse('map-detail', args=[99999])
        response = self.client.get(non_existent_url)

        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)


================================================================================
文件路径: python-backend\map\views.py
--------------------------------------------------------------------------------

from rest_framework import viewsets, status
from rest_framework.views import APIView
from rest_framework.response import Response
from django.contrib.gis.geos import GEOSGeometry
import json

from .serializers import MapSerializer  # 序列化器依然需要，用于格式化输出
from map.services import MapDisplayService


class MapViewSet(viewsets.ViewSet):
    """
    只读 ViewSet，不继承 ModelViewSet
    """
    service_class = MapDisplayService

    def list(self, request):
        """GET /api/maps/"""
        service = self.service_class()

        # 1. 调用 Service 获取列表
        maps = service.get_map_list()

        # 2. 序列化返回
        # 注意：这里会返回所有地图的 GeoJSON，数据量可能较大
        # 实际生产中建议单独定义一个 SimpleMapSerializer (不含 detail_geojson) 用于列表
        serializer = MapSerializer(maps, many=True)

        return Response(serializer.data)

    def retrieve(self, request, pk=None):
        """GET /api/maps/{id}/"""
        service = self.service_class()

        # 1. 调用 Service 获取组装好的对象
        map_data = service.get_full_map_details(pk)

        if not map_data:
            return Response({"error": "Map not found"}, status=status.HTTP_404_NOT_FOUND)

        # 2. 使用 Serializer 格式化 Service 返回的数据
        # 注意：Serializer 内部字段 source='temp_stores' 需要对应 Service 挂载的属性
        serializer = MapSerializer(map_data)
        return Response(serializer.data)


class MapValidationView(APIView):
    """POST /api/maps/validate/"""
    service_class = MapDisplayService

    def post(self, request):
        service = self.service_class()

        # 1. 参数提取
        geometry_data = request.data.get('geometry')
        map_id = request.data.get('map_id')
        area_type = request.data.get('type')
        exclude_id = request.data.get('exclude_id')

        # 2. 数据预处理
        try:
            shape_str = json.dumps(geometry_data) if isinstance(geometry_data, dict) else geometry_data
            shape = GEOSGeometry(shape_str)
            if shape.srid != 2385: shape.srid = 2385
        except Exception:
            return Response({"error": "Invalid Geometry"}, status=400)

        # 3. 调用 Service 业务逻辑
        is_valid, reason = service.validate_geometry(shape, map_id, exclude_id, area_type)

        return Response({"valid": is_valid, "reason": reason})


class MapBatchValidationView(APIView):
    """POST /api/maps/validate_batch/ (批量校验)"""
    service_class = MapDisplayService

    def post(self, request):
        service = self.service_class()

        map_id = request.data.get('map_id')
        updates = request.data.get('updates', [])

        if not map_id:
            return Response({"error": "map_id is required"}, status=status.HTTP_400_BAD_REQUEST)

        # --- 数据预处理：在 View 层统一解析几何并修正 SRID ---
        processed_updates = []
        for i, item in enumerate(updates):
            try:
                # 1. 提取原始数据
                raw_geo = item.get('geometry') or item.get('location')
                if not raw_geo: continue

                # 2. 转字符串
                shape_str = json.dumps(raw_geo) if isinstance(raw_geo, dict) else raw_geo

                # 3. 解析几何
                shape = GEOSGeometry(shape_str)

                # 4. 强制修正 SRID (与 MapValidationView 保持一致)
                if shape.srid != 2385:
                    shape.srid = 2385

                # 5. 将处理好的 GEOSGeometry 对象注入 item
                # 使用一个新的 key 'geos_obj' 传递给 Service
                item['geos_obj'] = shape
                processed_updates.append(item)

            except Exception as e:
                # 如果解析失败，直接返回 400，中断处理
                return Response(
                    {"error": f"Invalid geometry at index {i} (ID: {item.get('id')}): {str(e)}"},
                    status=status.HTTP_400_BAD_REQUEST
                )

        # 调用 Service，传入包含 GEOSGeometry 对象的列表
        is_valid, errors = service.validate_batch(map_id, processed_updates)

        return Response({
            "valid": is_valid,
            "errors": errors
        })


================================================================================
文件路径: python-backend\map\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\map\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\python_backend\settings.py
--------------------------------------------------------------------------------

"""
Django settings for python_backend project.

Based on by 'django-admin startproject' using Django 2.1.2.

For more information on this file, see
https://docs.djangoproject.com/en/2.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/2.1/ref/settings/
"""

import os
import posixpath

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/2.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = '7306ec88-3719-40e9-88d4-2d6fdee59734'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ['*']

# Application references
# https://docs.djangoproject.com/en/2.1/ref/settings/#std:setting-INSTALLED_APPS
INSTALLED_APPS = [
    # Add your apps here to enable them
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.gis',
    'rest_framework',
    'django_filters',
    # 支持跨域请求
    'corsheaders',
    'core.apps.CoreConfig',
    'map.apps.MapConfig',
    'client.apps.ClientConfig',
    'management.apps.ManagementConfig',
    'search.apps.SearchConfig',
    'guide.apps.GuideConfig',
    'editor.apps.EditorConfig'
]

# Middleware framework
# https://docs.djangoproject.com/en/2.1/topics/http/middleware/
MIDDLEWARE = [
    # CORS middleware should be placed as high as possible
    'corsheaders.middleware.CorsMiddleware',
    # 注意：确保 CommonMiddleware 仍然在 CorsMiddleware 之后
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'python_backend.urls'

# Template configuration
# https://docs.djangoproject.com/en/2.1/topics/templates/
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'python_backend.wsgi.application'

# Database
# https://docs.djangoproject.com/en/2.1/ref/settings/#databases
DATABASES = {
    'default': {
        'ENGINE': 'django.contrib.gis.db.backends.postgis',
        'NAME': os.environ.get('POSTGRES_DB'),
        'USER': os.environ.get('POSTGRES_USER'),
        'PASSWORD': os.environ.get('POSTGRES_PASSWORD'),
        'HOST': 'postgres-db',
        'PORT': '5432',
    }
}

# Password validation
# https://docs.djangoproject.com/en/2.1/ref/settings/#auth-password-validators
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Internationalization
# https://docs.djangoproject.com/en/2.1/topics/i18n/
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_L10N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/2.1/howto/static-files/
STATIC_URL = '/static/'
STATIC_ROOT = posixpath.join(*(BASE_DIR.split(os.path.sep) + ['static']))

REST_FRAMEWORK = {
    # 默认权限设置：这里设置为默认需要登录才能访问，方便后续开发
    'DEFAULT_PERMISSION_CLASSES': [
        # 'rest_framework.permissions.IsAuthenticated',
        # 如果是开发初期想全部公开，可以改为:
        'rest_framework.permissions.AllowAny',
    ],

    # 默认认证方式
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
    ],

    # 默认分页设置 (推荐配置，防止大数据量查死数据库)
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,

    # 统一日期格式 (可选)
    'DATETIME_FORMAT': '%Y-%m-%d %H:%M:%S',
}

# CORS 设置（开发环境方便测试，生产请按需限制）
CORS_ALLOWED_ORIGINS = [
  "http://localhost:8080"
]
CORS_ALLOW_CREDENTIALS = True
# 可根据需要自定义允许的头、方法
# CORS_ALLOW_HEADERS = list(default_headers) + [
#     'your-custom-header',
# ]



================================================================================
文件路径: python-backend\python_backend\urls.py
--------------------------------------------------------------------------------

"""
python_backend URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/2.1/topics/http/urls/

Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""

# Uncomment next two lines to enable admin:
from django.contrib import admin
from django.urls import path,include
from rest_framework.routers import DefaultRouter
from map.views import MapViewSet, MapValidationView, MapBatchValidationView

from guide.views import RoutePlanView

from management.views import AdminAuthView, AdminProfileView


router = DefaultRouter()
router.register(r'maps', MapViewSet, basename='map')
urlpatterns = [
    path('search/', include('search.urls')),
    path('api/editor/', include('editor.urls')),
    path('api/management/', include('management.urls')),
    # Uncomment the next line to enable the admin:
    #path('admin/', admin.site.urls)
    path('api/maps/validate/', MapValidationView.as_view(), name='map-validate'),
    path('api/maps/validate_batch/', MapBatchValidationView.as_view(), name='map-validate-batch'),
    path('api/guide/route/',RoutePlanView.as_view(), name='route-plan'),
    path('api/', include(router.urls)),
    path('api/management/auth/<str:action>/', AdminAuthView.as_view(), name='admin-auth'),
    path('api/management/profile/', AdminProfileView.as_view(), name='admin-profile'),
    path('admin/', admin.site.urls),
    path('api/search/', include('search.urls')),
    # 其他URL配置...
]



================================================================================
文件路径: python-backend\python_backend\wsgi.py
--------------------------------------------------------------------------------

"""
WSGI config for python_backend project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

For more information, visit
https://docs.djangoproject.com/en/2.1/howto/deployment/wsgi/
"""

import os

import django
from django.core.wsgi import get_wsgi_application

os.environ.setdefault(
    'DJANGO_SETTINGS_MODULE',
    'python_backend.settings')
django.setup()

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
application = get_wsgi_application()



================================================================================
文件路径: python-backend\python_backend\__init__.py
--------------------------------------------------------------------------------

"""
Package for python_backend.
"""



================================================================================
文件路径: python-backend\search\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\search\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class SearchConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'search'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\search\context.py
--------------------------------------------------------------------------------

from django.apps import apps
from django.db.models import Q


class BaseSearchContext:
    """基础搜索上下文类"""

    def __init__(self, model_name):
        self.model_name = model_name
        self.model = apps.get_model('core', model_name)


class StoreareaContext(BaseSearchContext):
    """店铺区域上下文"""

    def __init__(self):
        super().__init__('Storearea')

    def get_by_id(self, storearea_id):
        """根据ID获取店铺区域"""
        try:
            return self.model.objects.get(id=storearea_id)
        except self.model.DoesNotExist:
            return None

    def search_by_name(self, name):
        """根据名称搜索店铺区域"""
        return self.model.objects.filter(
            store_name__icontains=name,
            is_active=True
        )

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选店铺区域"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_storearea_map_relations(self, storearea_id):
        """获取店铺区域的地图关联"""
        StoreareaMap = apps.get_model('core', 'StoreareaMap')
        return StoreareaMap.objects.filter(storearea_id=storearea_id)


class EventContext(BaseSearchContext):
    """活动上下文"""

    def __init__(self):
        super().__init__('Event')

    def get_by_id(self, event_id):
        """根据ID获取活动"""
        try:
            return self.model.objects.get(id=event_id)
        except self.model.DoesNotExist:
            return None

    def search_by_name(self, name):
        """根据名称搜索活动"""
        return self.model.objects.filter(
            event_name__icontains=name,
            is_active=True
        )

    def filter_active_events(self):
        """获取所有活跃活动"""
        return self.model.objects.filter(is_active=True)

    def get_event_storearea_relations(self, event_id):
        """获取活动的店铺区域关联"""
        EventStorearea = apps.get_model('core', 'EventStorearea')
        return EventStorearea.objects.filter(event_id=event_id)

    def get_event_eventarea_relations(self, event_id):
        """获取活动的活动区域关联"""
        EventEventarea = apps.get_model('core', 'EventEventarea')
        return EventEventarea.objects.filter(event_id=event_id)


class EventareaContext(BaseSearchContext):
    """活动区域上下文"""

    def __init__(self):
        super().__init__('Eventarea')

    def get_by_id(self, eventarea_id):
        """根据ID获取活动区域"""
        try:
            return self.model.objects.get(id=eventarea_id)
        except self.model.DoesNotExist:
            return None

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选活动区域"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_eventarea_map_relations(self, eventarea_id):
        """获取活动区域的地图关联"""
        EventareaMap = apps.get_model('core', 'EventareaMap')
        return EventareaMap.objects.filter(eventarea_id=eventarea_id)

    def get_eventarea_map_relations_by_map(self, map_id):
        """根据地图ID获取活动区域关联"""
        EventareaMap = apps.get_model('core', 'EventareaMap')
        return EventareaMap.objects.filter(map_id=map_id)


class FacilityContext(BaseSearchContext):
    """设施上下文"""

    def __init__(self):
        super().__init__('Facility')

    def get_by_id(self, facility_id):
        """根据ID获取设施"""
        try:
            return self.model.objects.get(id=facility_id)
        except self.model.DoesNotExist:
            return None

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选设施"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_facility_map_relations(self, facility_id):
        """获取设施的地图关联"""
        FacilityMap = apps.get_model('core', 'FacilityMap')
        return FacilityMap.objects.filter(facility_id=facility_id)

    def get_facility_map_relations_by_map(self, map_id):
        """根据地图ID获取设施关联"""
        FacilityMap = apps.get_model('core', 'FacilityMap')
        return FacilityMap.objects.filter(map_id=map_id)


class OtherareaContext(BaseSearchContext):
    """其他区域上下文"""

    def __init__(self):
        super().__init__('Otherarea')

    def get_by_id(self, otherarea_id):
        """根据ID获取其他区域"""
        try:
            return self.model.objects.get(id=otherarea_id)
        except self.model.DoesNotExist:
            return None

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选其他区域"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_otherarea_map_relations(self, otherarea_id):
        """获取其他区域的地图关联"""
        OtherareaMap = apps.get_model('core', 'OtherareaMap')
        return OtherareaMap.objects.filter(otherarea_id=otherarea_id)

    def get_otherarea_map_relations_by_map(self, map_id):
        """根据地图ID获取其他区域关联"""
        OtherareaMap = apps.get_model('core', 'OtherareaMap')
        return OtherareaMap.objects.filter(map_id=map_id)


class SearchElementContext:
    """搜索元素上下文，用于处理关联关系"""

    @staticmethod
    def get_storearea_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取店铺区域ID"""
        StoreareaMap = apps.get_model('core', 'StoreareaMap')
        Storearea = apps.get_model('core', 'Storearea')

        # 获取该地图的所有storearea关联
        storearea_maps = StoreareaMap.objects.filter(map_id=map_id)
        storearea_ids = [sm.storearea_id for sm in storearea_maps]

        # 如果提供了类型参数，则进一步过滤
        if type_id is not None:
            storeareas = Storearea.objects.filter(
                id__in=storearea_ids,
                type=type_id,
                is_active=True
            )
            storearea_ids = [storearea.id for storearea in storeareas]

        return storearea_ids

    @staticmethod
    def get_eventarea_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取活动区域ID"""
        EventareaMap = apps.get_model('core', 'EventareaMap')
        Eventarea = apps.get_model('core', 'Eventarea')

        eventarea_maps = EventareaMap.objects.filter(map_id=map_id)
        eventarea_ids = [em.eventarea_id for em in eventarea_maps]

        if type_id is not None:
            eventareas = Eventarea.objects.filter(
                id__in=eventarea_ids,
                type=type_id,
                is_active=True
            )
            eventarea_ids = [eventarea.id for eventarea in eventareas]

        return eventarea_ids

    @staticmethod
    def get_facility_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取设施ID"""
        FacilityMap = apps.get_model('core', 'FacilityMap')
        Facility = apps.get_model('core', 'Facility')

        facility_maps = FacilityMap.objects.filter(map_id=map_id)
        facility_ids = [fm.facility_id for fm in facility_maps]

        if type_id is not None:
            facilities = Facility.objects.filter(
                id__in=facility_ids,
                type=type_id,
                is_active=True
            )
            facility_ids = [facility.id for facility in facilities]

        return facility_ids

    @staticmethod
    def get_otherarea_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取其他区域ID"""
        OtherareaMap = apps.get_model('core', 'OtherareaMap')
        Otherarea = apps.get_model('core', 'Otherarea')

        otherarea_maps = OtherareaMap.objects.filter(map_id=map_id)
        otherarea_ids = [om.otherarea_id for om in otherarea_maps]

        if type_id is not None:
            otherareas = Otherarea.objects.filter(
                id__in=otherarea_ids,
                type=type_id,
                is_active=True
            )
            otherarea_ids = [otherarea.id for otherarea in otherareas]

        return otherarea_ids


================================================================================
文件路径: python-backend\search\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from django.apps import apps


# 使用延迟加载的方式定义序列化器
def get_storearea_serializer():
    Storearea = apps.get_model('core', 'Storearea')

    class StoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            fields = '__all__'

    return StoreareaSerializer


def get_event_serializer():
    Event = apps.get_model('core', 'Event')

    class EventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = '__all__'

    return EventSerializer


def get_eventarea_serializer():
    Eventarea = apps.get_model('core', 'Eventarea')

    class EventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            fields = '__all__'

    return EventareaSerializer


def get_facility_serializer():
    Facility = apps.get_model('core', 'Facility')

    class FacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            fields = '__all__'

    return FacilitySerializer


def get_otherarea_serializer():
    Otherarea = apps.get_model('core', 'Otherarea')

    class OtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            fields = '__all__'

    return OtherareaSerializer


def get_simple_storearea_serializer():
    Storearea = apps.get_model('core', 'Storearea')

    class SimpleStoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            fields = ['id', 'store_name', 'type']

    return SimpleStoreareaSerializer


def get_simple_event_serializer():
    Event = apps.get_model('core', 'Event')

    class SimpleEventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = ['id', 'event_name', 'start_date', 'end_date']

    return SimpleEventSerializer


def get_simple_eventarea_serializer():
    Eventarea = apps.get_model('core', 'Eventarea')

    class SimpleEventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            fields = ['id', 'organizer_name', 'type']

    return SimpleEventareaSerializer


def get_simple_facility_serializer():
    Facility = apps.get_model('core', 'Facility')

    class SimpleFacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            fields = ['id', 'type']

    return SimpleFacilitySerializer


def get_simple_otherarea_serializer():
    Otherarea = apps.get_model('core', 'Otherarea')

    class SimpleOtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            fields = ['id', 'type', 'is_public']

    return SimpleOtherareaSerializer



================================================================================
文件路径: python-backend\search\services.py
--------------------------------------------------------------------------------

from rest_framework import status
from django.apps import apps
from .context import (
    StoreareaContext, EventContext, EventareaContext,
    FacilityContext, OtherareaContext, SearchElementContext
)


class SearchService:
    """搜索服务"""

    def __init__(self):
        self.storearea_ctx = StoreareaContext()
        self.event_ctx = EventContext()
        self.eventarea_ctx = EventareaContext()
        self.facility_ctx = FacilityContext()
        self.otherarea_ctx = OtherareaContext()
        self.element_ctx = SearchElementContext()

    # ========== 店铺搜索功能 ==========

    def get_storearea_by_id(self, storearea_id):
        """获取ID为<>的商铺区域的所有信息"""
        storearea = self.storearea_ctx.get_by_id(storearea_id)
        if not storearea:
            return None, {'error': 'Storearea not found'}, status.HTTP_404_NOT_FOUND
        return storearea, None, None

    def search_storearea_by_name(self, name):
        """按名称寻找店铺区域"""
        if not name:
            return None, {'error': 'Name parameter is required'}, status.HTTP_400_BAD_REQUEST
        storeareas = self.storearea_ctx.search_by_name(name)
        return storeareas, None, None

    def list_storearea_by_type(self, type_param):
        """返回指定类型店铺区域列表"""
        if type_param:
            try:
                type_id = int(type_param)
                storeareas = self.storearea_ctx.filter_by_type(type_id=type_id)
                return storeareas, {'type': type_id}, None
            except ValueError:
                return None, {'error': 'Invalid type parameter'}, status.HTTP_400_BAD_REQUEST
        else:
            storeareas = self.storearea_ctx.filter_by_type()
            return storeareas, None, None

    def get_storearea_events(self, storearea_id):
        """返回指定店铺区域的所有活动ID列表"""
        storearea = self.storearea_ctx.get_by_id(storearea_id)
        if not storearea or not storearea.is_active:
            return None, {'error': 'Storearea not found'}, status.HTTP_404_NOT_FOUND

        EventStorearea = apps.get_model('core', 'EventStorearea')
        event_relations = EventStorearea.objects.filter(storearea_id=storearea_id)
        event_ids = [relation.event_id for relation in event_relations]

        return {'storearea_id': storearea_id, 'event_ids': event_ids}, None, None

    def get_storearea_map_ids(self, storearea_id):
        """获取storearea_id为<>的活动区域所属的map_id"""
        storearea_maps = self.storearea_ctx.get_storearea_map_relations(storearea_id)
        map_ids = [storearea_map.map_id for storearea_map in storearea_maps]
        return {'storearea_id': storearea_id, 'map_ids': map_ids}, None, None

    def get_storearea_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且type为<>的所有storearea的id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            storearea_ids = self.element_ctx.get_storearea_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'storearea_ids': storearea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_all_storearea_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有storearea_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            storearea_ids = self.element_ctx.get_storearea_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'storearea_ids': storearea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST

    # ========== 活动搜索功能 ==========

    def get_event_by_id(self, event_id):
        """按ID寻找活动"""
        event = self.event_ctx.get_by_id(event_id)
        if not event:
            return None, {'error': 'Event not found'}, status.HTTP_404_NOT_FOUND
        return event, None, None

    def search_event_by_name(self, name):
        """按名称寻找活动"""
        if not name:
            return None, {'error': 'Name parameter is required'}, status.HTTP_400_BAD_REQUEST
        events = self.event_ctx.search_by_name(name)
        return events, None, None

    def list_event_by_type(self, type_param):
        """返回指定类型活动列表"""
        events = self.event_ctx.filter_active_events()

        if type_param:
            try:
                type_id = int(type_param)
                EventEventarea = apps.get_model('core', 'EventEventarea')
                event_ids = EventEventarea.objects.filter(
                    eventarea__type=type_id
                ).values_list('event_id', flat=True).distinct()

                events = events.filter(id__in=event_ids)
                return events, {'type': type_id}, None
            except ValueError:
                return None, {'error': 'Invalid type parameter'}, status.HTTP_400_BAD_REQUEST
        else:
            return events, None, None

    def get_event_areas(self, event_id):
        """返回参加该活动的区域ID列表"""
        event = self.event_ctx.get_by_id(event_id)
        if not event:
            return None, {'error': 'Event not found'}, status.HTTP_404_NOT_FOUND

        storearea_relations = self.event_ctx.get_event_storearea_relations(event_id)
        storearea_ids = [relation.storearea_id for relation in storearea_relations]

        eventarea_relations = self.event_ctx.get_event_eventarea_relations(event_id)
        eventarea_ids = [relation.eventarea_id for relation in eventarea_relations]

        result = {
            'event_id': event_id,
            'storearea_ids': storearea_ids,
            'eventarea_ids': eventarea_ids,
            'all_area_ids': storearea_ids + eventarea_ids
        }
        return result, None, None

    # ========== 活动区域功能 ==========

    def get_eventarea_by_id(self, eventarea_id):
        """获取id为<>的活动区域的所有信息"""
        eventarea = self.eventarea_ctx.get_by_id(eventarea_id)
        if not eventarea:
            return None, {'error': 'Eventarea not found'}, status.HTTP_404_NOT_FOUND
        return eventarea, None, None

    def get_eventarea_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且 type为<>的所有eventarea的id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            eventarea_ids = self.element_ctx.get_eventarea_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'eventarea_ids': eventarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_eventarea_map_ids(self, eventarea_id):
        """获取eventarea_id为<>的活动区域所属的map_id"""
        eventarea_maps = self.eventarea_ctx.get_eventarea_map_relations(eventarea_id)
        map_ids = [eventarea_map.map_id for eventarea_map in eventarea_maps]
        return {'eventarea_id': eventarea_id, 'map_ids': map_ids}, None, None

    def get_all_eventarea_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有eventarea_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            eventarea_ids = self.element_ctx.get_eventarea_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'eventarea_ids': eventarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST

    # ========== 设施功能 ==========

    def get_facility_by_id(self, facility_id):
        """获取id为<>的设施的所有信息"""
        facility = self.facility_ctx.get_by_id(facility_id)
        if not facility:
            return None, {'error': 'Facility not found'}, status.HTTP_404_NOT_FOUND
        return facility, None, None

    def get_facility_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且type为<>的所有设施id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            facility_ids = self.element_ctx.get_facility_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'facility_ids': facility_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_facility_map_ids(self, facility_id):
        """获取facility_id为<>的活动区域所属的map_id"""
        facility_maps = self.facility_ctx.get_facility_map_relations(facility_id)
        map_ids = [facility_map.map_id for facility_map in facility_maps]
        return {'facility_id': facility_id, 'map_ids': map_ids}, None, None

    def get_all_facility_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有facility_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            facility_ids = self.element_ctx.get_facility_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'facility_ids': facility_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST

    # ========== 其他区域功能 ==========

    def get_otherarea_by_id(self, otherarea_id):
        """获取id为<>的其他区域的所有信息"""
        otherarea = self.otherarea_ctx.get_by_id(otherarea_id)
        if not otherarea:
            return None, {'error': 'Otherarea not found'}, status.HTTP_404_NOT_FOUND
        return otherarea, None, None

    def get_otherarea_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且type为<>的所有otherarea的id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            otherarea_ids = self.element_ctx.get_otherarea_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'otherarea_ids': otherarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_otherarea_map_ids(self, otherarea_id):
        """获取otherarea_id为<>的活动区域所属的map_id"""
        otherarea_maps = self.otherarea_ctx.get_otherarea_map_relations(otherarea_id)
        map_ids = [otherarea_map.map_id for otherarea_map in otherarea_maps]
        return {'otherarea_id': otherarea_id, 'map_ids': map_ids}, None, None

    def get_all_otherarea_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有otherarea_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            otherarea_ids = self.element_ctx.get_otherarea_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'otherarea_ids': otherarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST


================================================================================
文件路径: python-backend\search\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\search\urls.py
--------------------------------------------------------------------------------

from django.urls import path
from . import views

urlpatterns = [
    # Search店铺功能
    path('storearea/<int:storearea_id>/', views.storearea_by_id, name='storearea-by-id'),
    path('storearea/search/', views.storearea_search, name='storearea-search'),
    path('storearea/list/', views.storearea_list_by_type, name='storearea-list-by-type'),
    path('storearea/<int:storearea_id>/events/', views.storearea_events, name='storearea-events'),

    # 新增的店铺区域功能
    path('storearea/<int:storearea_id>/map/', views.storearea_map_ids, name='storearea-map-ids'),
    path('storearea/list/map/', views.storearea_ids_by_map_and_type, name='storearea-ids-by-map-type'),
    path('storearea/list/all_by_map/', views.all_storearea_ids_by_map, name='all-storearea-ids-by-map'),

    # Search活动功能
    path('event/<int:event_id>/', views.event_by_id, name='event-by-id'),
    path('event/search/', views.event_search, name='event-search'),
    path('event/list/', views.event_list_by_type, name='event-list-by-type'),
    path('event/<int:event_id>/areas/', views.event_areas, name='event-areas'),

    # 新增的活动区域功能
    path('eventarea/<int:eventarea_id>/', views.eventarea_by_id, name='eventarea-by-id'),
    path('eventarea/list/ids_by_map_type/', views.eventarea_ids_by_map_and_type, name='eventarea-ids-by-map-type'),
    path('eventarea/<int:eventarea_id>/map/', views.eventarea_map_ids, name='eventarea-map-ids'),
    path('eventarea/list/all_by_map/', views.all_eventarea_ids_by_map, name='all-eventarea-ids-by-map'),

    # 新增的设施功能
    path('facility/<int:facility_id>/', views.facility_by_id, name='facility-by-id'),
    path('facility/list/ids_by_map_type/', views.facility_ids_by_map_and_type, name='facility-ids-by-map-type'),
    path('facility/<int:facility_id>/map/', views.facility_map_ids, name='facility-map-ids'),
    path('facility/list/all_by_map/', views.all_facility_ids_by_map, name='all-facility-ids-by-map'),

    # 新增的其他区域功能
    path('otherarea/<int:otherarea_id>/', views.otherarea_by_id, name='otherarea-by-id'),
    path('otherarea/list/ids_by_map_type/', views.otherarea_ids_by_map_and_type, name='otherarea-ids-by-map-type'),
    path('otherarea/<int:otherarea_id>/map/', views.otherarea_map_ids, name='otherarea-map-ids'),
    path('otherarea/list/all_by_map/', views.all_otherarea_ids_by_map, name='all-otherarea-ids-by-map'),
]


================================================================================
文件路径: python-backend\search\views.py
--------------------------------------------------------------------------------

from rest_framework.decorators import api_view
from rest_framework.response import Response
from .services import SearchService
from .serializers import (
    get_storearea_serializer, get_simple_storearea_serializer,
    get_event_serializer, get_simple_event_serializer,
    get_eventarea_serializer, get_simple_eventarea_serializer,
    get_facility_serializer, get_simple_facility_serializer,
    get_otherarea_serializer, get_simple_otherarea_serializer
)

search_service = SearchService()


# ========== 店铺搜索功能 ==========

@api_view(['GET'])
def storearea_by_id(request, storearea_id):
    """获取id为<>的商铺区域的所有信息"""
    result, error, status_code = search_service.get_storearea_by_id(storearea_id)
    if error:
        return Response(error, status=status_code)

    StoreareaSerializer = get_storearea_serializer()
    serializer = StoreareaSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def storearea_search(request):
    """按名称寻找店铺区域"""
    name = request.GET.get('name', '').strip()
    result, error, status_code = search_service.search_storearea_by_name(name)
    if error:
        return Response(error, status=status_code)

    StoreareaSerializer = get_storearea_serializer()
    serializer = StoreareaSerializer(result, many=True)
    return Response(serializer.data)


@api_view(['GET'])
def storearea_list_by_type(request):
    """返回指定类型店铺区域列表"""
    type_param = request.GET.get('type', '').strip()
    result, extra, error = search_service.list_storearea_by_type(type_param)
    if error:
        return Response(error, status=extra)

    if type_param:
        StoreareaSerializer = get_storearea_serializer()
        serializer = StoreareaSerializer(result, many=True)
        response_data = {'type': extra['type'], 'storeareas': serializer.data}
    else:
        categorized = {}
        SimpleStoreareaSerializer = get_simple_storearea_serializer()
        for storearea in result:
            type_key = storearea.type or 0
            if type_key not in categorized:
                categorized[type_key] = []
            serializer = SimpleStoreareaSerializer(storearea)
            categorized[type_key].append(serializer.data)
        response_data = categorized

    return Response(response_data)


@api_view(['GET'])
def storearea_events(request, storearea_id):
    """返回指定店铺区域的所有活动ID列表"""
    result, error, status_code = search_service.get_storearea_events(storearea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def storearea_map_ids(request, storearea_id):
    """获取storearea_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_storearea_map_ids(storearea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def storearea_ids_by_map_and_type(request):
    """获取map_id为<> 且type为<>的所有storearea的id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_storearea_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_storearea_ids_by_map(request):
    """获取map_id为<>的地图对应的所有storearea_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_storearea_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 活动搜索功能 ==========

@api_view(['GET'])
def event_by_id(request, event_id):
    """按ID寻找活动"""
    result, error, status_code = search_service.get_event_by_id(event_id)
    if error:
        return Response(error, status=status_code)

    EventSerializer = get_event_serializer()
    serializer = EventSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def event_search(request):
    """按名称寻找活动"""
    name = request.GET.get('name', '').strip()
    result, error, status_code = search_service.search_event_by_name(name)
    if error:
        return Response(error, status=status_code)

    EventSerializer = get_event_serializer()
    serializer = EventSerializer(result, many=True)
    return Response(serializer.data)


@api_view(['GET'])
def event_list_by_type(request):
    """返回指定类型活动列表"""
    type_param = request.GET.get('type', '').strip()
    result, extra, error = search_service.list_event_by_type(type_param)
    if error:
        return Response(error, status=extra)

    if type_param:
        EventSerializer = get_event_serializer()
        serializer = EventSerializer(result, many=True)
        response_data = {'type': extra['type'], 'events': serializer.data}
    else:
        categorized = {}
        SimpleEventSerializer = get_simple_event_serializer()

        for event in result:
            # 获取该活动关联的所有Eventarea类型
            from django.apps import apps
            EventEventarea = apps.get_model('core', 'EventEventarea')
            eventarea_types = EventEventarea.objects.filter(
                event_id=event.id
            ).values_list('eventarea__type', flat=True).distinct()

            if not eventarea_types:
                type_key = 0
                if type_key not in categorized:
                    categorized[type_key] = []
                serializer = SimpleEventSerializer(event)
                categorized[type_key].append(serializer.data)
            else:
                for eventarea_type in eventarea_types:
                    type_key = eventarea_type or 0
                    if type_key not in categorized:
                        categorized[type_key] = []

                    serializer = SimpleEventSerializer(event)
                    categorized[type_key].append(serializer.data)

        response_data = categorized

    return Response(response_data)


@api_view(['GET'])
def event_areas(request, event_id):
    """返回参加该活动的区域ID列表"""
    result, error, status_code = search_service.get_event_areas(event_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 活动区域功能 ==========

@api_view(['GET'])
def eventarea_by_id(request, eventarea_id):
    """获取id为<>的活动区域的所有信息"""
    result, error, status_code = search_service.get_eventarea_by_id(eventarea_id)
    if error:
        return Response(error, status=status_code)

    EventareaSerializer = get_eventarea_serializer()
    serializer = EventareaSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def eventarea_ids_by_map_and_type(request):
    """获取map_id为<> 且 type为<>的所有eventarea的id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_eventarea_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def eventarea_map_ids(request, eventarea_id):
    """获取eventarea_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_eventarea_map_ids(eventarea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_eventarea_ids_by_map(request):
    """获取map_id为<>的地图对应的所有eventarea_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_eventarea_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 设施功能 ==========

@api_view(['GET'])
def facility_by_id(request, facility_id):
    """获取id为<>的设施的所有信息"""
    result, error, status_code = search_service.get_facility_by_id(facility_id)
    if error:
        return Response(error, status=status_code)

    FacilitySerializer = get_facility_serializer()
    serializer = FacilitySerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def facility_ids_by_map_and_type(request):
    """获取map_id为<> 且type为<>的所有设施id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_facility_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def facility_map_ids(request, facility_id):
    """获取facility_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_facility_map_ids(facility_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_facility_ids_by_map(request):
    """获取map_id为<>的地图对应的所有facility_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_facility_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 其他区域功能 ==========

@api_view(['GET'])
def otherarea_by_id(request, otherarea_id):
    """获取id为<>的其他区域的所有信息"""
    result, error, status_code = search_service.get_otherarea_by_id(otherarea_id)
    if error:
        return Response(error, status=status_code)

    OtherareaSerializer = get_otherarea_serializer()
    serializer = OtherareaSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def otherarea_ids_by_map_and_type(request):
    """获取map_id为<> 且type为<>的所有otherarea的id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_otherarea_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def otherarea_map_ids(request, otherarea_id):
    """获取otherarea_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_otherarea_map_ids(otherarea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_otherarea_ids_by_map(request):
    """获取map_id为<>的地图对应的所有otherarea_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_otherarea_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)



================================================================================
文件路径: python-backend\search\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\search\migrations\__init__.py
--------------------------------------------------------------------------------






================================================================================
文件路径: python-backend\manage.py
--------------------------------------------------------------------------------

#!/usr/bin/env python
"""
Command-line utility for administrative tasks.

# For more information about this file, visit
# https://docs.djangoproject.com/en/2.1/ref/django-admin/
"""

import os
import sys

import django

if __name__ == '__main__':
    os.environ.setdefault(
        'DJANGO_SETTINGS_MODULE',
        'python_backend.settings')
    django.setup()

    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)



================================================================================
文件路径: python-backend\requirements.txt
--------------------------------------------------------------------------------

Django==5.2.8
asgiref==3.10.0
pip==25.0.1
psycopg2-binary==2.9.11
sqlparse==0.5.3
tzdata==2025.2
virtualenv==12.1.1
djangorestframework==3.15.2
markdown==3.7
django-filter==24.3
django-cors-headers==4.0.0
ezdxf==1.1.0


================================================================================
文件路径: python-backend\client\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\client\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class ClientConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'client'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\client\models.py
--------------------------------------------------------------------------------

from django.db import models

# Create your models here.



================================================================================
文件路径: python-backend\client\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\client\views.py
--------------------------------------------------------------------------------

from django.shortcuts import render

# Create your views here.
from rest_framework import viewsets, status

from rest_framework.decorators import action

from rest_framework.response import Response


================================================================================
文件路径: python-backend\client\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\client\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\core\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\core\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig

class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core'


================================================================================
文件路径: python-backend\core\context.py
--------------------------------------------------------------------------------

from core.models import *
from django.db.models import Q

class BaseContext:
    """基础 CRUD Context"""
    def __init__(self, model):
        self.model = model

    def get_by_id(self, pk):
        try:
            return self.model.objects.get(pk=pk)
        except self.model.DoesNotExist:
            return None

    def list_all(self):
        return self.model.objects.all()

    def create(self, **kwargs):
        return self.model.objects.create(**kwargs)

    def update(self, instance, **kwargs):
        for key, value in kwargs.items():
            setattr(instance, key, value)
        instance.save()
        return instance

    def delete(self, instance):
        instance.delete()


================================================================================
文件路径: python-backend\core\models.py
--------------------------------------------------------------------------------

from django.contrib.gis.db import models

# Create your models here.
class Admin(models.Model):
    account = models.CharField(unique=True, max_length=64)
    password = models.CharField(max_length=256)
    name = models.CharField(max_length=64, blank=True, null=True)

    class Meta:
        db_table = 'admin'
        # managed = False


class Building(models.Model):
    name = models.CharField(unique=True, max_length=64)
    address = models.CharField(max_length=256)
    description = models.CharField(max_length=256, blank=True, null=True)

    class Meta:
        db_table = 'building'
        # managed = False


class Event(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    description = models.CharField(max_length=256, blank=True, null=True)
    event_name = models.CharField(max_length=64)
    start_date = models.DateTimeField()
    end_date = models.DateTimeField()
    image_url = models.CharField(max_length=256, blank=True, null=True)

    class Meta:
        db_table = 'event'
        # managed = False


class EventEventarea(models.Model):
    pk = models.CompositePrimaryKey('event_id', 'eventarea_id')
    event = models.ForeignKey(Event, on_delete=models.CASCADE)
    eventarea = models.ForeignKey('Eventarea', on_delete=models.CASCADE)

    class Meta:
        db_table = 'event_eventarea'
        # managed = False
        # unique_together = (('event', 'eventarea'),)


class EventStorearea(models.Model):
    pk = models.CompositePrimaryKey('event_id', 'storearea_id')
    event = models.ForeignKey(Event, on_delete=models.CASCADE)
    storearea = models.ForeignKey('Storearea', on_delete=models.CASCADE)

    class Meta:
        db_table = 'event_storearea'
        # unique_together = (('event', 'storearea'),)
        # managed = False


class Eventarea(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    shape = models.PolygonField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    organizer_name = models.CharField(max_length=64)
    organizer_phone = models.CharField(max_length=16)
    type = models.IntegerField(blank=True, null=True)

    class Meta:
        db_table = 'eventarea'
        # managed = False


class EventareaMap(models.Model):
    pk = models.CompositePrimaryKey('eventarea_id', 'map_id')
    eventarea = models.ForeignKey(Eventarea, on_delete=models.CASCADE)
    map = models.ForeignKey('Map', on_delete=models.CASCADE)

    class Meta:
        db_table = 'eventarea_map'
        # unique_together = (('eventarea', 'map'),)
        # managed = False


class Facility(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    location = models.PointField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    type = models.IntegerField()

    class Meta:
        db_table = 'facility'
        # managed = False


class FacilityMap(models.Model):
    pk = models.CompositePrimaryKey('facility_id', 'map_id')
    facility = models.ForeignKey(Facility, on_delete=models.CASCADE)
    map = models.ForeignKey('Map', on_delete=models.CASCADE)

    class Meta:
        db_table = 'facility_map'
        # unique_together = (('facility', 'map'),)
        # managed = False


class Map(models.Model):
    building = models.ForeignKey(Building, models.CASCADE)
    floor_number = models.IntegerField()
    detail = models.GeometryCollectionField(srid=2385)

    class Meta:
        db_table = 'map'
        unique_together = (('building', 'floor_number'),)
        # managed = False


class Otherarea(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    shape = models.PolygonField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    type = models.IntegerField()
    is_public = models.BooleanField(blank=True, null=True)

    class Meta:
        db_table = 'otherarea'
        # managed = False


class OtherareaMap(models.Model):
    pk = models.CompositePrimaryKey('otherarea_id', 'map_id')
    otherarea = models.ForeignKey(Otherarea, on_delete=models.CASCADE)
    map = models.ForeignKey(Map, on_delete=models.CASCADE)

    class Meta:
        db_table = 'otherarea_map'
        # managed = False
        # unique_together = (('otherarea', 'map'),)


class Storearea(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    shape = models.PolygonField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    store_name = models.CharField(max_length=64)
    owner_name = models.CharField(max_length=64)
    owner_phone = models.CharField(max_length=16)
    logo_url = models.CharField(max_length=256, blank=True, null=True)
    open_time = models.TimeField(blank=True, null=True)
    close_time = models.TimeField(blank=True, null=True)
    type = models.IntegerField(blank=True, null=True)
    api_url = models.CharField(max_length=256, blank=True, null=True)

    class Meta:
        db_table = 'storearea'
        # managed = False


class StoreareaMap(models.Model):
    pk = models.CompositePrimaryKey('storearea_id', 'map_id')
    storearea = models.ForeignKey(Storearea, on_delete=models.CASCADE)
    map = models.ForeignKey(Map, on_delete=models.CASCADE)

    class Meta:
        db_table = 'storearea_map'
        # unique_together = (('storearea', 'map'),)
        # managed = False


================================================================================
文件路径: python-backend\core\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\core\views.py
--------------------------------------------------------------------------------

from django.shortcuts import render

# Create your views here.



================================================================================
文件路径: python-backend\core\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\core\migrations\0001_initial.py
--------------------------------------------------------------------------------

# Generated by Django 5.2.8 on 2025-12-10 02:55

import django.contrib.gis.db.models.fields
import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Admin',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('account', models.CharField(max_length=64, unique=True)),
                ('password', models.CharField(max_length=256)),
                ('name', models.CharField(blank=True, max_length=64, null=True)),
            ],
            options={
                'db_table': 'admin',
            },
        ),
        migrations.CreateModel(
            name='Building',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=64, unique=True)),
                ('address', models.CharField(max_length=256)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
            ],
            options={
                'db_table': 'building',
            },
        ),
        migrations.CreateModel(
            name='Event',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('event_name', models.CharField(max_length=64)),
                ('start_date', models.DateTimeField()),
                ('end_date', models.DateTimeField()),
                ('image_url', models.CharField(blank=True, max_length=256, null=True)),
            ],
            options={
                'db_table': 'event',
            },
        ),
        migrations.CreateModel(
            name='Eventarea',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('shape', django.contrib.gis.db.models.fields.PolygonField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('organizer_name', models.CharField(max_length=64)),
                ('organizer_phone', models.CharField(max_length=16)),
                ('type', models.IntegerField(blank=True, null=True)),
            ],
            options={
                'db_table': 'eventarea',
            },
        ),
        migrations.CreateModel(
            name='Facility',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('location', django.contrib.gis.db.models.fields.PointField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('type', models.IntegerField()),
            ],
            options={
                'db_table': 'facility',
            },
        ),
        migrations.CreateModel(
            name='Otherarea',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('shape', django.contrib.gis.db.models.fields.PolygonField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('type', models.IntegerField()),
                ('is_public', models.BooleanField(blank=True, null=True)),
            ],
            options={
                'db_table': 'otherarea',
            },
        ),
        migrations.CreateModel(
            name='Storearea',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('shape', django.contrib.gis.db.models.fields.PolygonField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('store_name', models.CharField(max_length=64)),
                ('owner_name', models.CharField(max_length=64)),
                ('owner_phone', models.CharField(max_length=16)),
                ('logo_url', models.CharField(blank=True, max_length=256, null=True)),
                ('open_time', models.TimeField(blank=True, null=True)),
                ('close_time', models.TimeField(blank=True, null=True)),
                ('type', models.IntegerField(blank=True, null=True)),
                ('api_url', models.CharField(blank=True, max_length=256, null=True)),
            ],
            options={
                'db_table': 'storearea',
            },
        ),
        migrations.CreateModel(
            name='EventEventarea',
            fields=[
                ('pk', models.CompositePrimaryKey('event_id', 'eventarea_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('event', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.event')),
                ('eventarea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.eventarea')),
            ],
            options={
                'db_table': 'event_eventarea',
            },
        ),
        migrations.CreateModel(
            name='Map',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('floor_number', models.IntegerField()),
                ('detail', django.contrib.gis.db.models.fields.GeometryCollectionField(srid=2385)),
                ('building', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.building')),
            ],
            options={
                'db_table': 'map',
                'unique_together': {('building', 'floor_number')},
            },
        ),
        migrations.CreateModel(
            name='FacilityMap',
            fields=[
                ('pk', models.CompositePrimaryKey('facility_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('facility', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.facility')),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
            ],
            options={
                'db_table': 'facility_map',
            },
        ),
        migrations.CreateModel(
            name='EventareaMap',
            fields=[
                ('pk', models.CompositePrimaryKey('eventarea_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('eventarea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.eventarea')),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
            ],
            options={
                'db_table': 'eventarea_map',
            },
        ),
        migrations.CreateModel(
            name='OtherareaMap',
            fields=[
                ('pk', models.CompositePrimaryKey('otherarea_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
                ('otherarea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.otherarea')),
            ],
            options={
                'db_table': 'otherarea_map',
            },
        ),
        migrations.CreateModel(
            name='EventStorearea',
            fields=[
                ('pk', models.CompositePrimaryKey('event_id', 'storearea_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('event', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.event')),
                ('storearea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.storearea')),
            ],
            options={
                'db_table': 'event_storearea',
            },
        ),
        migrations.CreateModel(
            name='StoreareaMap',
            fields=[
                ('pk', models.CompositePrimaryKey('storearea_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
                ('storearea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.storearea')),
            ],
            options={
                'db_table': 'storearea_map',
            },
        ),
    ]



================================================================================
文件路径: python-backend\core\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\editor\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\editor\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class EditorConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'editor'



================================================================================
文件路径: python-backend\editor\context.py
--------------------------------------------------------------------------------

from django.contrib.gis.geos import GEOSGeometry
from core.models import (
    Event,
    Storearea,
    StoreareaMap,
    EventStorearea,
    EventEventarea,
    Eventarea,
    EventareaMap,
    Otherarea,
    OtherareaMap,
    Facility,
    FacilityMap
)


class StoreareaContext:
    """
    店铺区域（Storearea）的数据访问层
    负责与数据库交互，仅提供shape属性相关的操作
    """

    @staticmethod
    def get_all():
        """获取所有店铺区域"""
        return Storearea.objects.all()

    @staticmethod
    def get_by_id(storearea_id):
        """根据ID获取店铺区域"""
        return Storearea.objects.filter(id=storearea_id).first()

    @staticmethod
    def create(shape, map_id=None):
        """创建新的店铺区域，并可选绑定到指定地图"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            # 这样无论是WKT还是GeoJSON格式，都会使用正确的SRID
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        storearea = Storearea.objects.create(shape=shape_geom)
        # 绑定到地图
        if map_id is not None:
            StoreareaMap.objects.create(storearea=storearea, map_id=map_id)
        return storearea

    @staticmethod
    def update_shape(storearea_id, shape):
        """更新店铺区域的形状"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        Storearea.objects.filter(id=storearea_id).update(shape=shape_geom)
        return StoreareaContext.get_by_id(storearea_id)

    @staticmethod
    def delete(storearea_id):
        """删除店铺区域"""
        Storearea.objects.filter(id=storearea_id).delete()

    @staticmethod
    def get_events_by_storearea(storearea_id):
        """获取店铺关联的所有活动ID"""
        event_relations = EventStorearea.objects.filter(storearea_id=storearea_id)
        return [relation.event_id for relation in event_relations]


class EventContext:
    """
    活动（Event）的数据访问层
    负责与数据库交互，仅提供shape属性相关的操作
    """

    @staticmethod
    def get_all():
        """获取所有活动"""
        return Event.objects.all()

    @staticmethod
    def get_by_id(event_id):
        """根据ID获取活动"""
        return Event.objects.filter(id=event_id).first()



    @staticmethod
    def get_storeareas_by_event(event_id):
        """获取活动关联的所有店铺区域ID"""
        storearea_relations = EventStorearea.objects.filter(event_id=event_id)
        return [relation.storearea_id for relation in storearea_relations]

    @staticmethod
    def get_eventareas_by_event(event_id):
        """获取活动关联的所有活动区域ID"""
        eventarea_relations = EventEventarea.objects.filter(event_id=event_id)
        return [relation.eventarea_id for relation in eventarea_relations]

    @staticmethod
    def add_storearea_relation(event_id, storearea_id):
        """添加活动与店铺区域的关联关系"""
        return EventStorearea.objects.get_or_create(event_id=event_id, storearea_id=storearea_id)

    @staticmethod
    def remove_storearea_relation(event_id, storearea_id):
        """移除活动与店铺区域的关联关系"""
        return EventStorearea.objects.filter(event_id=event_id, storearea_id=storearea_id).delete()

    @staticmethod
    def add_eventarea_relation(event_id, eventarea_id):
        """添加活动与活动区域的关联关系"""
        return EventEventarea.objects.get_or_create(event_id=event_id, eventarea_id=eventarea_id)

    @staticmethod
    def remove_eventarea_relation(event_id, eventarea_id):
        """移除活动与活动区域的关联关系"""
        return EventEventarea.objects.filter(event_id=event_id, eventarea_id=eventarea_id).delete()


class EventareaContext:
    """
    活动区域（Eventarea）的数据访问层
    负责与数据库交互，提供基本的CRUD操作
    """

    @staticmethod
    def get_all():
        """获取所有活动区域"""
        return Eventarea.objects.all()

    @staticmethod
    def get_by_id(eventarea_id):
        """根据ID获取活动区域"""
        return Eventarea.objects.filter(id=eventarea_id).first()

    @staticmethod
    def create(shape, map_id=None):
        """创建新的活动区域，并可选绑定到指定地图"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        eventarea = Eventarea.objects.create(shape=shape_geom)
        if map_id is not None:
            EventareaMap.objects.create(eventarea=eventarea, map_id=map_id)
        return eventarea

    @staticmethod
    def update_shape(eventarea_id, shape):
        """更新活动区域的形状"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        Eventarea.objects.filter(id=eventarea_id).update(shape=shape_geom)
        return EventareaContext.get_by_id(eventarea_id)

    @staticmethod
    def delete(eventarea_id):
        """删除活动区域"""
        Eventarea.objects.filter(id=eventarea_id).delete()


class OtherareaContext:
    """
    其他区域（Otherarea）的数据访问层
    负责与数据库交互，提供基本的CRUD操作
    """

    @staticmethod
    def get_all():
        """获取所有其他区域"""
        return Otherarea.objects.all()

    @staticmethod
    def get_by_id(otherarea_id):
        """根据ID获取其他区域"""
        return Otherarea.objects.filter(id=otherarea_id).first()

    @staticmethod
    def create(shape, map_id=None, type_val=None):
        """创建新的其他区域，并可选绑定到指定地图"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        otherarea = Otherarea.objects.create(
            shape=shape_geom,
            type=type_val if type_val is not None else 0  # 默认 0，避免 NOT NULL 约束报错
        )
        if map_id is not None:
            OtherareaMap.objects.create(otherarea=otherarea, map_id=map_id)
        return otherarea

    @staticmethod
    def update_shape(otherarea_id, shape):
        """更新其他区域的形状"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        Otherarea.objects.filter(id=otherarea_id).update(shape=shape_geom)
        return OtherareaContext.get_by_id(otherarea_id)

    @staticmethod
    def delete(otherarea_id):
        """删除其他区域"""
        Otherarea.objects.filter(id=otherarea_id).delete()


class FacilityContext:
    """
    设施（Facility）的数据访问层
    """

    @staticmethod
    def get_all():
        return Facility.objects.all()

    @staticmethod
    def get_by_id(facility_id):
        return Facility.objects.filter(id=facility_id).first()

    @staticmethod
    def create(location, map_id=None, type_val=None):
        try:
            loc_geom = GEOSGeometry(location)
            if loc_geom.srid != 2385:
                loc_geom.srid = 2385
        except Exception as e:
            raise ValueError(f"Invalid spatial data: {str(e)}")

        facility = Facility.objects.create(
            location=loc_geom,
            type=type_val if type_val is not None else 0
        )
        if map_id is not None:
            FacilityMap.objects.create(facility=facility, map_id=map_id)
        return facility

    @staticmethod
    def update_location(facility_id, location):
        """更新设施位置"""
        try:
            loc_geom = GEOSGeometry(location)
            if loc_geom.srid != 2385:
                loc_geom.srid = 2385
        except Exception as e:
            raise ValueError(f"Invalid spatial data: {str(e)}")

        Facility.objects.filter(id=facility_id).update(location=loc_geom)
        return FacilityContext.get_by_id(facility_id)

    @staticmethod
    def delete(facility_id):
        Facility.objects.filter(id=facility_id).delete()


================================================================================
文件路径: python-backend\editor\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from django.apps import apps


def get_storearea_serializer():
    """获取 Storearea 序列化器"""
    Storearea = apps.get_model('core', 'Storearea')

    class StoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            fields = '__all__'
            # 由于使用了 managed=False，需要明确指定字段
            # 但 ModelSerializer 会自动从模型获取字段

    return StoreareaSerializer


def get_event_serializer():
    """获取 Event 序列化器"""
    Event = apps.get_model('core', 'Event')

    class EventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = '__all__'

    return EventSerializer


def get_eventarea_serializer():
    """获取活动区域序列化器"""
    Eventarea = apps.get_model('core', 'Eventarea')
    
    class EventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            fields = '__all__'
    
    return EventareaSerializer


def get_otherarea_serializer():
    """获取其他区域序列化器"""
    Otherarea = apps.get_model('core', 'Otherarea')
    
    class OtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            fields = '__all__'
    
    return OtherareaSerializer


def get_facility_serializer():
    """获取设施序列化器"""
    Facility = apps.get_model('core', 'Facility')

    class FacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            fields = '__all__'

    return FacilitySerializer

def get_map_serializer():
    Map = apps.get_model('core', 'Map')
    class MapSerializer(serializers.ModelSerializer):
        class Meta:
            model = Map
            fields = '__all__'
    return MapSerializer


================================================================================
文件路径: python-backend\editor\services.py
--------------------------------------------------------------------------------

from .context import StoreareaContext, EventContext, EventareaContext, OtherareaContext,FacilityContext
from map.context import MapContext
from django.contrib.gis.geos import GeometryCollection, Polygon, Point
from django.db import transaction
import ezdxf
import io


class StoreareaService:
    """
    店铺区域（Storearea）的业务层
    负责处理业务逻辑，调用数据访问层方法，仅处理shape属性相关操作
    """

    @staticmethod
    def get_all_storeareas():
        """获取所有店铺区域"""
        return StoreareaContext.get_all()

    @staticmethod
    def get_storearea_by_id(storearea_id):
        """根据ID获取店铺区域"""
        return StoreareaContext.get_by_id(storearea_id)

    @staticmethod
    def create_storearea(shape, map_id=None):
        """创建新的店铺区域，并可选绑定到指定地图"""
        return StoreareaContext.create(shape, map_id)

    @staticmethod
    def update_shape(storearea_id, shape):
        """更新店铺区域的形状"""
        # 可以在这里添加业务逻辑验证
        return StoreareaContext.update_shape(storearea_id, shape)

    @staticmethod
    def delete_storearea(storearea_id):
        """删除店铺区域"""
        # 可以在这里添加业务逻辑验证
        return StoreareaContext.delete(storearea_id)

    @staticmethod
    def get_events_for_storearea(storearea_id):
        """获取店铺关联的所有活动ID"""
        return StoreareaContext.get_events_by_storearea(storearea_id)


class EventService:
    """
    活动（Event）的业务层
    负责处理业务逻辑，调用数据访问层方法，仅处理shape属性相关操作
    """

    @staticmethod
    def get_all_events():
        """获取所有活动"""
        return EventContext.get_all()

    @staticmethod
    def get_event_by_id(event_id):
        """根据ID获取活动"""
        return EventContext.get_by_id(event_id)



    @staticmethod
    def get_areas_for_event(event_id):
        """获取活动关联的所有区域ID（包括店铺区域和活动区域）"""
        storearea_ids = EventContext.get_storeareas_by_event(event_id)
        eventarea_ids = EventContext.get_eventareas_by_event(event_id)
        return {
            'storearea_ids': storearea_ids,
            'eventarea_ids': eventarea_ids,
            'all_area_ids': storearea_ids + eventarea_ids
        }

    @staticmethod
    def add_storearea_to_event(event_id, storearea_id):
        """添加活动与店铺区域的关联关系"""
        # 可以在这里添加业务逻辑验证（如检查活动和店铺是否存在等）
        return EventContext.add_storearea_relation(event_id, storearea_id)

    @staticmethod
    def remove_storearea_from_event(event_id, storearea_id):
        """移除活动与店铺区域的关联关系"""
        # 可以在这里添加业务逻辑验证
        return EventContext.remove_storearea_relation(event_id, storearea_id)

    @staticmethod
    def add_eventarea_to_event(event_id, eventarea_id):
        """添加活动与活动区域的关联关系"""
        # 可以在这里添加业务逻辑验证（如检查活动和活动区域是否存在等）
        return EventContext.add_eventarea_relation(event_id, eventarea_id)

    @staticmethod
    def remove_eventarea_from_event(event_id, eventarea_id):
        """移除活动与活动区域的关联关系"""
        # 可以在这里添加业务逻辑验证
        return EventContext.remove_eventarea_relation(event_id, eventarea_id)


class EventareaService:
    """
    活动区域（Eventarea）的业务层
    负责处理业务逻辑，调用数据访问层方法
    注意：在editor模块中只处理shape属性的更新
    """

    @staticmethod
    def get_all_eventareas():
        """获取所有活动区域"""
        return EventareaContext.get_all()

    @staticmethod
    def get_eventarea_by_id(eventarea_id):
        """根据ID获取活动区域"""
        return EventareaContext.get_by_id(eventarea_id)

    @staticmethod
    def create_eventarea(shape, map_id=None):
        """创建新的活动区域，并可选绑定到指定地图"""
        return EventareaContext.create(shape, map_id)

    @staticmethod
    def update_eventarea_shape(eventarea_id, shape):
        """更新活动区域的形状"""
        # 可以在这里添加业务逻辑验证（如形状有效性检查等）
        return EventareaContext.update_shape(eventarea_id, shape)

    @staticmethod
    def delete_eventarea(eventarea_id):
        """删除活动区域"""
        # 可以在这里添加业务逻辑验证
        return EventareaContext.delete(eventarea_id)


class OtherareaService:
    """
    其他区域（Otherarea）的业务层
    负责处理业务逻辑，调用数据访问层方法
    注意：在editor模块中只处理shape属性的更新
    """

    @staticmethod
    def get_all_otherareas():
        """获取所有其他区域"""
        return OtherareaContext.get_all()

    @staticmethod
    def get_otherarea_by_id(otherarea_id):
        """根据ID获取其他区域"""
        return OtherareaContext.get_by_id(otherarea_id)

    @staticmethod
    def create_otherarea(shape, map_id=None, type_val=None):
        """创建新的其他区域，并可选绑定到指定地图"""
        return OtherareaContext.create(shape, map_id, type_val)

    @staticmethod
    def update_otherarea_shape(otherarea_id, shape):
        """更新其他区域的形状"""
        # 可以在这里添加业务逻辑验证（如形状有效性检查等）
        return OtherareaContext.update_shape(otherarea_id, shape)

    @staticmethod
    def delete_otherarea(otherarea_id):
        """删除其他区域"""
        # 可以在这里添加业务逻辑验证
        return OtherareaContext.delete(otherarea_id)

class FacilityService:
    """
    设施（Facility）的业务层
    """
    @staticmethod
    def get_all_facilities():
        return FacilityContext.get_all()

    @staticmethod
    def get_facility_by_id(facility_id):
        return FacilityContext.get_by_id(facility_id)

    @staticmethod
    def create_facility(location, map_id=None, type_val=None):
        return FacilityContext.create(location, map_id, type_val)

    @staticmethod
    def update_facility_location(facility_id, location):
        return FacilityContext.update_location(facility_id, location)

    @staticmethod
    def delete_facility(facility_id):
        return FacilityContext.delete(facility_id)


class MapEditorService:
    """
    地图编辑服务：处理地图及关联要素的创建、导入
    """

    # 定义 CAD 图层名称到业务类型的映射
    LAYER_MAPPING = {
        'FLOOR_OUTLINE': 'floor',  # 底图外框
        'VOIDS': 'hole',  # 底图镂空
        'AREA_STORE': 'storearea',  # 店铺区域
        'AREA_EVENT': 'eventarea',  # 活动区域
        'AREA_OTHER': 'otherarea',  # 其他区域
        'FACILITIES': 'facility'  # 设施
    }

    @staticmethod
    def create_map(building_id, floor_number, file=None):
        map_ctx = MapContext()

        # 1. 业务校验
        if map_ctx.check_exists(building_id, floor_number):
            raise ValueError("该建筑的此楼层已存在地图")

        try:
            with transaction.atomic():
                # 2. 解析 DXF 数据
                if file:
                    dxf_data = MapEditorService._parse_dxf_layers(file)
                else:
                    # 手动模式默认数据
                    dxf_data = {
                        'floor': Polygon(((0, 0), (0, 100), (100, 100), (100, 0), (0, 0)), srid=2385),
                        'holes': [],
                        'storearea': [],
                        'eventarea': [],
                        'otherarea': [],
                        'facility': []
                    }

                # 3. 组装并创建 Map (底图)
                # 将外框和镂空组合成 GeometryCollection
                if not dxf_data['floor']:
                    raise ValueError("DXF 中未找到 FLOOR_OUTLINE 图层或有效的闭合外轮廓")

                # 组合 list: [外框, 洞1, 洞2...]
                map_geometry_list = [dxf_data['floor']] + dxf_data['holes']
                map_geometry = GeometryCollection(map_geometry_list, srid=2385)

                # 调用 Context 创建地图
                new_map = map_ctx.create_map_record(building_id, floor_number, map_geometry)

                # 4. 创建关联实体 (调用 editor.context 中的各 Context)
                # 注意：editor.context.create 方法通常只接收 shape/location 和 map_id

                # A. 创建店铺
                for shape in dxf_data['storearea']:
                    # 这里可以根据需求生成默认名称，例如 "导入的店铺"
                    StoreareaContext.create(shape=shape, map_id=new_map.id)

                # B. 创建活动区
                for shape in dxf_data['eventarea']:
                    EventareaContext.create(shape=shape, map_id=new_map.id)

                # C. 创建其他区域
                for shape in dxf_data['otherarea']:
                    # type_val 默认为 0
                    OtherareaContext.create(shape=shape, map_id=new_map.id, type_val=0)

                # D. 创建设施 (点)
                for location in dxf_data['facility']:
                    # FacilityContext.create 接收 Point 对象
                    FacilityContext.create(location=location, map_id=new_map.id, type_val=0)

                return new_map

        except Exception as e:
            # 捕获异常并回滚事务（由 transaction.atomic 自动处理回滚，这里重新抛出以便 View 层捕获）
            raise ValueError(f"创建地图失败: {str(e)}")

    @staticmethod
    def _parse_dxf_layers(uploaded_file):
        """
        解析 DXF 文件，按图层分类提取几何数据
        """
        try:
            # === 修复逻辑开始 ===
            # 1. 统一转换为二进制流 (Binary Stream)
            binary_stream = None
            if isinstance(uploaded_file, bytes):
                binary_stream = io.BytesIO(uploaded_file)
            elif hasattr(uploaded_file, 'read'):
                # 已经是流对象 (BytesIO 或 Django UploadedFile)
                binary_stream = uploaded_file
            else:
                raise ValueError("不支持的文件输入类型")

            # 2. 确保指针在开头
            if hasattr(binary_stream, 'seek'):
                binary_stream.seek(0)

            # 3. 将二进制流包装为文本流 (Text Stream)
            # ezdxf.read() 需要读取字符串。DXF 通常是 cp1252 或 utf-8。
            # 使用 errors='ignore' 防止因为编码问题导致解析完全失败
            text_stream = io.TextIOWrapper(binary_stream, encoding='utf-8', errors='ignore')

            # 4. 读取 DXF
            doc = ezdxf.read(text_stream)
            # === 修复逻辑结束 ===

            msp = doc.modelspace()

            result = {
                'floor': None,
                'holes': [],
                'storearea': [],
                'eventarea': [],
                'otherarea': [],
                'facility': []
            }

            # 遍历所有实体
            for entity in msp:
                # 增加容错：有些实体可能没有 layer 属性
                if not hasattr(entity.dxf, 'layer'):
                    continue

                layer_name = entity.dxf.layer.upper()

                if layer_name not in MapEditorService.LAYER_MAPPING:
                    continue

                target_type = MapEditorService.LAYER_MAPPING[layer_name]

                # --- 处理多边形 (区域/楼层) ---
                if entity.dxftype() == 'LWPOLYLINE':
                    if not entity.closed:
                        continue  # 忽略未闭合的线

                    points = []
                    # 坐标转换：毫米 -> 米
                    for p in entity.get_points():
                        points.append((p[0] / 1000.0, p[1] / 1000.0))

                    # 确保首尾闭合
                    if points[0] != points[-1]:
                        points.append(points[0])

                    if len(points) >= 4:
                        poly = Polygon(points, srid=2385)

                        if target_type == 'floor':
                            # 假设图纸里只有一个最大的框是地板，如果有多个，暂取第一个或覆盖
                            if result['floor'] is None:
                                result['floor'] = poly
                            else:
                                # 如果有多个 FLOOR_OUTLINE，简单的逻辑是看谁面积大
                                if poly.area > result['floor'].area:
                                    result['floor'] = poly
                        elif target_type == 'hole':
                            result['holes'].append(poly)
                        elif target_type in ['storearea', 'eventarea', 'otherarea']:
                            result[target_type].append(poly)

                # --- 处理点/圆 (设施) ---
                elif entity.dxftype() in ['CIRCLE', 'POINT']:
                    if target_type == 'facility':
                        x, y = 0, 0
                        if entity.dxftype() == 'CIRCLE':
                            # 圆取圆心
                            center = entity.dxf.center
                            x, y = center.x / 1000.0, center.y / 1000.0
                        else:
                            # 点取坐标
                            loc = entity.dxf.location
                            x, y = loc.x / 1000.0, loc.y / 1000.0

                        point = Point(x, y, srid=2385)
                        result['facility'].append(point)

            return result

        except Exception as e:
            # 增加一些调试信息
            import traceback
            traceback.print_exc()
            raise ValueError(f"DXF 解析内部错误: {str(e)}")


================================================================================
文件路径: python-backend\editor\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\editor\urls.py
--------------------------------------------------------------------------------

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

# 创建路由器并注册视图集
router = DefaultRouter()
router.register(r'storearea', views.StoreareaViewSet, basename='editor_storearea')
router.register(r'event', views.EventViewSet, basename='editor_event')
router.register(r'eventarea', views.EventareaViewSet, basename='editor_eventarea')
router.register(r'otherarea', views.OtherareaViewSet, basename='editor_otherarea')
router.register(r'facility', views.FacilityViewSet, basename='editor_facility')
router.register(r'map', views.MapEditorViewSet, basename='editor_map')

urlpatterns = [
    # 包含路由器生成的所有URL
    path('', include(router.urls)),
]




================================================================================
文件路径: python-backend\editor\views.py
--------------------------------------------------------------------------------

import base64
import io
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from django.shortcuts import get_object_or_404
from rest_framework.parsers import JSONParser
from .serializers import get_storearea_serializer, get_event_serializer, get_eventarea_serializer, get_otherarea_serializer, get_facility_serializer, get_map_serializer
from .services import StoreareaService, EventService, EventareaService, OtherareaService, FacilityService, MapEditorService


class StoreareaViewSet(viewsets.ModelViewSet):
    """
    店铺区域（Storearea）的视图集
    
    注意：在editor模块中只处理shape属性的更新，其他属性在management中实现
    
    支持的操作：
    - GET /api/editor/storearea/ - 获取所有店铺区域列表
    - GET /api/editor/storearea/{id}/ - 获取指定店铺区域详情
    - POST /api/editor/storearea/ - 创建店铺区域（仅支持shape属性）
    - PATCH /api/editor/storearea/{id}/ - 部分更新店铺区域（仅支持shape属性）
    - DELETE /api/editor/storearea/{id}/ - 删除店铺区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_storearea_serializer()
    
    def get_queryset(self):
        """获取所有店铺区域"""
        return StoreareaService.get_all_storeareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有店铺区域列表"""
        storeareas = StoreareaService.get_all_storeareas()
        serializer = self.get_serializer(storeareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定店铺区域详情"""
        storearea = get_object_or_404(StoreareaService.get_all_storeareas(), pk=pk)
        serializer = self.get_serializer(storearea)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新店铺区域"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """部分更新店铺区域（仅支持shape属性）"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be updated in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        storearea = get_object_or_404(StoreareaService.get_all_storeareas(), pk=pk)
        shape = request.data.get('shape')
        
        updated_storearea = StoreareaService.update_shape(pk, shape)
        serializer = self.get_serializer(updated_storearea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建店铺区域（仅支持shape属性），并绑定到指定地图"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be provided when creating storearea in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        shape = request.data.get('shape')
        map_id = request.data.get('map_id')
        new_storearea = StoreareaService.create_storearea(shape, map_id)
        serializer = self.get_serializer(new_storearea)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    def destroy(self, request, pk=None):
        """删除店铺区域"""
        StoreareaService.delete_storearea(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)
    
    @action(detail=True, methods=['get'])
    def events(self, request, pk=None):
        """获取店铺关联的所有活动ID"""
        event_ids = StoreareaService.get_events_for_storearea(pk)
        return Response({
            'storearea_id': pk,
            'event_ids': event_ids
        })


class EventViewSet(viewsets.ModelViewSet):
    """
    活动（Event）的视图集
    
    注意：Event模型没有shape字段，因此不支持shape属性更新

    支持的操作：
    - GET /api/editor/event/ - 获取所有活动列表
    - GET /api/editor/event/{id}/ - 获取指定活动详情
    - GET /api/editor/event/{id}/areas/ - 获取活动关联的所有区域ID
    - POST/DELETE /api/editor/event/{id}/storeareas/ - 管理活动与店铺区域的关联关系
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_event_serializer()
    
    def get_queryset(self):
        """获取所有活动"""
        return EventService.get_all_events()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动列表"""
        events = EventService.get_all_events()
        serializer = self.get_serializer(events, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动详情"""
        event = get_object_or_404(EventService.get_all_events(), pk=pk)
        serializer = self.get_serializer(event)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新活动"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """不允许在editor模块中更新活动"""
        return Response(
            {'error': 'Update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def create(self, request, *args, **kwargs):
        """不允许在editor模块中创建活动"""
        return Response(
            {'error': 'Create not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def destroy(self, request, pk=None):
        """不允许在editor模块中删除活动"""
        return Response(
            {'error': 'Delete not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    @action(detail=True, methods=['get'])
    def areas(self, request, pk=None):
        """获取活动关联的所有区域ID（包括店铺区域和活动区域）"""
        areas = EventService.get_areas_for_event(pk)
        return Response({
            'event_id': pk,
            'storearea_ids': areas['storearea_ids'],
            'eventarea_ids': areas['eventarea_ids'],
            'all_area_ids': areas['all_area_ids']
        })
    
    @action(detail=True, methods=['post', 'delete'])
    def storeareas(self, request, pk=None):
        """管理活动与店铺区域的关联关系"""
        if request.method == 'POST':
            # 添加关联
            storearea_id = request.data.get('storearea_id')
            if not storearea_id:
                return Response(
                    {'error': 'storearea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            relation, created = EventService.add_storearea_to_event(pk, storearea_id)
            
            if created:
                return Response(
                    {'message': 'Relation created successfully'},
                    status=status.HTTP_201_CREATED
                )
            else:
                return Response(
                    {'message': 'Relation already exists'},
                    status=status.HTTP_200_OK
                )
        
        elif request.method == 'DELETE':
            # 删除关联
            storearea_id = request.data.get('storearea_id')
            if not storearea_id:
                return Response(
                    {'error': 'storearea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            deleted_count, _ = EventService.remove_storearea_from_event(pk, storearea_id)
            
            if deleted_count > 0:
                return Response(
                    {'message': 'Relation deleted successfully'},
                    status=status.HTTP_204_NO_CONTENT
                )
            else:
                return Response(
                    {'error': 'Relation not found'},
                    status=status.HTTP_404_NOT_FOUND
                )


class EventareaViewSet(viewsets.ModelViewSet):
    """
    活动区域（Eventarea）的视图集
    
    注意：在editor模块中只处理shape属性的更新，其他属性在management中实现
    
    支持的操作：
    - GET /api/editor/eventarea/ - 获取所有活动区域列表
    - GET /api/editor/eventarea/{id}/ - 获取指定活动区域详情
    - POST /api/editor/eventarea/ - 创建活动区域（仅支持shape属性）
    - PATCH /api/editor/eventarea/{id}/ - 部分更新活动区域（仅支持shape属性）
    - DELETE /api/editor/eventarea/{id}/ - 删除活动区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_eventarea_serializer()
    
    def get_queryset(self):
        """获取所有活动区域"""
        return EventareaService.get_all_eventareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动区域列表"""
        eventareas = EventareaService.get_all_eventareas()
        serializer = self.get_serializer(eventareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动区域详情"""
        eventarea = get_object_or_404(EventareaService.get_all_eventareas(), pk=pk)
        serializer = self.get_serializer(eventarea)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新活动区域"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """部分更新活动区域（仅支持shape属性）"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be updated in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        eventarea = get_object_or_404(EventareaService.get_all_eventareas(), pk=pk)
        shape = request.data.get('shape')
        
        updated_eventarea = EventareaService.update_eventarea_shape(pk, shape)
        serializer = self.get_serializer(updated_eventarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建活动区域（仅支持shape属性），并绑定到指定地图"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be provided when creating eventarea in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        shape = request.data.get('shape')
        map_id = request.data.get('map_id')
        new_eventarea = EventareaService.create_eventarea(shape, map_id)
        serializer = self.get_serializer(new_eventarea)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    def destroy(self, request, pk=None):
        """删除活动区域"""
        EventareaService.delete_eventarea(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)


class OtherareaViewSet(viewsets.ModelViewSet):
    """
    其他区域（Otherarea）的视图集
    
    注意：在editor模块中只处理shape属性的更新，其他属性在management中实现
    
    支持的操作：
    - GET /api/editor/otherarea/ - 获取所有其他区域列表
    - GET /api/editor/otherarea/{id}/ - 获取指定其他区域详情
    - POST /api/editor/otherarea/ - 创建其他区域（仅支持shape属性）
    - PATCH /api/editor/otherarea/{id}/ - 部分更新其他区域（仅支持shape属性）
    - DELETE /api/editor/otherarea/{id}/ - 删除其他区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_otherarea_serializer()
    
    def get_queryset(self):
        """获取所有其他区域"""
        return OtherareaService.get_all_otherareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有其他区域列表"""
        otherareas = OtherareaService.get_all_otherareas()
        serializer = self.get_serializer(otherareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定其他区域详情"""
        otherarea = get_object_or_404(OtherareaService.get_all_otherareas(), pk=pk)
        serializer = self.get_serializer(otherarea)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新其他区域"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """部分更新其他区域（仅支持shape属性）"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be updated in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        otherarea = get_object_or_404(OtherareaService.get_all_otherareas(), pk=pk)
        shape = request.data.get('shape')
        
        updated_otherarea = OtherareaService.update_otherarea_shape(pk, shape)
        serializer = self.get_serializer(updated_otherarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建其他区域（仅支持shape属性），并绑定到指定地图"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be provided when creating otherarea in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        shape = request.data.get('shape')
        map_id = request.data.get('map_id')
        type_val = request.data.get('type')
        new_otherarea = OtherareaService.create_otherarea(shape, map_id, type_val)
        serializer = self.get_serializer(new_otherarea)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    def destroy(self, request, pk=None):
        """删除其他区域"""
        OtherareaService.delete_otherarea(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)
    
    @action(detail=True, methods=['post', 'delete'])
    def eventareas(self, request, pk=None):
        """管理活动与活动区域的关联关系"""
        if request.method == 'POST':
            # 添加关联
            eventarea_id = request.data.get('eventarea_id')
            if not eventarea_id:
                return Response(
                    {'error': 'eventarea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            relation, created = EventService.add_eventarea_to_event(pk, eventarea_id)
            
            if created:
                return Response(
                    {'message': 'Relation created successfully'},
                    status=status.HTTP_201_CREATED
                )
            else:
                return Response(
                    {'message': 'Relation already exists'},
                    status=status.HTTP_200_OK
                )
        
        elif request.method == 'DELETE':
            # 删除关联
            eventarea_id = request.data.get('eventarea_id')
            if not eventarea_id:
                return Response(
                    {'error': 'eventarea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            deleted_count, _ = EventService.remove_eventarea_from_event(pk, eventarea_id)
            
            if deleted_count > 0:
                return Response(
                    {'message': 'Relation deleted successfully'},
                    status=status.HTTP_204_NO_CONTENT
                )
            else:
                return Response(
                    {'error': 'Relation not found'},
                    status=status.HTTP_404_NOT_FOUND
                )


class FacilityViewSet(viewsets.ModelViewSet):
    """
    设施（Facility）的视图集
    支持操作：更新位置 (PATCH)
    """

    def get_serializer_class(self):
        return get_facility_serializer()

    def get_queryset(self):
        return FacilityService.get_all_facilities()

    def list(self, request, *args, **kwargs):
        facilities = FacilityService.get_all_facilities()
        serializer = self.get_serializer(facilities, many=True)
        return Response(serializer.data)

    def retrieve(self, request, pk=None):
        facility = get_object_or_404(FacilityService.get_all_facilities(), pk=pk)
        serializer = self.get_serializer(facility)
        return Response(serializer.data)

    def partial_update(self, request, pk=None):
        """部分更新设施（仅支持 location 属性）"""
        if 'location' not in request.data:
            return Response(
                {'error': 'Only location attribute can be updated in editor module'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # 检查 ID 是否存在
        get_object_or_404(FacilityService.get_all_facilities(), pk=pk)

        location = request.data.get('location')
        updated_facility = FacilityService.update_facility_location(pk, location)
        serializer = self.get_serializer(updated_facility)
        return Response(serializer.data)

    def create(self, request, *args, **kwargs):
        if 'location' not in request.data:
            return Response(
                {'error': 'Location is required'}, status=status.HTTP_400_BAD_REQUEST
            )

        location = request.data.get('location')
        map_id = request.data.get('map_id')
        type_val = request.data.get('type')

        new_facility = FacilityService.create_facility(location, map_id, type_val)
        serializer = self.get_serializer(new_facility)
        return Response(serializer.data, status=status.HTTP_201_CREATED)

    def destroy(self, request, pk=None):
        FacilityService.delete_facility(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)


class MapEditorViewSet(viewsets.ViewSet):
    """
    地图创建与编辑视图
    POST /api/editor/map/
    """
    # 既然前端改用 JSON，这里只需要 JSONParser
    parser_classes = (JSONParser,)

    def create(self, request):
        building_id = request.data.get('building_id')
        floor_number = request.data.get('floor_number')

        # 获取 Base64 字符串 (格式通常为 "data:application/dxf;base64,......")
        file_data_url = request.data.get('file_data')

        if not building_id or not floor_number:
            return Response({"error": "缺少建筑ID或楼层号"}, status=status.HTTP_400_BAD_REQUEST)

        dxf_file_stream = None
        if file_data_url:
            try:
                # 1. 分离头部 (如果有) 和 内容
                if ',' in file_data_url:
                    header, data_str = file_data_url.split(',', 1)
                else:
                    data_str = file_data_url

                # 2. Base64 解码
                file_bytes = base64.b64decode(data_str)

                # 3. 转为二进制流 (BytesIO 实现了 read() 方法，ezdxf 可直接读取)
                dxf_file_stream = io.BytesIO(file_bytes)
                # 为了让 ezdxf 读取文本模式更安全，有时需要 TextIOWrapper，
                # 但 ezdxf.read() 通常也能处理 bytes。我们先传 bytes stream。

            except Exception as e:
                return Response({"error": f"文件解析失败: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            # 调用 Service (Service 逻辑无需修改，它只关心传入的对象有 read() 方法)
            new_map = MapEditorService.create_map(building_id, floor_number, dxf_file_stream)

            Serializer = get_map_serializer()
            return Response(Serializer(new_map).data, status=status.HTTP_201_CREATED)

        except ValueError as e:
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)


================================================================================
文件路径: python-backend\editor\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\editor\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\guide\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\guide\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class GuideConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'guide'



================================================================================
文件路径: python-backend\guide\context.py
--------------------------------------------------------------------------------

from django.contrib.gis.geos import Polygon, Point
from typing import Tuple, List, Optional

# 导入所有涉及的模型
from core.models import Map, Storearea, Eventarea, Otherarea, Facility, StoreareaMap, EventareaMap, OtherareaMap, \
    FacilityMap


class GuideContext:  # 不继承 BaseContext
    """
    导航模块数据上下文
    职责：只负责从数据库提取几何数据，不负责路径计算逻辑
    """

    @staticmethod
    def get_map_geometry_data(map_id: int) -> Tuple[Optional[Polygon], List[Polygon], List[Polygon]]:
        """
        一次性获取地图的边界、原始镂空以及所有障碍物

        :param map_id: 地图 ID
        :return: (outer_shell, holes, obstacles)
        """
        # 1. 获取地图底图对象
        try:
            map_obj = Map.objects.get(pk=map_id)
        except Map.DoesNotExist:
            return None, [], []

        # 2. 解析地图底图 (GeometryCollection)
        # detail[0] 通常是地板外轮廓 (Polygon)
        # detail[1:] 是地板内部的镂空 (Polygon list)
        if not map_obj.detail or len(map_obj.detail) == 0:
            return None, [], []

        outer_shell = map_obj.detail[0]
        # 确保它是 Polygon，防止脏数据
        if not isinstance(outer_shell, Polygon):
            return None, [], []

        holes = []
        # 可能有镂空，也可能没有镂空
        if len(map_obj.detail) > 1:
            holes = list(map_obj.detail[1:])

        # 3. 获取所有业务层面的障碍物
        # 将所有障碍物统一合并到一个列表中返回
        obstacles = []

        # --- A. 获取商铺区域 (Polygon) ---
        stores = Storearea.objects.filter(
            storeareamap__map_id=map_id,
            shape__isnull=False
        ).values_list('shape', flat=True)
        obstacles.extend(stores)

        # --- B. 获取活动区域 (Polygon) ---
        events = Eventarea.objects.filter(
            eventareamap__map_id=map_id,
            shape__isnull=False
        ).values_list('shape', flat=True)
        obstacles.extend(events)

        # --- C. 获取其他区域 (Polygon) ---
        others = Otherarea.objects.filter(
            otherareamap__map_id=map_id,
            shape__isnull=False
        ).values_list('shape', flat=True)
        obstacles.extend(others)

        # --- D. 获取设施 (Point -> Polygon) ---
        facilities = Facility.objects.filter(
            facilitymap__map_id=map_id,
            location__isnull=False
        ).values_list('location', flat=True)
        # 将设施点膨胀后放入障碍物列表
        for point in facilities:
            # buffer(0.5) 表示以点为中心，半径 0.5 米的圆
            if isinstance(point, Point):
                obstacles.append(point.buffer(0.5))

        return outer_shell, holes, obstacles



================================================================================
文件路径: python-backend\guide\services.py
--------------------------------------------------------------------------------

# import networkx as nx
# from django.contrib.gis.geos import Point, LineString
# from map.context import MapContext
# from map.services import MapServices  # 复用校验逻辑
#
#
# class GuideService:
#
#     def __init__(self, map_id: int):
#         self.map_id = map_id
#         # 通过 Context 获取数据
#         self.outer_shell, self.holes = MapContext.get_map_geometry(map_id)
#         # 获取所有障碍物 (Map镂空 + 实体店铺 + 设施)
#         # 这里的 obstacles 是纯几何对象列表
#         self.obstacles = list(self.holes) + MapContext.get_all_obstacles(map_id)
#
#     # --- 接口 5: 完善导航接口 ---
#     def find_path(self, start_point: Point, end_point: Point):
#         """
#         计算单楼层内的两点路径
#         """
#         if not self.outer_shell:
#             return {"success": False, "message": "Map not initialized"}
#
#         # 0. 校验起终点合法性 (复用 MapService 的逻辑)
#         # 注意：这里我们假设 MapService 是无状态的工具类
#         valid_start, msg_start = MapService.check_area_placement(start_point, self.map_id)
#         # 对终点的检查可能需要放宽（因为终点可能就在店铺门口），这里暂时严格检查
#         valid_end, msg_end = MapService.check_area_placement(end_point, self.map_id)
#
#         if not valid_start:
#             return {"success": False, "message": f"Start point invalid: {msg_start}"}
#         # 如果终点是店铺，check_area_placement 会报错（因为和店铺重合），
#         # 实际逻辑中应该判断终点是否在障碍物内部，如果在内部，应该“弹出”到最近的可行走点。
#         # 此处简化，假设输入点已经处理过。
#
#         # 1. 构建可见性图 (Visibility Graph)
#         graph = nx.Graph()
#
#         # 节点包括：起点、终点、所有障碍物的顶点
#         nodes = [start_point, end_point]
#         for obs in self.obstacles:
#             # 获取多边形外环坐标 (去除最后一个重复点)
#             coords = obs.exterior.coords[:-1]
#             nodes.extend([Point(c, srid=2385) for c in coords])
#
#         # 2. 构建边
#         # 优化：仅在节点数较少时使用全连接 O(N^2)
#         node_ids = range(len(nodes))
#
#         for i in node_ids:
#             graph.add_node(i, pos=(nodes[i].x, nodes[i].y))
#
#         for i in node_ids:
#             for j in range(i + 1, len(nodes)):
#                 p1 = nodes[i]
#                 p2 = nodes[j]
#
#                 if self._is_line_of_sight_clear(p1, p2):
#                     dist = p1.distance(p2)
#                     graph.add_edge(i, j, weight=dist)
#
#         # 3. 计算 Dijkstra
#         try:
#             path_indices = nx.dijkstra_path(graph, source=0, target=1)
#             path_coords = [(nodes[i].x, nodes[i].y) for i in path_indices]
#
#             return {
#                 "success": True,
#                 "distance": nx.dijkstra_path_length(graph, source=0, target=1),
#                 "path": LineString(path_coords, srid=2385),
#                 "steps": path_coords
#             }
#         except nx.NetworkXNoPath:
#             return {
#                 "success": False,
#                 "message": "No walkable path found."
#             }
#
#     def _is_line_of_sight_clear(self, p1: Point, p2: Point) -> bool:
#         """
#         私有方法：判断视线是否被阻挡
#         """
#         line = LineString(p1, p2)
#
#         # 必须在外轮廓内
#         if not self.outer_shell.contains(line):
#             return False
#
#         # 不能穿过任何障碍物
#         for obstacle in self.obstacles:
#             # 使用 relation 或者 intersection 判断
#             if obstacle.intersects(line) and not obstacle.touches(line):
#                 return False
#         return True

from django.contrib.gis.geos import Point, LineString, Polygon
from typing import Tuple, List, Optional
import math
import heapq

# Context 导入
from guide.context import GuideContext


class GridSystem:
    """
    辅助类：网格系统类
    负责将世界坐标(Geo)转换为离散的网格坐标(Grid)
    并管理障碍物矩阵
    """

    def __init__(self, boundary_polygon: Polygon, resolution: float = 0.5):
        """
        :param boundary_polygon: 地图的外轮廓
        :param resolution: 网格精度，例如 0.5 表示每个网格格子 0.5x0.5 米
        """
        self.resolution = resolution
        self.boundary = boundary_polygon
        # 获取多边形 boundary_polygon 的最小最大坐标
        self.min_x, self.min_y, self.max_x, self.max_y = boundary_polygon.extent
        # 计算网格系统的 x方向、 y方向各自的格子总数
        self.width = int(math.ceil((self.max_x - self.min_x) / resolution))  # 这个方法 ceil 是向上取整
        self.height = int(math.ceil((self.max_y - self.min_y) / resolution))
        # 障碍物集合，存储不可行走的网格坐标元组 (gx, gy)
        self.obstacles = set()

    def world_to_grid(self, x: float, y: float) -> Tuple[int, int]:
        """将世界坐标转为网格坐标"""
        gx = int((x - self.min_x) / self.resolution)  # int() 是向下取整
        gy = int((y - self.min_y) / self.resolution)
        return gx, gy

    def grid_to_world(self, gx: int, gy: int) -> Tuple[float, float]:
        """将网格坐标中心转为世界坐标"""
        wx = self.min_x + (gx + 0.5) * self.resolution  # 这里是加上半格的意思，不是加上 0.5 米
        wy = self.min_y + (gy + 0.5) * self.resolution
        return wx, wy

    def mark_obstacles(self, geometry_list: List[Polygon]):
        """
        向 self.obstacles 集合中存储障碍物占据的格子坐标
        某个障碍物占据了哪些格子
        逆向思维：判断这个格子是否在这个障碍物多边形内
        """
        for poly in geometry_list:
            # 1. 性能优化：不要扫描全图，只扫描障碍物所在的那个矩形区域（Bounding Box）
            # poly.extent 返回 (min_x, min_y, max_x, max_y)
            min_x, min_y, max_x, max_y = poly.extent

            # 2. 把这个矩形区域的四个角，转换成网格坐标
            # min_gx, min_gy 是左下角格子的索引
            # max_gx, max_gy 是右上角格子的索引
            min_gx, min_gy = self.world_to_grid(min_x, min_y)
            max_gx, max_gy = self.world_to_grid(max_x, max_y)

            # 3. 修正边界，防止算出负数或者超出地图宽度的索引
            min_gx = max(0, min_gx)
            min_gy = max(0, min_gy)
            max_gx = min(self.width, max_gx + 1)  # +1 是为了保证循环能覆盖到边缘
            max_gy = min(self.height, max_gy + 1)

            # 4. 循环遍历这个小区域内的每一个格子
            for gx in range(min_gx, max_gx):
                for gy in range(min_gy, max_gy):
                    # 算出这个格子中心点在地图上的真实坐标 (wx, wy)
                    wx, wy = self.grid_to_world(gx, gy)

                    # 创建一个临时的点对象
                    cell_center = Point(wx, wy, srid=2385)

                    # 5. 关键判断：如果这个格子的中心点碰到了障碍物，这个格子就是不可走的
                    # intersects() 表示“相交”或“重叠”
                    if poly.intersects(cell_center):
                        self.obstacles.add((gx, gy))

    def is_walkable(self, gx: int, gy: int) -> bool:
        """检查网格点是否在地图内且不是障碍物"""
        # 1. 数组边界检查，严格小于 self.width，因为 self.width 是上取整
        if not (0 <= gx < self.width and 0 <= gy < self.height):
            return False
        # 2. 障碍物检查
        if (gx, gy) in self.obstacles:
            return False
        # 3. 地图边界检查
        # 算出这个格子中心的真实世界坐标
        wx, wy = self.grid_to_world(gx, gy)
        # 构造一个临时的点对象
        point = Point(wx, wy, srid=2385)
        # contains() 表示如果点在多边形内部返回 True，在外部返回 False
        if not self.boundary.contains(point):
            return False

        return True


class RoutePlanService:
    """
    路径规划业务服务层
    """

    def __init__(self):
        # 创建上下文对象
        self.ctx = GuideContext()

    def validate_request_params(self, map_id, start_data, end_data) -> Tuple[bool, str]:
        """
        在View中使用的，对Request请求参数的校验逻辑
        """
        # 1. 必填项校验
        if map_id is None:
            return False, "Missing parameter: map_id"
        if not start_data or not end_data:
            return False, "Missing parameter: start or end coordinates"

        # 2. 字典结构校验
        if not isinstance(start_data, dict) or not isinstance(end_data, dict):
            return False, "Coordinates must be JSON objects with x and y"

        # 3. 坐标数值校验
        try:
            float(start_data.get('x'))
            float(start_data.get('y'))
            float(end_data.get('x'))
            float(end_data.get('y'))
        except (ValueError, TypeError):
            return False, "Coordinates x and y must be valid numbers"

        return True, "Request params are valid"

    def calculate_route(self, map_id: int, start_pt: Point, end_pt: Point) -> Optional[LineString]:
        """
        主入口：计算路径
        """
        # 1. 获取地图几何数据 (调用 Context)
        # 期望返回:
        # outer_shell: Polygon (地图地板轮廓)
        # holes: List[Polygon] (地图本身镂空)
        # obstacles: List[Geometry] (商铺、活动区、其他区域、膨胀后的设施)
        outer_shell, holes, obstacles = self.ctx.get_map_geometry_data(map_id)

        if not outer_shell:
            raise ValueError(f"Map #{map_id} outer_shell missing")

        # 2. 初始化网格系统 (Grid System)
        # 设定分辨率为 0.5 米 (可根据性能需求调整)
        grid_sys = GridSystem(outer_shell, resolution=0.5)

        # 3. 网格化障碍物
        # 将 holes 和 obstacles 合并处理
        all_obstacles = holes + obstacles
        grid_sys.mark_obstacles(all_obstacles)

        # 4. 起点、终点坐标转换
        start_node = grid_sys.world_to_grid(start_pt.x, start_pt.y)
        end_node = grid_sys.world_to_grid(end_pt.x, end_pt.y)

        # 5. 校验起终点有效性
        if not grid_sys.is_walkable(*start_node):
            raise ValueError("Start node is not walkable")
        if not grid_sys.is_walkable(*end_node):
            raise ValueError("End node is not walkable")

        # 6. 执行 A* 算法，返回网格坐标的列表
        path_nodes = self._run_astar(start_node, end_node, grid_sys)

        if not path_nodes:
            return None

        # 7. 结果转换 (Grid Nodes -> Geo LineString)
        # 将网格路径转回世界坐标的折线
        return self._construct_linestring(path_nodes, grid_sys)

    def _run_astar(self, start_node: Tuple[int, int], end_node: Tuple[int, int], grid: GridSystem) \
            -> List[Tuple[int, int]]:
        """
        A* 算法核心逻辑
        :param start_node: (gx, gy) 起点
        :param end_node: (gx, gy) 终点
        :param grid: 网格系统对象，用于判断可行走性
        :return: [(x1, y1), (x2, y2), ...] 路径列表，如果找不到路径返回 None
        """
        # 1. 初始化 open_set (优先队列)，存放 (f_score, node)，可能的扩展节点
        # f_score = g_score + h_score
        open_set = []
        heapq.heappush(open_set, (0, start_node))

        # 2. 初始化记录字典
        # came_from: 记录路径回溯，key=当前节点, value=父节点
        came_from = {}

        # g_score: 从起点到当前节点的实际代价。默认无穷大。
        g_score = {start_node: 0.0}

        # f_score: 预估总代价。默认无穷大。
        # f_score[start_node] = h(start_node, end)
        f_score = {start_node: self._heuristic(start_node, end_node)}

        # 定义移动方向和对应的代价
        # (dx, dy, cost)
        sqrt2 = math.sqrt(2)
        movements = [
            (0, 1, 1.0), (0, -1, 1.0), (1, 0, 1.0), (-1, 0, 1.0),  # 上下右左
            (1, 1, sqrt2), (1, -1, sqrt2), (-1, 1, sqrt2), (-1, -1, sqrt2)  # 对角线
        ]

        # 3. 主循环，当 open_set 非空
        while open_set:
            # 取出 f_score 最小的节点
            current_f, current = heapq.heappop(open_set)

            # --- 成功到达终点 ---
            if current == end_node:
                return self._reconstruct_path(came_from, current)

            # 遍历 8 个邻居
            for dx, dy, move_cost in movements:
                neighbor = (current[0] + dx, current[1] + dy)

                # --- 核心判断：如果邻居不可走则跳过 ---
                if not grid.is_walkable(*neighbor):
                    continue

                # 计算经过当前节点到达邻居的 tentative_g (临时G值)
                tentative_g = g_score[current] + move_cost

                # 如果临时G值小于该邻居之前的G值，或者之前没访问过该邻居 (字典里找不到 neighbor 这个 key，就返回 inf)
                if tentative_g < g_score.get(neighbor, float('inf')):
                    # 更新记录
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g

                    # 计算 f 值 = g + h
                    new_f = tentative_g + self._heuristic(neighbor, end_node)
                    f_score[neighbor] = new_f

                    # 加入优先队列等待处理
                    heapq.heappush(open_set, (new_f, neighbor))

        # 循环结束仍未找到终点
        return None

    def _reconstruct_path(self, came_from: dict, current: Tuple[int, int]) -> List[Tuple[int, int]]:
        """
        私有辅助方法：从终点回溯到起点，重建路径
        """
        total_path = [current]
        while current in came_from:
            current = came_from[current]
            total_path.append(current)

        # 因为是从终点往回找的，所以要反转列表
        return total_path[::-1]

    def _heuristic(self, node_a: Tuple[int, int], node_b: Tuple[int, int]) -> float:
        """
        启发函数 (对角距离)
        """
        delta_x = abs(node_a[0] - node_b[0])
        delta_y = abs(node_a[1] - node_b[1])
        h_value = delta_x + delta_y + (math.sqrt(2) - 2) * min(delta_x, delta_y)
        return h_value

    def _construct_linestring(self, path_nodes: List[Tuple[int, int]], grid: GridSystem) -> LineString:
        """
        将网格节点序列转换为 PostGIS LineString 对象
        """
        points = []
        for gx, gy in path_nodes:
            wx, wy = grid.grid_to_world(gx, gy)
            points.append((wx, wy))

        return LineString(points, srid=2385)



================================================================================
文件路径: python-backend\guide\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase
from unittest.mock import MagicMock, patch
from django.contrib.gis.geos import Polygon, Point, LineString
from guide.services import RoutePlanService, GridSystem
from rest_framework.test import APITestCase
from rest_framework import status
from django.contrib.gis.geos import Polygon, GeometryCollection, Point
from core.models import Map, Building, Storearea, StoreareaMap


class GridSystemTestCase(TestCase):
    """
    测试 GridSystem 类的底层逻辑 (坐标转换、障碍物标记、边界检查)
    """

    def setUp(self):
        # 创建一个 10x10 的正方形地图 (SRID=2385)
        # 坐标范围: (0,0) -> (10,10)
        self.boundary = Polygon(((0, 0), (0, 10), (10, 10), (10, 0), (0, 0)), srid=2385)
        # 分辨率设为 1.0 米，方便计算 (网格大小 10x10)
        self.grid = GridSystem(self.boundary, resolution=1.0)

    def test_coordinate_conversion(self):
        """测试世界坐标与网格坐标的相互转换"""
        # 测试 world_to_grid (向下取整)
        # 坐标 (1.5, 1.5) 应该落在 (1, 1) 格子
        gx, gy = self.grid.world_to_grid(1.5, 1.5)
        self.assertEqual((gx, gy), (1, 1))

        # 测试 grid_to_world (取中心点)
        # 格子 (1, 1) 的中心应该是 (1.5, 1.5)
        wx, wy = self.grid.grid_to_world(1, 1)
        self.assertEqual((wx, wy), (1.5, 1.5))

    def test_mark_obstacles(self):
        """测试障碍物栅格化逻辑"""
        # 创建一个位于地图中心的障碍物 (4,4) 到 (6,6)
        obstacle = Polygon(((4, 4), (4, 6), (6, 6), (6, 4), (4, 4)), srid=2385)

        self.grid.mark_obstacles([obstacle])

        # 检查障碍物内部的点 (5, 5) -> 不可走
        self.assertFalse(self.grid.is_walkable(5, 5))

        # 检查障碍物边缘的点 (网格化后可能会占据边缘)
        # (4, 4) 根据 intersects 判定通常会被占据
        self.assertFalse(self.grid.is_walkable(4, 4))

        # 检查开阔区域的点 (1, 1) -> 可走
        self.assertTrue(self.grid.is_walkable(1, 1))

    def test_boundary_check_complex_shape(self):
        """
        测试不规则形状地图的边界检查 (L型地图)
        验证 is_walkable 中的 boundary.contains 逻辑
        """
        # 创建一个 L 型多边形 (缺口在右上角)
        # (0,0) -> (0,10) -> (5,10) -> (5,5) -> (10,5) -> (10,0) -> (0,0)
        l_shape_wkt = "POLYGON((0 0, 0 10, 5 10, 5 5, 10 5, 10 0, 0 0))"
        l_shape = Polygon.from_ewkt(l_shape_wkt)
        l_shape.srid = 2385

        grid = GridSystem(l_shape, resolution=1.0)

        # 1. 测试在地图内的点 (2, 2)
        self.assertTrue(grid.is_walkable(2, 2))

        # 2. 测试在 L 型缺口处的点 (8, 8)
        # 虽然 (8, 8) 在 GridSystem 的数组索引范围内 (width=10, height=10)
        # 但它在物理上位于大楼外部
        self.assertFalse(grid.is_walkable(8, 8))


class RoutePlanServiceTestCase(TestCase):
    """
    测试 A* 算法服务层逻辑
    使用 Mock 屏蔽 Context/数据库 操作
    """

    def setUp(self):
        self.service = RoutePlanService()
        # 基础地图: 20x20 米的正方形
        self.map_boundary = Polygon(((0, 0), (0, 20), (20, 20), (20, 0), (0, 0)), srid=2385)

    @patch('guide.services.GuideContext')
    def test_simple_straight_path(self, MockContext):
        """测试无障碍物的直线路径"""
        # --- Mock 设置 ---
        mock_ctx_instance = MockContext.return_value
        # 返回: (外框, 镂空[], 障碍物[])
        mock_ctx_instance.get_map_geometry_data.return_value = (self.map_boundary, [], [])

        # 替换 service 中的 ctx
        self.service.ctx = mock_ctx_instance

        # --- 执行测试 ---
        start = Point(2, 2, srid=2385)
        end = Point(18, 18, srid=2385)

        # 运行算法
        route = self.service.calculate_route(map_id=1, start_pt=start, end_pt=end)

        # --- 断言 ---
        self.assertIsInstance(route, LineString)
        # 直线距离约为 22.62 米
        # A* 也是走的对角线，长度应该非常接近直线距离
        self.assertAlmostEqual(route.length, start.distance(end), delta=1.0)

    @patch('guide.services.GuideContext')
    def test_obstacle_avoidance(self, MockContext):
        """测试绕行逻辑：起点和终点中间有一堵墙，必须从缺口绕过去"""
        # --- Mock 设置 ---
        mock_ctx_instance = MockContext.return_value

        # 定义障碍物：一堵带缺口的墙
        # 墙的范围：y轴 9到11，x轴 5到20。
        # 这意味着 x轴 0到5 的区域是空的（缺口），路径只能从这里通过。
        wall_with_gap = Polygon(((5, 9), (5, 11), (20, 11), (20, 9), (5, 9)), srid=2385)

        # 模拟 Context 返回：地图边界、无镂空、以及上面定义的障碍物
        mock_ctx_instance.get_map_geometry_data.return_value = (
            self.map_boundary,
            [],
            [wall_with_gap]
        )
        self.service.ctx = mock_ctx_instance

        # --- 执行测试 ---
        # 起点(10, 2) -> 终点(10, 18)
        # 直线连线会被墙挡住 (墙在 y=9~11, x=5~20)
        start = Point(10, 2, srid=2385)
        end = Point(10, 18, srid=2385)

        route = self.service.calculate_route(1, start, end)

        # --- 断言 ---
        self.assertIsNotNone(route)

        # 1. 验证路径长度：肯定大于直线距离 (16米)
        # 直线距离 = 18 - 2 = 16
        self.assertTrue(route.length > 16.0)

        # 2. 验证路径走向：必须经过左侧缺口
        # 获取路径上所有点的 x 坐标
        coords = route.coords
        min_x_in_path = min(p[0] for p in coords)

        # 因为墙是从 x=5 开始的，所以要想过去，路径中至少有一个点的 x 必须小于 5 (或者接近 5)
        # 我们这里断言 < 6.0 是为了留一点网格化精度的余量
        self.assertLess(min_x_in_path, 6.0)

    @patch('guide.services.GuideContext')
    def test_unreachable_target(self, MockContext):
        """测试终点被完全包围无法到达的情况"""
        mock_ctx_instance = MockContext.return_value

        # 障碍物完全包围终点 (10, 10)
        box = Polygon(((8, 8), (8, 12), (12, 12), (12, 8), (8, 8)), srid=2385)

        mock_ctx_instance.get_map_geometry_data.return_value = (self.map_boundary, [], [box])
        self.service.ctx = mock_ctx_instance

        start = Point(2, 2, srid=2385)
        end = Point(10, 10, srid=2385)  # 在盒子里面

        # 预期抛出 ValueError (因为 End node is not walkable)
        # 或者如果 End node 勉强算 walkable 但无法到达，则返回 None
        # 根据 services.py 逻辑，先检查 is_walkable

        # 由于障碍物占位，End point 所在的网格会被标记为 obstacle
        with self.assertRaises(ValueError) as cm:
            self.service.calculate_route(1, start, end)

        self.assertIn("End node is not walkable", str(cm.exception))


class GuideIntegrationTestCase(APITestCase):
    """
    第二步：集成测试
    测试 Views -> Services -> Context -> DB 的完整链路
    """

    def setUp(self):
        # 1. 创建基础建筑 (外键依赖)
        self.building = Building.objects.create(
            name="Test Mall",
            address="123 Test St"
        )

        # 2. 创建地图 (Map)
        # 地图是一个 20x20 的正方形
        # 注意：Map 的 detail 字段是 GeometryCollection
        boundary = Polygon(((0, 0), (0, 20), (20, 20), (20, 0), (0, 0)), srid=2385)
        gc = GeometryCollection(boundary, srid=2385)

        self.map_obj = Map.objects.create(
            building=self.building,
            floor_number=1,
            detail=gc
        )

        # 3. 创建一个商铺 (障碍物)
        # 商铺挡在地图中间 (8,8) 到 (12,12)
        store_shape = Polygon(((8, 8), (8, 12), (12, 12), (12, 8), (8, 8)), srid=2385)
        self.store = Storearea.objects.create(
            store_name="Blocker Store",
            owner_name="Test Owner",
            owner_phone="123",
            shape=store_shape,
            is_active=True  # 确保是激活状态
        )

        # 4. 关联商铺和地图 (建立中间表关系)
        # 注意：根据你的 models.py，StoreareaMap 有两个外键
        StoreareaMap.objects.create(
            storearea=self.store,
            map=self.map_obj
        )

        # API URL (需要你在 urls.py 中配置好，这里假设路径是 /api/guide/route/)
        self.url = '/api/guide/route/'

    def test_route_api_success(self):
        """测试完整的 API 调用流程"""
        # 起点 (2,2)，终点 (18,18)
        # 中间有商铺挡路，应该能规划出路径
        payload = {
            "map_id": self.map_obj.id,
            "start": {"x": 2.0, "y": 2.0},
            "end": {"x": 18.0, "y": 18.0}
        }

        response = self.client.post(self.url, payload, format='json')

        # 1. 验证状态码 200
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        # 2. 验证返回数据结构
        data = response.data
        self.assertIn("route", data)
        self.assertIn("distance", data)
        self.assertIsInstance(data["route"], dict)  # GeoJSON 对象
        self.assertIsInstance(data["route"]["coordinates"], list)

        # 3. 验证距离是否合理 (直线约22米，绕路肯定大于22米)
        self.assertTrue(data["distance"] > 22.0)

        # 打印一下结果看看
        print(f"\n[Integration Test] Route Distance: {data['distance']} meters")

    def test_api_missing_params(self):
        """测试参数缺失情况"""
        payload = {"map_id": self.map_obj.id}  # 缺少 start/end
        response = self.client.post(self.url, payload, format='json')
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

    def test_api_invalid_coordinates(self):
        """测试无效坐标 (起点在墙里)"""
        # 起点 (10, 10) 正好在刚才创建的 Storearea 内部
        payload = {
            "map_id": self.map_obj.id,
            "start": {"x": 10.0, "y": 10.0},
            "end": {"x": 18.0, "y": 18.0}
        }
        response = self.client.post(self.url, payload, format='json')

        # 预期报错：Start node is not walkable
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn("error", response.data)


================================================================================
文件路径: python-backend\guide\views.py
--------------------------------------------------------------------------------

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.contrib.gis.geos import Point
import json

# 导入服务类
from .services import RoutePlanService


class RoutePlanView(APIView):
    """
    POST /api/guide/route/
    接收起点终点坐标，返回路径规划结果
    """
    service_class = RoutePlanService

    def post(self, request):
        service = self.service_class()

        # 读取前端传参
        # 前端传参示例: {"map_id": 1, "start": {"x": 10.0, "y": 20.0}, "end": {"x": 50.0, "y": 60.0}}
        map_id = request.data.get('map_id')
        start_data = request.data.get('start')
        end_data = request.data.get('end')

        # 这一步负责检查参数是否存在、格式是否正确、坐标是否可转换为浮点数
        # 我们不需要在这里写 if-else，全交给 Service
        is_valid, error_msg = service.validate_request_params(map_id, start_data, end_data)

        if not is_valid:
            return Response({"error": error_msg}, status=status.HTTP_400_BAD_REQUEST)

        try:
            # 经过上面的校验，这里可以放心转换，不用担心 KeyError 或 TypeError
            start_point = Point(float(start_data['x']), float(start_data['y']), srid=2385)
            end_point = Point(float(end_data['x']), float(end_data['y']), srid=2385)

        except Exception as e:
            # 极端异常情况
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)

        try:
            # 预期 service 返回一个 LineString 对象
            route_geometry = service.calculate_route(map_id, start_point, end_point)

            if not route_geometry:
                return Response({"error": "Route not found or unreachable"}, status=status.HTTP_404_NOT_FOUND)

            # 构造返回
            response_data = {
                # json.loads(route_geometry.geojson) 将 GeoJSON 字符串转为 Python 字典/列表
                "route": json.loads(route_geometry.geojson),
                # route_geometry.length 自动计算米制长度，然后保留 2 位小数
                "distance": round(route_geometry.length, 2)
            }

            return Response(response_data)

        except Exception as e:
            # 捕获如算法内部抛出的业务异常
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)


================================================================================
文件路径: python-backend\guide\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\guide\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\management\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\management\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class ManagementConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'management'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\management\context.py
--------------------------------------------------------------------------------

from core.models import Eventarea, Otherarea, Event, Storearea, Facility,Admin
from core.context import BaseContext

class EventareaContext:
    """
    活动区域（Eventarea）的数据访问层
    
    提供与Eventarea模型相关的数据操作方法
    """
    
    @staticmethod
    def get_all_eventareas():
        """
        获取所有活动区域
        
        Returns:
            QuerySet: 活动区域的查询集
        """
        return Eventarea.objects.all()
    
    @staticmethod
    def get_eventarea_by_id(eventarea_id):
        """
        根据ID获取活动区域
        
        Args:
            eventarea_id: 活动区域ID
        
        Returns:
            Eventarea: 活动区域对象
        """
        return Eventarea.objects.get(id=eventarea_id)
    
    @staticmethod
    def create_eventarea(data):
        """
        创建新的活动区域
        
        Args:
            data: 活动区域数据
        
        Returns:
            Eventarea: 创建的活动区域对象
        """
        return Eventarea.objects.create(**data)
    
    @staticmethod
    def update_eventarea(eventarea_id, data):
        """
        更新活动区域
        
        Args:
            eventarea_id: 活动区域ID
            data: 更新数据
        
        Returns:
            Eventarea: 更新后的活动区域对象
        """
        eventarea = Eventarea.objects.get(id=eventarea_id)
        for key, value in data.items():
            setattr(eventarea, key, value)
        eventarea.save()
        return eventarea
    
    @staticmethod
    def delete_eventarea(eventarea_id):
        """
        删除活动区域
        
        Args:
            eventarea_id: 活动区域ID
        """
        Eventarea.objects.filter(id=eventarea_id).delete()


class EventContext:
    """
    活动（Event）的数据访问层
    
    提供与Event模型相关的数据操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """
    
    @staticmethod
    def get_all_events():
        """
        获取所有活动
        
        Returns:
            QuerySet: 活动的查询集
        """
        return Event.objects.all()
    
    @staticmethod
    def get_event_by_id(event_id):
        """
        根据ID获取活动
        
        Args:
            event_id: 活动ID
        
        Returns:
            Event: 活动对象
        """
        return Event.objects.get(id=event_id)
    
    @staticmethod
    def create_event(data):
        """
        创建新的活动
        
        Args:
            data: 活动数据
        
        Returns:
            Event: 创建的活动对象
        """
        return Event.objects.create(**data)
    
    @staticmethod
    def update_event(event_id, data):
        """
        更新活动
        
        Args:
            event_id: 活动ID
            data: 更新数据
        
        Returns:
            Event: 更新后的活动对象
        """
        event = Event.objects.get(id=event_id)
        for key, value in data.items():
            setattr(event, key, value)
        event.save()
        return event
    
    @staticmethod
    def delete_event(event_id):
        """
        删除活动
        
        Args:
            event_id: 活动ID
        """
        Event.objects.filter(id=event_id).delete()


class StoreareaContext:
    """
    店铺区域（Storearea）的数据访问层
    
    提供与Storearea模型相关的数据操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """
    
    @staticmethod
    def get_all_storeareas():
        """
        获取所有店铺区域
        
        Returns:
            QuerySet: 店铺区域的查询集
        """
        return Storearea.objects.all()
    
    @staticmethod
    def get_storearea_by_id(storearea_id):
        """
        根据ID获取店铺区域
        
        Args:
            storearea_id: 店铺区域ID
        
        Returns:
            Storearea: 店铺区域对象
        """
        return Storearea.objects.get(id=storearea_id)
    
    @staticmethod
    def create_storearea(data):
        """
        创建新的店铺区域
        
        Args:
            data: 店铺区域数据
        
        Returns:
            Storearea: 创建的店铺区域对象
        """
        return Storearea.objects.create(**data)
    
    @staticmethod
    def update_storearea(storearea_id, data):
        """
        更新店铺区域
        
        Args:
            storearea_id: 店铺区域ID
            data: 更新数据
        
        Returns:
            Storearea: 更新后的店铺区域对象
        """
        storearea = Storearea.objects.get(id=storearea_id)
        for key, value in data.items():
            setattr(storearea, key, value)
        storearea.save()
        return storearea
    
    @staticmethod
    def delete_storearea(storearea_id):
        """
        删除店铺区域
        
        Args:
            storearea_id: 店铺区域ID
        """
        Storearea.objects.filter(id=storearea_id).delete()


class OtherareaContext:
    """
    其他区域（Otherarea）的数据访问层
    
    提供与Otherarea模型相关的数据操作方法
    """
    
    @staticmethod
    def get_all_otherareas():
        """
        获取所有其他区域
        
        Returns:
            QuerySet: 其他区域的查询集
        """
        return Otherarea.objects.all()
    
    @staticmethod
    def get_otherarea_by_id(otherarea_id):
        """
        根据ID获取其他区域
        
        Args:
            otherarea_id: 其他区域ID
        
        Returns:
            Otherarea: 其他区域对象
        """
        return Otherarea.objects.get(id=otherarea_id)
    
    @staticmethod
    def create_otherarea(data):
        """
        创建新的其他区域
        
        Args:
            data: 其他区域数据
        
        Returns:
            Otherarea: 创建的其他区域对象
        """
        return Otherarea.objects.create(**data)
    
    @staticmethod
    def update_otherarea(otherarea_id, data):
        """
        更新其他区域
        
        Args:
            otherarea_id: 其他区域ID
            data: 更新数据
        
        Returns:
            Otherarea: 更新后的其他区域对象
        """
        otherarea = Otherarea.objects.get(id=otherarea_id)
        for key, value in data.items():
            setattr(otherarea, key, value)
        otherarea.save()
        return otherarea
    
    @staticmethod
    def delete_otherarea(otherarea_id):
        """
        删除其他区域
        
        Args:
            otherarea_id: 其他区域ID
        """
        Otherarea.objects.filter(id=otherarea_id).delete()


class FacilityContext:
    """
    设施（Facility）的数据访问层
    
    提供与Facility模型相关的数据操作方法
    注意：location属性由editor模块处理
    """
    
    @staticmethod
    def get_all_facilities():
        """
        获取所有设施
        
        Returns:
            QuerySet: 设施的查询集
        """
        return Facility.objects.all()
    
    @staticmethod
    def get_facility_by_id(facility_id):
        """
        根据ID获取设施
        
        Args:
            facility_id: 设施ID
        
        Returns:
            Facility: 设施对象
        """
        return Facility.objects.get(id=facility_id)
    
    @staticmethod
    def create_facility(data):
        """
        创建新的设施
        
        Args:
            data: 设施数据
        
        Returns:
            Facility: 创建的设施对象
        """
        return Facility.objects.create(**data)
    
    @staticmethod
    def update_facility(facility_id, data):
        """
        更新设施
        
        Args:
            facility_id: 设施ID
            data: 更新数据
        
        Returns:
            Facility: 更新后的设施对象
        """
        facility = Facility.objects.get(id=facility_id)
        for key, value in data.items():
            setattr(facility, key, value)
        facility.save()
        return facility
    
    @staticmethod
    def delete_facility(facility_id):
        """
        删除设施
        
        Args:
            facility_id: 设施ID
        """
        Facility.objects.filter(id=facility_id).delete()

class AdminContext(BaseContext):
    """针对 Admin 模型的基础 CRUD 和查询操作"""
    def __init__(self):
        super().__init__(Admin)

    def get_by_account(self, account: str) -> Admin | None:
        """根据账号名获取 Admin 实例"""
        try:
            return self.model.objects.get(account=account)
        except self.model.DoesNotExist:
            return None


================================================================================
文件路径: python-backend\management\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from django.apps import apps
from core.models import Admin

def get_eventarea_serializer():
    """获取活动区域序列化器"""
    Eventarea = apps.get_model('core', 'Eventarea')
    
    class EventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            exclude = ['shape']
    
    return EventareaSerializer


def get_otherarea_serializer():
    """获取其他区域序列化器"""
    Otherarea = apps.get_model('core', 'Otherarea')
    
    class OtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            exclude = ['shape']
    
    return OtherareaSerializer


def get_event_serializer():
    """获取Event模型的序列化器"""
    Event = apps.get_model('core', 'Event')
    
    class EventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = '__all__'
    
    return EventSerializer


def get_storearea_serializer():
    """获取Storearea模型的序列化器"""
    Storearea = apps.get_model('core', 'Storearea')
    
    class StoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            exclude = ['shape']
    
    return StoreareaSerializer


def get_facility_serializer():
    """获取Facility模型的序列化器"""
    Facility = apps.get_model('core', 'Facility')
    
    class FacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            exclude = ['location']
    
    return FacilitySerializer

# Input Serializers (用于接收前端数据)
class AdminRegisterSerializer(serializers.Serializer):
    """管理员注册输入"""
    account = serializers.CharField(max_length=64)
    password = serializers.CharField(max_length=128, write_only=True)
    name = serializers.CharField(max_length=64, required=False, allow_blank=True)

class AdminLoginSerializer(serializers.Serializer):
    """管理员登录输入"""
    account = serializers.CharField(max_length=64)
    password = serializers.CharField(max_length=128, write_only=True) # write_only: 密码只用于输入，不用于输出

class AdminUpdateSerializer(serializers.Serializer):
    """管理员修改信息输入 (用于 PUT / PATCH)"""
    name = serializers.CharField(max_length=64, required=False, allow_blank=True)
    # 允许修改密码，但必须使用新的字段名 new_password
    new_password = serializers.CharField(max_length=128, required=False, write_only=True)

# Output Serializer (用于返回 Admin 实例信息)
class AdminProfileSerializer(serializers.ModelSerializer):
    """管理员信息的输出格式 (不暴露密码)"""
    class Meta:
        model = Admin
        fields = ['id', 'account', 'name']
        read_only_fields = ['id', 'account'] # 账号和ID不能通过这个接口修改


================================================================================
文件路径: python-backend\management\services.py
--------------------------------------------------------------------------------

from .context import EventareaContext, OtherareaContext, EventContext, StoreareaContext, FacilityContext, AdminContext
from core.models import Admin
from django.contrib.auth.hashers import make_password, check_password
from django.core.exceptions import ValidationError


class AdminService:
    """负责管理员的注册、登录和个人信息修改的业务逻辑"""

    def __init__(self):
        self.ctx = AdminContext()

    def register_admin(self, account: str, password: str, name: str | None = None) -> Admin:
        """注册新管理员"""
        if self.ctx.get_by_account(account):
            raise ValidationError("Admin account already exists.")

        # 1. 密码哈希 (SECURITY CRITICAL)
        hashed_password = make_password(password)

        # 2. 创建实例
        admin_instance = self.ctx.create(
            account=account,
            password=hashed_password,
            name=name
        )
        return admin_instance

    def login_admin(self, account: str, password: str) -> Admin | None:
        """验证管理员登录凭证"""
        admin_instance = self.ctx.get_by_account(account)

        # 1. 检查实例是否存在
        if not admin_instance:
            return None  # 账号不存在

        # 2. 检查密码是否匹配 (使用 check_password 验证哈希值)
        if check_password(password, admin_instance.password):
            return admin_instance  # 登录成功

        return None  # 密码错误

    def update_profile(self, admin_instance: Admin, name: str | None, new_password: str | None) -> Admin:
        """更新管理员信息 (姓名和/或密码)"""
        update_data = {}

        if name is not None:
            update_data['name'] = name

        if new_password:
            # 3. 如果有新密码，哈希后再更新
            update_data['password'] = make_password(new_password)

        return self.ctx.update(admin_instance, **update_data)


class EventareaService:
    """
    活动区域（Eventarea）的业务逻辑层

    提供与Eventarea模型相关的业务逻辑处理方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_eventareas():
        """
        获取所有活动区域

        Returns:
            QuerySet: 活动区域的查询集
        """
        return EventareaContext.get_all_eventareas()

    @staticmethod
    def get_eventarea_by_id(eventarea_id):
        """
        根据ID获取活动区域

        Args:
            eventarea_id: 活动区域ID

        Returns:
            Eventarea: 活动区域对象
        """
        return EventareaContext.get_eventarea_by_id(eventarea_id)

    @staticmethod
    def create_eventarea(data):
        """
        创建新的活动区域

        Args:
            data: 活动区域数据

        Returns:
            Eventarea: 创建的活动区域对象
        """
        # 业务逻辑验证
        # 1. 验证数据完整性
        required_fields = ['is_active', 'description', 'organizer_name', 'organizer_phone', 'type']
        for field in required_fields:
            if field not in data:
                raise ValueError(f"Field '{field}' is required")

        # 2. 验证电话号码格式
        # 这里可以添加更复杂的电话号码验证逻辑
        if len(data['organizer_phone']) < 10:
            raise ValueError("Phone number must be at least 10 characters long")

        # 3. 验证类型是否合法
        valid_types = ['exhibition', 'concert', 'meeting', 'other']  # 根据实际需求调整
        if data['type'] not in valid_types:
            raise ValueError(f"Invalid type. Valid types are: {', '.join(valid_types)}")

        # 4. 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        return EventareaContext.create_eventarea(data)

    @staticmethod
    def update_eventarea(eventarea_id, data):
        """
        更新活动区域

        Args:
            eventarea_id: 活动区域ID
            data: 更新数据

        Returns:
            Eventarea: 更新后的活动区域对象
        """
        # 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        # 如果有其他业务逻辑验证，可以在这里添加

        return EventareaContext.update_eventarea(eventarea_id, data)

    @staticmethod
    def delete_eventarea(eventarea_id):
        """
        删除活动区域

        Args:
            eventarea_id: 活动区域ID
        """
        # 业务逻辑验证
        # 1. 验证活动区域是否存在
        eventarea = EventareaContext.get_eventarea_by_id(eventarea_id)

        # 2. 验证是否有相关联的活动
        if eventarea.event_set.exists():
            raise ValueError("Cannot delete eventarea with associated events")

        return EventareaContext.delete_eventarea(eventarea_id)


class OtherareaService:
    """
    其他区域（Otherarea）的业务逻辑层

    提供与Otherarea模型相关的业务逻辑处理方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_otherareas():
        """
        获取所有其他区域

        Returns:
            QuerySet: 其他区域的查询集
        """
        return OtherareaContext.get_all_otherareas()

    @staticmethod
    def get_otherarea_by_id(otherarea_id):
        """
        根据ID获取其他区域

        Args:
            otherarea_id: 其他区域ID

        Returns:
            Otherarea: 其他区域对象
        """
        return OtherareaContext.get_otherarea_by_id(otherarea_id)

    @staticmethod
    def create_otherarea(data):
        """
        创建新的其他区域

        Args:
            data: 其他区域数据

        Returns:
            Otherarea: 创建的其他区域对象
        """
        # 业务逻辑验证
        # 1. 验证数据完整性
        required_fields = ['is_active', 'description', 'type', 'is_public']
        for field in required_fields:
            if field not in data:
                raise ValueError(f"Field '{field}' is required")

        # 2. 验证类型是否合法
        valid_types = ['restroom', 'parking', 'entrance', 'exit', 'staircase', 'elevator', 'other']  # 根据实际需求调整
        if data['type'] not in valid_types:
            raise ValueError(f"Invalid type. Valid types are: {', '.join(valid_types)}")

        # 3. 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        return OtherareaContext.create_otherarea(data)

    @staticmethod
    def update_otherarea(otherarea_id, data):
        """
        更新其他区域

        Args:
            otherarea_id: 其他区域ID
            data: 更新数据

        Returns:
            Otherarea: 更新后的其他区域对象
        """
        # 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        # 如果有其他业务逻辑验证，可以在这里添加

        return OtherareaContext.update_otherarea(otherarea_id, data)

    @staticmethod
    def delete_otherarea(otherarea_id):
        """
        删除其他区域

        Args:
            otherarea_id: 其他区域ID
        """
        # 业务逻辑验证
        # 1. 验证其他区域是否存在
        otherarea = OtherareaContext.get_otherarea_by_id(otherarea_id)

        # 2. 可以添加其他验证逻辑

        return OtherareaContext.delete_otherarea(otherarea_id)


class EventService:
    """
    活动（Event）的业务逻辑层

    提供与Event模型相关的业务逻辑操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_events():
        """
        获取所有活动

        Returns:
            QuerySet: 活动的查询集
        """
        return EventContext.get_all_events()

    @staticmethod
    def get_event_by_id(event_id):
        """
        根据ID获取活动

        Args:
            event_id: 活动ID

        Returns:
            Event: 活动对象
        """
        return EventContext.get_event_by_id(event_id)

    @staticmethod
    def create_event(data):
        """
        创建新的活动

        Args:
            data: 活动数据

        Returns:
            Event: 创建的活动对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 业务逻辑验证
        # 这里可以添加更多的业务逻辑验证

        return EventContext.create_event(data)

    @staticmethod
    def update_event(event_id, data):
        """
        更新活动

        Args:
            event_id: 活动ID
            data: 更新数据

        Returns:
            Event: 更新后的活动对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 业务逻辑验证
        # 这里可以添加更多的业务逻辑验证

        return EventContext.update_event(event_id, data)

    @staticmethod
    def delete_event(event_id):
        """
        删除活动

        Args:
            event_id: 活动ID
        """
        EventContext.delete_event(event_id)


class StoreareaService:
    """
    店铺区域（Storearea）的业务逻辑层

    提供与Storearea模型相关的业务逻辑操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_storeareas():
        """
        获取所有店铺区域

        Returns:
            QuerySet: 店铺区域的查询集
        """
        return StoreareaContext.get_all_storeareas()

    @staticmethod
    def get_storearea_by_id(storearea_id):
        """
        根据ID获取店铺区域

        Args:
            storearea_id: 店铺区域ID

        Returns:
            Storearea: 店铺区域对象
        """
        return StoreareaContext.get_storearea_by_id(storearea_id)

    @staticmethod
    def create_storearea(data):
        """
        创建新的店铺区域

        Args:
            data: 店铺区域数据

        Returns:
            Storearea: 创建的店铺区域对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 业务逻辑验证
        # 这里可以添加更多的业务逻辑验证

        return StoreareaContext.create_storearea(data)

    @staticmethod
    def update_storearea(storearea_id, data):
        """
        更新店铺区域

        Args:
            storearea_id: 店铺区域ID
            data: 更新数据

        Returns:
            Storearea: 更新后的店铺区域对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 业务逻辑验证
        # 这里可以添加更多的业务逻辑验证

        return StoreareaContext.update_storearea(storearea_id, data)

    @staticmethod
    def delete_storearea(storearea_id):
        """
        删除店铺区域
        
        Args:
            storearea_id: 店铺区域ID
        """
        StoreareaContext.delete_storearea(storearea_id)


class FacilityService:
    """
    设施（Facility）的业务逻辑层
    
    提供与Facility模型相关的业务逻辑处理方法
    注意：location属性由editor模块处理
    """

    @staticmethod
    def get_all_facilities():
        """
        获取所有设施
        
        Returns:
            QuerySet: 设施的查询集
        """
        return FacilityContext.get_all_facilities()

    @staticmethod
    def get_facility_by_id(facility_id):
        """
        根据ID获取设施
        
        Args:
            facility_id: 设施ID
        
        Returns:
            Facility: 设施对象
        """
        return FacilityContext.get_facility_by_id(facility_id)

    @staticmethod
    def create_facility(data):
        """
        创建新的设施
        
        Args:
            data: 设施数据
        
        Returns:
            Facility: 创建的设施对象
        """
        # 业务逻辑验证
        # 1. 验证数据完整性
        required_fields = ['is_active', 'description', 'type']
        for field in required_fields:
            if field not in data:
                raise ValueError(f"Field '{field}' is required")

        # 2. 验证类型是否合法（根据实际需求调整）
        # 这里假设type是整数类型，表示不同的设施类型

        # 3. 如果提供了location属性，将其移除（location属性由editor模块处理）
        if 'location' in data:
            data.pop('location')

        return FacilityContext.create_facility(data)

    @staticmethod
    def update_facility(facility_id, data):
        """
        更新设施
        
        Args:
            facility_id: 设施ID
            data: 更新数据
        
        Returns:
            Facility: 更新后的设施对象
        """
        # 如果提供了location属性，将其移除（location属性由editor模块处理）
        if 'location' in data:
            data.pop('location')

        # 如果有其他业务逻辑验证，可以在这里添加

        return FacilityContext.update_facility(facility_id, data)

    @staticmethod
    def delete_facility(facility_id):
        """
        删除设施
        
        Args:
            facility_id: 设施ID
        """
        # 业务逻辑验证
        # 1. 验证设施是否存在
        facility = FacilityContext.get_facility_by_id(facility_id)

        # 2. 可以添加其他验证逻辑

        return FacilityContext.delete_facility(facility_id)


================================================================================
文件路径: python-backend\management\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.
from rest_framework.test import APITestCase
from rest_framework import status
from django.urls import reverse
from core.models import Admin
from django.contrib.auth.hashers import check_password, make_password


class AdminAuthAPITestCase(APITestCase):
    """
    测试管理员注册、登录、注销接口 (AdminAuthView)
    """

    def setUp(self):
        # 预先定义好路由名称
        self.register_url = reverse('admin-auth', kwargs={'action': 'register'})
        self.login_url = reverse('admin-auth', kwargs={'action': 'login'})
        self.logout_url = reverse('admin-auth', kwargs={'action': 'logout'})
        self.profile_url = reverse('admin-profile')  # 档案管理路由

        # 注册一个测试管理员供后续登录测试使用
        self.account = "testuser"
        self.password = "password123"
        self.admin = Admin.objects.create(
            account=self.account,
            password=make_password(self.password),  # 注意: 这里是明文，在测试中我们会手动进行哈希检查
            name="Original Name"
        )
        # # 注意: 真实的 AdminService.register_admin 会自动哈希密码，但这里我们绕过 Service 直接创建，
        # # 所以必须手动设置哈希后的密码才能通过 login 测试。
        # self.admin.password = check_password(self.password, 'fake_hash')  # 任意哈希值
        # self.admin.save()

    # ------------------ 注册 (Register) 测试 ------------------

    def test_register_success(self):
        """测试成功注册新管理员"""
        data = {"account": "newadmin", "password": "newpassword456", "name": "New Admin"}
        response = self.client.post(self.register_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Admin.objects.count(), 2)
        self.assertEqual(response.data['account'], 'newadmin')

        # 验证密码是否被哈希存储
        new_admin = Admin.objects.get(account='newadmin')
        self.assertTrue(check_password("newpassword456", new_admin.password))

    def test_register_duplicate_account(self):
        """测试注册时账号重复"""
        data = {"account": self.account, "password": "somepassword", "name": "Duplicate User"}
        response = self.client.post(self.register_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('account already exists', response.data['error'].lower())
        self.assertEqual(Admin.objects.count(), 1)  # 确认没有创建新用户

    # ------------------ 登录 (Login) 测试 ------------------

    def test_login_success(self):
        """测试成功登录"""
        data = {"account": self.account, "password": self.password}
        response = self.client.post(self.login_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['account'], self.account)
        # 验证 Session 是否被正确设置 (检查响应中的 session key)
        self.assertIn('sessionid', response.cookies)
        self.assertTrue(self.client.session.get('admin_id'))

    def test_login_failure_wrong_password(self):
        """测试密码错误导致登录失败"""
        data = {"account": self.account, "password": "wrongpassword"}
        response = self.client.post(self.login_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertIn('Invalid account or password', response.data['error'])

    def test_login_failure_non_existent_account(self):
        """测试账号不存在导致登录失败"""
        data = {"account": "nonexistent", "password": "anypassword"}
        response = self.client.post(self.login_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertIn('Invalid account or password', response.data['error'])

    # ------------------ 注销 (Logout) 测试 ------------------

    def test_logout_success(self):
        """测试成功注销"""
        # 先登录以设置 Session
        self.client.post(self.login_url, {"account": self.account, "password": self.password}, format='json')

        # 执行注销
        response = self.client.post(self.logout_url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        # 验证 Session 是否被清除
        self.assertIsNone(self.client.session.get('admin_id'))


class AdminProfileAPITestCase(APITestCase):
    """
    测试管理员档案管理接口 (AdminProfileView)
    """

    def setUp(self):
        self.login_url = reverse('admin-auth', kwargs={'action': 'login'})
        self.profile_url = reverse('admin-profile')

        self.account = "profileuser"
        self.password = "profilepass"

        # 手动创建 Admin 实例,确保密码哈希
        hashed_password = make_password(self.password)
        self.admin = Admin.objects.create(
            account=self.account,
            password=hashed_password,
            name="Profile Target"
        )

        # 登录并获取 Session Cookie
        self.client.post(self.login_url, {"account": self.account, "password": self.password}, format='json')
        # self.admin = Admin.objects.get(account=self.account)  # 获取实例

    # ------------------ 权限 (Authorization) 测试 ------------------

    def test_profile_requires_authentication(self):
        """测试未登录用户无法访问 Profile 接口"""
        self.client.logout()  # 清除 Session
        response_get = self.client.get(self.profile_url, format='json')
        response_put = self.client.put(self.profile_url, {"name": "fail"}, format='json')

        self.assertEqual(response_get.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertEqual(response_put.status_code, status.HTTP_401_UNAUTHORIZED)

    # ------------------ 获取信息 (GET) 测试 ------------------

    def test_get_profile_success(self):
        """测试成功获取个人信息"""
        response = self.client.get(self.profile_url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['account'], self.account)
        self.assertEqual(response.data['name'], "Profile Target")
        self.assertNotIn('password', response.data)  # 确保密码没有被泄露

    # ------------------ 修改信息 (PUT/PATCH) 测试 ------------------

    def test_update_name_success(self):
        """测试成功修改姓名"""
        new_name = "Updated User Name"
        response = self.client.put(self.profile_url, {"name": new_name}, format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['name'], new_name)

        # 验证数据库中的值已更新
        self.admin.refresh_from_db()
        self.assertEqual(self.admin.name, new_name)

    def test_update_password_success(self):
        """测试成功修改密码"""
        new_password = "verysecurepassword"
        response = self.client.put(self.profile_url, {"new_password": new_password}, format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['account'], self.account)

        # 验证新的密码能否用于登录
        self.admin.refresh_from_db()
        self.assertTrue(check_password(new_password, self.admin.password))

        # 验证旧密码失效
        self.assertFalse(check_password(self.password, self.admin.password))

    def test_update_both_success(self):
        """测试同时修改姓名和密码"""
        new_name = "Final Name"
        new_password = "FinalPassword"

        response = self.client.put(self.profile_url,
                                   {"name": new_name, "new_password": new_password},
                                   format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['name'], new_name)

        # 验证数据库
        self.admin.refresh_from_db()
        self.assertEqual(self.admin.name, new_name)
        self.assertTrue(check_password(new_password, self.admin.password))


================================================================================
文件路径: python-backend\management\urls.py
--------------------------------------------------------------------------------

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import EventareaViewSet, OtherareaViewSet, EventViewSet, StoreareaViewSet, FacilityViewSet

# 创建路由器并注册视图集
router = DefaultRouter()
router.register(r'eventarea', EventareaViewSet, basename='management_eventarea')
router.register(r'otherarea', OtherareaViewSet, basename='management_otherarea')
router.register(r'event', EventViewSet, basename='management_event')
router.register(r'storearea', StoreareaViewSet, basename='management_storearea')
router.register(r'facility', FacilityViewSet, basename='management_facility')

urlpatterns = [
    # 包含路由器生成的所有URL
    path('', include(router.urls)),
]



================================================================================
文件路径: python-backend\management\views.py
--------------------------------------------------------------------------------

from rest_framework import viewsets, status
from rest_framework.response import Response
from django.shortcuts import get_object_or_404
from .serializers import get_eventarea_serializer, get_otherarea_serializer, get_event_serializer, get_storearea_serializer, get_facility_serializer
from .services import EventareaService, OtherareaService, EventService, StoreareaService, FacilityService


class EventareaViewSet(viewsets.ModelViewSet):
    """
    活动区域（Eventarea）的视图集
    
    注意：
    - 在management模块中处理除shape属性外的所有其他属性
    - shape属性的操作由editor模块处理
    - 不允许修改shape属性
    
    支持的操作：
    - GET /api/management/eventarea/ - 获取所有活动区域列表
    - GET /api/management/eventarea/{id}/ - 获取指定活动区域详情
    - POST /api/management/eventarea/ - 创建新的活动区域
    - PUT /api/management/eventarea/{id}/ - 完整更新活动区域（不包括shape）
    - PATCH /api/management/eventarea/{id}/ - 部分更新活动区域（不包括shape）
    - DELETE /api/management/eventarea/{id}/ - 删除指定活动区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_eventarea_serializer()
    
    def get_queryset(self):
        """获取所有活动区域"""
        return EventareaService.get_all_eventareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动区域列表"""
        eventareas = EventareaService.get_all_eventareas()
        serializer = self.get_serializer(eventareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动区域详情"""
        eventarea = get_object_or_404(EventareaService.get_all_eventareas(), pk=pk)
        serializer = self.get_serializer(eventarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的活动区域"""
        try:
            # 检查是否包含shape属性，如果包含则移除
            data = request.data.copy()
            if 'shape' in data:
                data.pop('shape')
            
            eventarea = EventareaService.create_eventarea(data)
            serializer = self.get_serializer(eventarea)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新活动区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            eventarea = EventareaService.update_eventarea(pk, request.data)
            serializer = self.get_serializer(eventarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新活动区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            eventarea = EventareaService.update_eventarea(pk, request.data)
            serializer = self.get_serializer(eventarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """删除指定活动区域"""
        try:
            EventareaService.delete_eventarea(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class OtherareaViewSet(viewsets.ModelViewSet):
    """
    其他区域（Otherarea）的视图集
    
    注意：
    - 在management模块中处理除shape属性外的所有其他属性
    - shape属性的操作由editor模块处理
    - 不允许修改shape属性
    
    支持的操作：
    - GET /api/management/otherarea/ - 获取所有其他区域列表
    - GET /api/management/otherarea/{id}/ - 获取指定其他区域详情
    - POST /api/management/otherarea/ - 创建新的其他区域
    - PUT /api/management/otherarea/{id}/ - 完整更新其他区域（不包括shape）
    - PATCH /api/management/otherarea/{id}/ - 部分更新其他区域（不包括shape）
    - DELETE /api/management/otherarea/{id}/ - 删除指定其他区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_otherarea_serializer()
    
    def get_queryset(self):
        """获取所有其他区域"""
        return OtherareaService.get_all_otherareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有其他区域列表"""
        otherareas = OtherareaService.get_all_otherareas()
        serializer = self.get_serializer(otherareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定其他区域详情"""
        otherarea = get_object_or_404(OtherareaService.get_all_otherareas(), pk=pk)
        serializer = self.get_serializer(otherarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的其他区域"""
        try:
            # 检查是否包含shape属性，如果包含则移除
            data = request.data.copy()
            if 'shape' in data:
                data.pop('shape')
            
            otherarea = OtherareaService.create_otherarea(data)
            serializer = self.get_serializer(otherarea)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新其他区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            otherarea = OtherareaService.update_otherarea(pk, request.data)
            serializer = self.get_serializer(otherarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新其他区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            otherarea = OtherareaService.update_otherarea(pk, request.data)
            serializer = self.get_serializer(otherarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """删除指定其他区域"""
        try:
            OtherareaService.delete_otherarea(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class EventViewSet(viewsets.ModelViewSet):
    """
    活动（Event）的视图集
    
    支持的操作：
    - GET /api/management/event/ - 获取所有活动列表
    - GET /api/management/event/{id}/ - 获取指定活动详情
    - POST /api/management/event/ - 创建新的活动
    - PUT /api/management/event/{id}/ - 完整更新活动
    - PATCH /api/management/event/{id}/ - 部分更新活动
    - DELETE /api/management/event/{id}/ - 删除指定活动
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_event_serializer()
    
    def get_queryset(self):
        """获取所有活动"""
        return EventService.get_all_events()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动列表"""
        events = EventService.get_all_events()
        serializer = self.get_serializer(events, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动详情"""
        event = get_object_or_404(EventService.get_all_events(), pk=pk)
        serializer = self.get_serializer(event)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的活动"""
        try:
            event = EventService.create_event(request.data)
            serializer = self.get_serializer(event)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新活动"""
        try:
            event = EventService.update_event(pk, request.data)
            serializer = self.get_serializer(event)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新活动"""
        try:
            event = EventService.update_event(pk, request.data)
            serializer = self.get_serializer(event)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """删除指定活动"""
        try:
            EventService.delete_event(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class StoreareaViewSet(viewsets.ModelViewSet):
    """
    店铺区域（Storearea）的视图集
    
    注意：
    - 不处理shape属性，该属性由editor模块处理
    
    支持的操作：
    - GET /api/management/storearea/ - 获取所有店铺区域列表
    - GET /api/management/storearea/{id}/ - 获取指定店铺区域详情
    - POST /api/management/storearea/ - 创建新的店铺区域
    - PUT /api/management/storearea/{id}/ - 完整更新店铺区域（不包括shape）
    - PATCH /api/management/storearea/{id}/ - 部分更新店铺区域（不包括shape）
    - DELETE /api/management/storearea/{id}/ - 删除指定店铺区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_storearea_serializer()
    
    def get_queryset(self):
        """获取所有店铺区域"""
        return StoreareaService.get_all_storeareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有店铺区域列表"""
        storeareas = StoreareaService.get_all_storeareas()
        serializer = self.get_serializer(storeareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定店铺区域详情"""
        storearea = get_object_or_404(StoreareaService.get_all_storeareas(), pk=pk)
        serializer = self.get_serializer(storearea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的店铺区域"""
        try:
            # 检查是否包含shape属性，如果包含则移除
            data = request.data.copy()
            if 'shape' in data:
                data.pop('shape')
            
            storearea = StoreareaService.create_storearea(data)
            serializer = self.get_serializer(storearea)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新店铺区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            storearea = StoreareaService.update_storearea(pk, request.data)
            serializer = self.get_serializer(storearea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新店铺区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            storearea = StoreareaService.update_storearea(pk, request.data)
            serializer = self.get_serializer(storearea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """
        删除指定店铺区域
        """
        try:
            StoreareaService.delete_storearea(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class FacilityViewSet(viewsets.ModelViewSet):
    """
    设施（Facility）的视图集
    
    注意：
    - 在management模块中处理除location属性外的所有其他属性
    - location属性的操作由editor模块处理
    - 不允许修改location属性
    
    支持的操作：
    - GET /api/management/facility/ - 获取所有设施列表
    - GET /api/management/facility/{id}/ - 获取指定设施详情
    - POST /api/management/facility/ - 创建新的设施
    - PUT /api/management/facility/{id}/ - 完整更新设施（不包括location）
    - PATCH /api/management/facility/{id}/ - 部分更新设施（不包括location）
    - DELETE /api/management/facility/{id}/ - 删除指定设施
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_facility_serializer()
    
    def get_queryset(self):
        """获取所有设施"""
        return FacilityService.get_all_facilities()
    
    def list(self, request, *args, **kwargs):
        """获取所有设施列表"""
        facilities = FacilityService.get_all_facilities()
        serializer = self.get_serializer(facilities, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定设施详情"""
        facility = get_object_or_404(FacilityService.get_all_facilities(), pk=pk)
        serializer = self.get_serializer(facility)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的设施"""
        try:
            # 检查是否包含location属性，如果包含则移除
            data = request.data.copy()
            if 'location' in data:
                data.pop('location')
            
            facility = FacilityService.create_facility(data)
            serializer = self.get_serializer(facility)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新设施（不包括location）"""
        try:
            # 检查是否包含location属性，如果包含则返回错误
            if 'location' in request.data:
                return Response(
                    {'error': 'Location attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            facility = FacilityService.update_facility(pk, request.data)
            serializer = self.get_serializer(facility)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新设施（不包括location）"""
        try:
            # 检查是否包含location属性，如果包含则返回错误
            if 'location' in request.data:
                return Response(
                    {'error': 'Location attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            facility = FacilityService.update_facility(pk, request.data)
            serializer = self.get_serializer(facility)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """删除指定设施"""
        try:
            FacilityService.delete_facility(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.core.exceptions import ValidationError
from django.http import HttpRequest

from .services import AdminService
from .serializers import AdminRegisterSerializer, AdminLoginSerializer, AdminUpdateSerializer, AdminProfileSerializer
from core.models import Admin
from core.context import BaseContext


class AdminAuthMixin:
    """一个简单的用于检查管理员登录状态并加载 Admin 实例的 Mixin"""
    @staticmethod
    def get_admin_user(request: HttpRequest) -> Admin | None:
        admin_id = request.session.get('admin_id')
        if admin_id:
            try:
                # 使用 BaseContext 或 AdminContext 获取实例
                return BaseContext(Admin).get_by_id(admin_id)
            except Admin.DoesNotExist:
                del request.session['admin_id']  # 清理过期会话
                return None
        return None


class AdminAuthView(APIView):
    """
    处理管理员的注册、登录、注销
    POST /api/management/auth/register/
    POST /api/management/auth/login/
    POST /api/management/auth/logout/
    """
    service_class = AdminService

    def post(self, request, action):
        service = self.service_class()

        if action == 'register':
            serializer = AdminRegisterSerializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            try:
                admin = service.register_admin(**serializer.validated_data)
                return Response(AdminProfileSerializer(admin).data, status=status.HTTP_201_CREATED)
            except ValidationError as e:
                return Response({"error": e.message}, status=status.HTTP_400_BAD_REQUEST)

        elif action == 'login':
            serializer = AdminLoginSerializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            admin = service.login_admin(**serializer.validated_data)

            if admin:
                # 登录成功：在 session 中设置 ID
                request.session['admin_id'] = admin.id
                return Response(AdminProfileSerializer(admin).data, status=status.HTTP_200_OK)
            else:
                return Response({"error": "Invalid account or password"}, status=status.HTTP_401_UNAUTHORIZED)

        elif action == 'logout':
            if 'admin_id' in request.session:
                del request.session['admin_id']  # 清除 session
            return Response({"message": "Logout successful"}, status=status.HTTP_200_OK)

        else:
            return Response({"error": "Invalid action"}, status=status.HTTP_400_BAD_REQUEST)


# --- 个人信息接口 ---
class AdminProfileView(AdminAuthMixin, APIView):
    """
    处理管理员个人信息的获取和修改
    GET /api/management/profile/
    PUT/PATCH /api/management/profile/
    """
    service_class = AdminService
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.admin_user = None # 初始化实例属性
        
    def dispatch(self, request, *args, **kwargs):
        # 在处理请求前，先检查登录状态并加载 Admin 实例
        self.admin_user = self.get_admin_user(request)
        if not self.admin_user:
            return Response({"error": "Authentication credentials were not provided."},
                            status=status.HTTP_401_UNAUTHORIZED)
        return super().dispatch(request, *args, **kwargs)

    def get(self, request):
        """获取当前登录管理员的个人信息"""
        # self.admin_user 已在 dispatch 中加载并验证
        return Response(AdminProfileSerializer(self.admin_user).data)

    def put(self, request):
        """修改当前登录管理员的个人信息 (PUT/PATCH 通用)"""
        serializer = AdminUpdateSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        service = self.service_class()

        updated_admin = service.update_profile(
            admin_instance=self.admin_user,
            name=serializer.validated_data.get('name'),
            new_password=serializer.validated_data.get('new_password')
        )

        return Response(AdminProfileSerializer(updated_admin).data, status=status.HTTP_200_OK)


================================================================================
文件路径: python-backend\management\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\management\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\map\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\map\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig



class MapConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'map'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\map\context.py
--------------------------------------------------------------------------------

from core.models import Map, Storearea, Facility, Otherarea, Eventarea
from django.db.models import Q
from core.context import BaseContext


class MapContext(BaseContext):
    def __init__(self):
        super().__init__(Map)

    def get_map_with_building(self, map_id):
        """获取地图并预加载建筑信息"""
        try:
            return self.model.objects.select_related('building').get(pk=map_id)
        except self.model.DoesNotExist:
            return None

    @staticmethod
    def get_map_elements(map_obj):
        """一次性获取地图关联的所有元素 ID"""
        # 注意：这里只负责取数据，不负责格式化
        store_ids = map_obj.storeareamap_set.values_list('storearea_id', flat=True)
        facility_ids = map_obj.facilitymap_set.values_list('facility_id', flat=True)
        other_ids = map_obj.otherareamap_set.values_list('otherarea_id', flat=True)
        event_ids = map_obj.eventareamap_set.values_list('eventarea_id', flat=True)
        return store_ids, facility_ids, other_ids, event_ids

    def list_all_with_building(self):
        """获取所有地图列表，并预加载建筑信息"""
        return self.model.objects.select_related('building').all()

    def check_exists(self, building_id, floor_number):
        """检查特定楼层是否存在"""
        return self.model.objects.filter(building_id=building_id, floor_number=floor_number).exists()

    def create_map_record(self, building_id, floor_number, geometry):
        """创建地图记录"""
        return self.create(
            building_id=building_id,
            floor_number=floor_number,
            detail=geometry
        )

class ElementContext:
    """负责处理具体的商铺、设施等元素"""

    @staticmethod
    def get_stores_by_ids(ids):
        return Storearea.objects.filter(id__in=ids)

    @staticmethod
    def get_facilities_by_ids(ids):
        return Facility.objects.filter(id__in=ids)

    @staticmethod
    def get_others_by_ids(ids):
        return Otherarea.objects.filter(id__in=ids)

    @staticmethod
    def get_events_by_ids(ids):
        return Eventarea.objects.filter(id__in=ids)

    @staticmethod
    def search_globally(keyword):
        stores = Storearea.objects.filter(store_name__icontains=keyword)
        others = Otherarea.objects.filter(description__icontains=keyword, is_public=True)
        return stores, others


================================================================================
文件路径: python-backend\map\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from core.models import Map, Storearea, Facility, Otherarea, Eventarea
import json


# ==========================================
# 1. 子元素序列化器 (先定义，供 MapSerializer 调用)
# ==========================================

class OtherareaSerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Otherarea
        # 将 is_public 暴露出来，前端可以用不同颜色渲染
        fields = ['id', 'type', 'description', 'is_public',  'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.shape: return None
        return json.loads(obj.shape.geojson)


class StoreareaSerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Storearea
        fields = ['id', 'store_name', 'type', 'logo_url', 'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.shape: return None
        return json.loads(obj.shape.geojson)


class FacilitySerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Facility
        fields = ['id', 'type', 'description', 'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.location: return None
        return json.loads(obj.location.geojson)


class EventareaSerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Eventarea
        fields = ['id', 'description',  'type', 'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.shape: return None
        return json.loads(obj.shape.geojson)


# ==========================================
# 2. 地图聚合序列化器 (核心修改部分)
# ==========================================

class MapSerializer(serializers.ModelSerializer):
    """
    地图详情：包含该楼层的底图几何信息，以及关联的商铺、设施等。
    """
    building_name = serializers.CharField(source='building.name', read_only=True)
    detail_geojson = serializers.SerializerMethodField()

    # --- 关键修改开始 ---
    # 使用 source='temp_xxx' 对应 MapDisplayService 中挂载的属性名
    # read_only=True 表示这些字段只用于输出，不用于写入
    stores = StoreareaSerializer(source='temp_stores', many=True, read_only=True)
    facilities = FacilitySerializer(source='temp_facilities', many=True, read_only=True)
    other_areas = OtherareaSerializer(source='temp_others', many=True, read_only=True)
    events = EventareaSerializer(source='temp_events', many=True, read_only=True)

    # --- 关键修改结束 ---

    class Meta:
        model = Map
        fields = [
            'id',
            'building_id',
            'building_name',
            'floor_number',
            'detail_geojson',
            # 必须把新字段加入 fields 列表
            'stores',
            'facilities',
            'other_areas',
            'events'
        ]

    @staticmethod
    def get_detail_geojson(obj):
        """
        处理底图几何 (外轮廓 + 镂空)
        """
        if not obj.detail:
            return None

        # 保持原始坐标系 (SRID 2385)，方便前端计算米制距离
        # 如果需要经纬度，需在此处 clone().transform(4326)
        geometry = obj.detail.clone()
        return json.loads(geometry.geojson)


================================================================================
文件路径: python-backend\map\services.py
--------------------------------------------------------------------------------

from django.contrib.gis.geos import GEOSGeometry, Polygon
from typing import Tuple, List
from map.context import MapContext, ElementContext
import json
from django.contrib.gis.geos import GEOSGeometry


# ==========================================
# Part 1: 纯几何算法 (保持不变)
# ==========================================
class GeometryAlgorithms:
    @staticmethod
    def validate_shape_syntax(geometry: GEOSGeometry) -> Tuple[bool, str]:
        if geometry is None: return False, "Geometry is None"
        if not geometry.valid: return False, f"Invalid Geometry: {geometry.valid_reason}"
        if isinstance(geometry, Polygon) and geometry.empty: return False, "Polygon is empty"
        return True, "Valid"

    @staticmethod
    def get_distance_between_areas(shape1: GEOSGeometry, shape2: GEOSGeometry) -> float:
        """
        接口 3: 获取输入的两个区域之间的距离
        """
        if not shape1 or not shape2:
            return -1.0
        # distance() 计算的是两个几何体之间最近点的欧几里得距离
        # 单位取决于 SRID (2385 为米)
        return shape1.distance(shape2)

    @staticmethod
    def validate_holes_inside_shell(outer_shell: GEOSGeometry, holes: List[GEOSGeometry]) -> Tuple[bool, str]:
        """
        接口 2: 镂空本身有无超出外轮廓区域
        """
        if not outer_shell:
            return False, "Outer shell is missing"

        if not holes:
            return True, "No holes to validate"

        for i, hole in enumerate(holes, start=1):
            # hole 必须完全在 outer_shell 内部 (contains)
            # 任何一部分超出或仅仅是相交都算非法
            if not outer_shell.contains(hole):
                return False, f"Hole #{i} is outside or intersecting the map boundary."

        return True, "All holes are valid"

    @staticmethod
    def check_placement(new_shape, outer_shell, holes, existing_obstacles):
        if not outer_shell: return False, "Map shell missing"
        if not outer_shell.contains(new_shape): return False, "Area exceeds map outer boundary"
        for i, hole in enumerate(holes):
            if hole.intersects(new_shape): return False, f"Area intersects with map hole #{i + 1}"
        for existing_shape in existing_obstacles:
            if existing_shape and existing_shape.intersects(new_shape):
                return False, "Area overlaps with an existing area"
        return True, "Placement valid"


# ==========================================
# Part 2: 业务服务 (修改部分)
# ==========================================

class MapDisplayService:
    """
    地图显示与校验服务
    """

    def __init__(self):
        self.map_ctx = MapContext()
        self.elem_ctx = ElementContext()

    def get_full_map_details(self, map_id):
        map_obj = self.map_ctx.get_map_with_building(map_id)
        if not map_obj: return None

        s_ids, f_ids, o_ids, e_ids = self.map_ctx.get_map_elements(map_obj)

        map_obj.temp_stores = self.elem_ctx.get_stores_by_ids(s_ids)
        map_obj.temp_facilities = self.elem_ctx.get_facilities_by_ids(f_ids)
        map_obj.temp_others = self.elem_ctx.get_others_by_ids(o_ids)
        map_obj.temp_events = self.elem_ctx.get_events_by_ids(e_ids)

        return map_obj

    def validate_geometry(self, geometry, map_id, exclude_id=None, area_type=None):
        """
        几何校验业务流程
        """
        # 1. 几何语法校验
        is_valid, msg = GeometryAlgorithms.validate_shape_syntax(geometry)
        if not is_valid:
            return False, msg

        # 2. 获取地图数据
        map_obj = self.map_ctx.get_map_with_building(map_id)
        if not map_obj or not map_obj.detail:
            return False, "Map data not found or empty"

        # 解析外轮廓和镂空
        outer_shell = map_obj.detail[0]
        holes = list(map_obj.detail[1:]) if len(map_obj.detail) > 1 else []

        # 3. 获取所有障碍物 (修改点：在 Service 层组装数据)
        obstacles = self._collect_obstacles(map_obj, exclude_id, area_type)

        # 4. 调用算法进行物理放置校验
        return GeometryAlgorithms.check_placement(
            new_shape=geometry,
            outer_shell=outer_shell,
            holes=holes,
            existing_obstacles=obstacles
        )

    def _collect_obstacles(self, map_obj, exclude_id, area_type) -> List[GEOSGeometry]:
        """
        私有辅助方法：利用 MapContext 和 ElementContext 收集该地图上所有实体的形状
        """
        obstacles = []

        # 1. 从 MapContext 获取所有关联 ID
        s_ids, f_ids, o_ids, e_ids = self.map_ctx.get_map_elements(map_obj)

        # 辅助函数：处理排除逻辑
        def should_include(item_id, item_type):
            # 如果类型相同且 ID 相同，则排除（说明是正在编辑的那个对象）
            if area_type == item_type and str(item_id) == str(exclude_id):
                return False
            return True

        # 2. 从 ElementContext 获取对象并提取形状

        # A. 商铺 (Stores)
        stores = self.elem_ctx.get_stores_by_ids(s_ids)
        for s in stores:
            if should_include(s.id, 'store') and s.shape:
                obstacles.append(s.shape)

        # B. 设施 (Facilities) - 需要 Buffer 处理
        facilities = self.elem_ctx.get_facilities_by_ids(f_ids)
        for f in facilities:
            if should_include(f.id, 'facility') and f.location:
                # 设施通常是点，必须膨胀成多边形才能进行碰撞检测
                # 假设半径 0.5 米
                obstacles.append(f.location.buffer(0.5))

        # C. 其他区域 (Otherareas)
        others = self.elem_ctx.get_others_by_ids(o_ids)
        for o in others:
            if should_include(o.id, 'other') and o.shape:
                obstacles.append(o.shape)

        # D. 活动区域 (Events)
        events = self.elem_ctx.get_events_by_ids(e_ids)
        for e in events:
            if should_include(e.id, 'event') and e.shape and e.is_active:
                obstacles.append(e.shape)

        return obstacles

    def get_map_list(self):
        """
        获取地图列表概要
        """
        # 1. 从 Context 获取所有地图
        maps = self.map_ctx.list_all_with_building()

        # 2. 初始化空属性，防止 MapSerializer 报错
        # (因为列表页通常不需要加载 heavy 的商铺/设施数据，只看底图或基础信息)
        for map_obj in maps:
            map_obj.temp_stores = []
            map_obj.temp_facilities = []
            map_obj.temp_others = []
            map_obj.temp_events = []

        return maps

    def validate_batch(self, map_id, updates_list):
        """
        批量校验
        :param map_id: 地图ID
        :param updates_list: 预处理过的列表，每项包含 'geos_obj' (GEOSGeometry)
        :return: (is_valid, errors_list)
        """
        # 1. 获取地图底图 (外框和镂空)
        map_obj = self.map_ctx.get_map_with_building(map_id)
        if not map_obj or not map_obj.detail:
            return False, ["地图数据缺失"]

        outer_shell = map_obj.detail[0]
        holes = list(map_obj.detail[1:]) if len(map_obj.detail) > 1 else []

        # 2. 整理新数据 (不再需要解析 JSON，直接取对象)
        new_geometries = []
        updated_keys = set()

        for item in updates_list:
            # 直接获取 View 层解析好的几何对象
            shape = item['geos_obj']

            # 统一为多边形用于碰撞检测 (点 -> 圆)
            collision_shape = shape.buffer(0.3) if shape.geom_type == 'Point' else shape

            item_type = str(item.get('type')).lower()
            item_id = str(item.get('id'))

            new_geometries.append({
                'id': item_id,
                'type': item_type,
                'shape': collision_shape,
                'name': item.get('name', 'Unknown')
            })

            key = f"{item_type}-{item_id}"
            updated_keys.add(key)

        # 3. 从数据库获取“背景障碍物” (排除掉在 updated_keys 里的项)
        s_ids, f_ids, o_ids, e_ids = self.map_ctx.get_map_elements(map_obj)
        static_obstacles = []

        def add_static(objects, type_name):
            for obj in objects:
                key = f"{type_name}-{str(obj.id)}"
                if key not in updated_keys:
                    shape = getattr(obj, 'shape', None)
                    if type_name == 'facility':
                        loc = getattr(obj, 'location', None)
                        if loc: shape = loc.buffer(0.3)

                    if shape:
                        static_obstacles.append(shape)

        add_static(self.elem_ctx.get_stores_by_ids(s_ids), 'store')
        add_static(self.elem_ctx.get_facilities_by_ids(f_ids), 'facility')
        add_static(self.elem_ctx.get_others_by_ids(o_ids), 'other')
        active_events = [e for e in self.elem_ctx.get_events_by_ids(e_ids) if e.is_active]
        add_static(active_events, 'event')

        # 4. 执行校验
        errors = []

        for curr in new_geometries:
            curr_shape = curr['shape']

            # 4.1 边界检查
            if not outer_shell.contains(curr_shape):
                errors.append(f"[{curr['name']}] 超出地图边界")
                continue

            for hole in holes:
                if hole.intersects(curr_shape) and not hole.touches(curr_shape):
                    errors.append(f"[{curr['name']}] 进入了地图镂空/中庭区域")
                    break

            # 4.2 静态障碍物碰撞
            for obs in static_obstacles:
                if obs.intersects(curr_shape) and not obs.touches(curr_shape):
                    errors.append(f"[{curr['name']}] 与未修改的固定区域重叠")
                    break

            # 4.3 动态物体互撞 (A 撞 B)
            for other in new_geometries:
                if curr['id'] == other['id'] and curr['type'] == other['type']:
                    continue

                if curr['type'] == 'facility' and other['type'] == 'facility':
                    continue

                if other['shape'].intersects(curr_shape) and not other['shape'].touches(curr_shape):
                    if curr['id'] < other['id']:
                        errors.append(f"[{curr['name']}] 与 [{other['name']}] 重叠")
                    break

        if len(errors) > 0:
            return False, errors

        return True, []


================================================================================
文件路径: python-backend\map\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.
from rest_framework.test import APITestCase
from rest_framework import status
from django.urls import reverse
from django.contrib.gis.geos import Polygon, GeometryCollection
from core.models import Building, Map, Storearea, StoreareaMap


class MapViewSetTestCase(APITestCase):
    """
    测试 MapViewSet 的 list 和 retrieve 接口
    验证从数据库到 Service 再到 View 的数据流是否正常
    """

    def setUp(self):
        """
        测试数据准备：
        1. 创建 Building
        2. 创建 Map (带 GeometryCollection)
        3. 创建 Storearea (带 Polygon)
        4. 建立 Map 和 Storearea 的关联
        """
        # 1. 创建建筑
        self.building = Building.objects.create(
            name="测试万达广场",
            address="上海市杨浦区"
        )

        # 2. 创建地图底图几何 (SRID 2385)
        # 假设是一个 100x100 的正方形外轮廓
        outer_shell = Polygon(((0, 0), (0, 100), (100, 100), (100, 0), (0, 0)), srid=2385)
        # detail 字段是 GeometryCollection
        map_detail = GeometryCollection(outer_shell, srid=2385)

        self.map_obj = Map.objects.create(
            building=self.building,
            floor_number=1,
            detail=map_detail
        )

        # 3. 创建商铺
        # 在地图内部创建一个 10x10 的小方块商铺
        store_shape = Polygon(((10, 10), (10, 20), (20, 20), (20, 10), (10, 10)), srid=2385)
        self.store = Storearea.objects.create(
            store_name="测试海底捞",
            type=1,
            shape=store_shape,
            owner_name="张三",
            owner_phone="123456",
            is_active = True
        )

        # 4. 关联商铺到地图 (重要：否则 retrieve 接口不会返回该商铺)
        StoreareaMap.objects.create(
            map=self.map_obj,
            storearea=self.store
        )

        # 路由名称定义 (对应 urls.py 中的 router.register(..., basename='maps'))
        self.list_url = reverse('map-list')
        self.detail_url = reverse('map-detail', args=[self.map_obj.id])

    def test_list_maps(self):
        """
        测试获取地图列表 (GET /api/maps/)
        """
        response = self.client.get(self.list_url)

        # 1. 验证状态码
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        # 2. 验证返回数据类型是列表
        self.assertIsInstance(response.data, list)
        self.assertEqual(len(response.data), 1)

        # 3. 验证基础字段
        map_data = response.data[0]
        self.assertEqual(map_data['floor_number'], 1)
        self.assertEqual(map_data['building_name'], "测试万达广场")

        # 4. 验证列表接口是否正确处理了 temp_stores (应该为空列表或不报错)
        # 根据我们之前的 Service 逻辑，列表接口为了性能可能没有加载 stores，或者加载了空列表
        if 'stores' in map_data:
            self.assertIsInstance(map_data['stores'], list)

    def test_retrieve_map_success(self):
        """
        测试获取单张地图详情 (GET /api/maps/{id}/)
        核心：验证 Service 是否成功组装了 detail_geojson 和 stores
        """
        response = self.client.get(self.detail_url)

        # 1. 验证状态码
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        data = response.data

        # 2. 验证底图几何 (detail_geojson)
        self.assertIn('detail_geojson', data)
        self.assertEqual(data['detail_geojson']['type'], 'GeometryCollection')

        # 3. 验证关联元素 (stores)
        # 这是验证 MapDisplayService.get_full_map_details 逻辑的关键
        self.assertIn('stores', data)
        self.assertEqual(len(data['stores']), 1)

        store_data = data['stores'][0]
        self.assertEqual(store_data['store_name'], "测试海底捞")
        self.assertEqual(store_data['id'], self.store.id)

        # 验证商铺的几何是否被正确序列化为 GeoJSON
        self.assertIn('geometry', store_data)
        self.assertEqual(store_data['geometry']['type'], 'Polygon')

        # 4. 验证其他空列表字段是否存在 (facilities, events, etc.)
        self.assertIn('facilities', data)
        self.assertEqual(data['facilities'], [])  # setUp中没创建设施，应为空列表

    def test_retrieve_map_not_found(self):
        """
        测试获取不存在的地图 ID
        """
        non_existent_url = reverse('map-detail', args=[99999])
        response = self.client.get(non_existent_url)

        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)


================================================================================
文件路径: python-backend\map\views.py
--------------------------------------------------------------------------------

from rest_framework import viewsets, status
from rest_framework.views import APIView
from rest_framework.response import Response
from django.contrib.gis.geos import GEOSGeometry
import json

from .serializers import MapSerializer  # 序列化器依然需要，用于格式化输出
from map.services import MapDisplayService


class MapViewSet(viewsets.ViewSet):
    """
    只读 ViewSet，不继承 ModelViewSet
    """
    service_class = MapDisplayService

    def list(self, request):
        """GET /api/maps/"""
        service = self.service_class()

        # 1. 调用 Service 获取列表
        maps = service.get_map_list()

        # 2. 序列化返回
        # 注意：这里会返回所有地图的 GeoJSON，数据量可能较大
        # 实际生产中建议单独定义一个 SimpleMapSerializer (不含 detail_geojson) 用于列表
        serializer = MapSerializer(maps, many=True)

        return Response(serializer.data)

    def retrieve(self, request, pk=None):
        """GET /api/maps/{id}/"""
        service = self.service_class()

        # 1. 调用 Service 获取组装好的对象
        map_data = service.get_full_map_details(pk)

        if not map_data:
            return Response({"error": "Map not found"}, status=status.HTTP_404_NOT_FOUND)

        # 2. 使用 Serializer 格式化 Service 返回的数据
        # 注意：Serializer 内部字段 source='temp_stores' 需要对应 Service 挂载的属性
        serializer = MapSerializer(map_data)
        return Response(serializer.data)


class MapValidationView(APIView):
    """POST /api/maps/validate/"""
    service_class = MapDisplayService

    def post(self, request):
        service = self.service_class()

        # 1. 参数提取
        geometry_data = request.data.get('geometry')
        map_id = request.data.get('map_id')
        area_type = request.data.get('type')
        exclude_id = request.data.get('exclude_id')

        # 2. 数据预处理
        try:
            shape_str = json.dumps(geometry_data) if isinstance(geometry_data, dict) else geometry_data
            shape = GEOSGeometry(shape_str)
            if shape.srid != 2385: shape.srid = 2385
        except Exception:
            return Response({"error": "Invalid Geometry"}, status=400)

        # 3. 调用 Service 业务逻辑
        is_valid, reason = service.validate_geometry(shape, map_id, exclude_id, area_type)

        return Response({"valid": is_valid, "reason": reason})


class MapBatchValidationView(APIView):
    """POST /api/maps/validate_batch/ (批量校验)"""
    service_class = MapDisplayService

    def post(self, request):
        service = self.service_class()

        map_id = request.data.get('map_id')
        updates = request.data.get('updates', [])

        if not map_id:
            return Response({"error": "map_id is required"}, status=status.HTTP_400_BAD_REQUEST)

        # --- 数据预处理：在 View 层统一解析几何并修正 SRID ---
        processed_updates = []
        for i, item in enumerate(updates):
            try:
                # 1. 提取原始数据
                raw_geo = item.get('geometry') or item.get('location')
                if not raw_geo: continue

                # 2. 转字符串
                shape_str = json.dumps(raw_geo) if isinstance(raw_geo, dict) else raw_geo

                # 3. 解析几何
                shape = GEOSGeometry(shape_str)

                # 4. 强制修正 SRID (与 MapValidationView 保持一致)
                if shape.srid != 2385:
                    shape.srid = 2385

                # 5. 将处理好的 GEOSGeometry 对象注入 item
                # 使用一个新的 key 'geos_obj' 传递给 Service
                item['geos_obj'] = shape
                processed_updates.append(item)

            except Exception as e:
                # 如果解析失败，直接返回 400，中断处理
                return Response(
                    {"error": f"Invalid geometry at index {i} (ID: {item.get('id')}): {str(e)}"},
                    status=status.HTTP_400_BAD_REQUEST
                )

        # 调用 Service，传入包含 GEOSGeometry 对象的列表
        is_valid, errors = service.validate_batch(map_id, processed_updates)

        return Response({
            "valid": is_valid,
            "errors": errors
        })


================================================================================
文件路径: python-backend\map\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\map\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\python_backend\settings.py
--------------------------------------------------------------------------------

"""
Django settings for python_backend project.

Based on by 'django-admin startproject' using Django 2.1.2.

For more information on this file, see
https://docs.djangoproject.com/en/2.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/2.1/ref/settings/
"""

import os
import posixpath

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/2.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = '7306ec88-3719-40e9-88d4-2d6fdee59734'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ['*']

# Application references
# https://docs.djangoproject.com/en/2.1/ref/settings/#std:setting-INSTALLED_APPS
INSTALLED_APPS = [
    # Add your apps here to enable them
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.gis',
    'rest_framework',
    'django_filters',
    # 支持跨域请求
    'corsheaders',
    'core.apps.CoreConfig',
    'map.apps.MapConfig',
    'client.apps.ClientConfig',
    'management.apps.ManagementConfig',
    'search.apps.SearchConfig',
    'guide.apps.GuideConfig',
    'editor.apps.EditorConfig'
]

# Middleware framework
# https://docs.djangoproject.com/en/2.1/topics/http/middleware/
MIDDLEWARE = [
    # CORS middleware should be placed as high as possible
    'corsheaders.middleware.CorsMiddleware',
    # 注意：确保 CommonMiddleware 仍然在 CorsMiddleware 之后
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'python_backend.urls'

# Template configuration
# https://docs.djangoproject.com/en/2.1/topics/templates/
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'python_backend.wsgi.application'

# Database
# https://docs.djangoproject.com/en/2.1/ref/settings/#databases
DATABASES = {
    'default': {
        'ENGINE': 'django.contrib.gis.db.backends.postgis',
        'NAME': os.environ.get('POSTGRES_DB'),
        'USER': os.environ.get('POSTGRES_USER'),
        'PASSWORD': os.environ.get('POSTGRES_PASSWORD'),
        'HOST': 'postgres-db',
        'PORT': '5432',
    }
}

# Password validation
# https://docs.djangoproject.com/en/2.1/ref/settings/#auth-password-validators
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Internationalization
# https://docs.djangoproject.com/en/2.1/topics/i18n/
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_L10N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/2.1/howto/static-files/
STATIC_URL = '/static/'
STATIC_ROOT = posixpath.join(*(BASE_DIR.split(os.path.sep) + ['static']))

REST_FRAMEWORK = {
    # 默认权限设置：这里设置为默认需要登录才能访问，方便后续开发
    'DEFAULT_PERMISSION_CLASSES': [
        # 'rest_framework.permissions.IsAuthenticated',
        # 如果是开发初期想全部公开，可以改为:
        'rest_framework.permissions.AllowAny',
    ],

    # 默认认证方式
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
    ],

    # 默认分页设置 (推荐配置，防止大数据量查死数据库)
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,

    # 统一日期格式 (可选)
    'DATETIME_FORMAT': '%Y-%m-%d %H:%M:%S',
}

# CORS 设置（开发环境方便测试，生产请按需限制）
CORS_ALLOWED_ORIGINS = [
  "http://localhost:8080"
]
CORS_ALLOW_CREDENTIALS = True
# 可根据需要自定义允许的头、方法
# CORS_ALLOW_HEADERS = list(default_headers) + [
#     'your-custom-header',
# ]



================================================================================
文件路径: python-backend\python_backend\urls.py
--------------------------------------------------------------------------------

"""
python_backend URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/2.1/topics/http/urls/

Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""

# Uncomment next two lines to enable admin:
from django.contrib import admin
from django.urls import path,include
from rest_framework.routers import DefaultRouter
from map.views import MapViewSet, MapValidationView, MapBatchValidationView

from guide.views import RoutePlanView

from management.views import AdminAuthView, AdminProfileView


router = DefaultRouter()
router.register(r'maps', MapViewSet, basename='map')
urlpatterns = [
    path('search/', include('search.urls')),
    path('api/editor/', include('editor.urls')),
    path('api/management/', include('management.urls')),
    # Uncomment the next line to enable the admin:
    #path('admin/', admin.site.urls)
    path('api/maps/validate/', MapValidationView.as_view(), name='map-validate'),
    path('api/maps/validate_batch/', MapBatchValidationView.as_view(), name='map-validate-batch'),
    path('api/guide/route/',RoutePlanView.as_view(), name='route-plan'),
    path('api/', include(router.urls)),
    path('api/management/auth/<str:action>/', AdminAuthView.as_view(), name='admin-auth'),
    path('api/management/profile/', AdminProfileView.as_view(), name='admin-profile'),
    path('admin/', admin.site.urls),
    path('api/search/', include('search.urls')),
    # 其他URL配置...
]



================================================================================
文件路径: python-backend\python_backend\wsgi.py
--------------------------------------------------------------------------------

"""
WSGI config for python_backend project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

For more information, visit
https://docs.djangoproject.com/en/2.1/howto/deployment/wsgi/
"""

import os

import django
from django.core.wsgi import get_wsgi_application

os.environ.setdefault(
    'DJANGO_SETTINGS_MODULE',
    'python_backend.settings')
django.setup()

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
application = get_wsgi_application()



================================================================================
文件路径: python-backend\python_backend\__init__.py
--------------------------------------------------------------------------------

"""
Package for python_backend.
"""



================================================================================
文件路径: python-backend\search\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\search\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class SearchConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'search'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\search\context.py
--------------------------------------------------------------------------------

from django.apps import apps
from django.db.models import Q


class BaseSearchContext:
    """基础搜索上下文类"""

    def __init__(self, model_name):
        self.model_name = model_name
        self.model = apps.get_model('core', model_name)


class StoreareaContext(BaseSearchContext):
    """店铺区域上下文"""

    def __init__(self):
        super().__init__('Storearea')

    def get_by_id(self, storearea_id):
        """根据ID获取店铺区域"""
        try:
            return self.model.objects.get(id=storearea_id)
        except self.model.DoesNotExist:
            return None

    def search_by_name(self, name):
        """根据名称搜索店铺区域"""
        return self.model.objects.filter(
            store_name__icontains=name,
            is_active=True
        )

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选店铺区域"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_storearea_map_relations(self, storearea_id):
        """获取店铺区域的地图关联"""
        StoreareaMap = apps.get_model('core', 'StoreareaMap')
        return StoreareaMap.objects.filter(storearea_id=storearea_id)


class EventContext(BaseSearchContext):
    """活动上下文"""

    def __init__(self):
        super().__init__('Event')

    def get_by_id(self, event_id):
        """根据ID获取活动"""
        try:
            return self.model.objects.get(id=event_id)
        except self.model.DoesNotExist:
            return None

    def search_by_name(self, name):
        """根据名称搜索活动"""
        return self.model.objects.filter(
            event_name__icontains=name,
            is_active=True
        )

    def filter_active_events(self):
        """获取所有活跃活动"""
        return self.model.objects.filter(is_active=True)

    def get_event_storearea_relations(self, event_id):
        """获取活动的店铺区域关联"""
        EventStorearea = apps.get_model('core', 'EventStorearea')
        return EventStorearea.objects.filter(event_id=event_id)

    def get_event_eventarea_relations(self, event_id):
        """获取活动的活动区域关联"""
        EventEventarea = apps.get_model('core', 'EventEventarea')
        return EventEventarea.objects.filter(event_id=event_id)


class EventareaContext(BaseSearchContext):
    """活动区域上下文"""

    def __init__(self):
        super().__init__('Eventarea')

    def get_by_id(self, eventarea_id):
        """根据ID获取活动区域"""
        try:
            return self.model.objects.get(id=eventarea_id)
        except self.model.DoesNotExist:
            return None

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选活动区域"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_eventarea_map_relations(self, eventarea_id):
        """获取活动区域的地图关联"""
        EventareaMap = apps.get_model('core', 'EventareaMap')
        return EventareaMap.objects.filter(eventarea_id=eventarea_id)

    def get_eventarea_map_relations_by_map(self, map_id):
        """根据地图ID获取活动区域关联"""
        EventareaMap = apps.get_model('core', 'EventareaMap')
        return EventareaMap.objects.filter(map_id=map_id)


class FacilityContext(BaseSearchContext):
    """设施上下文"""

    def __init__(self):
        super().__init__('Facility')

    def get_by_id(self, facility_id):
        """根据ID获取设施"""
        try:
            return self.model.objects.get(id=facility_id)
        except self.model.DoesNotExist:
            return None

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选设施"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_facility_map_relations(self, facility_id):
        """获取设施的地图关联"""
        FacilityMap = apps.get_model('core', 'FacilityMap')
        return FacilityMap.objects.filter(facility_id=facility_id)

    def get_facility_map_relations_by_map(self, map_id):
        """根据地图ID获取设施关联"""
        FacilityMap = apps.get_model('core', 'FacilityMap')
        return FacilityMap.objects.filter(map_id=map_id)


class OtherareaContext(BaseSearchContext):
    """其他区域上下文"""

    def __init__(self):
        super().__init__('Otherarea')

    def get_by_id(self, otherarea_id):
        """根据ID获取其他区域"""
        try:
            return self.model.objects.get(id=otherarea_id)
        except self.model.DoesNotExist:
            return None

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选其他区域"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_otherarea_map_relations(self, otherarea_id):
        """获取其他区域的地图关联"""
        OtherareaMap = apps.get_model('core', 'OtherareaMap')
        return OtherareaMap.objects.filter(otherarea_id=otherarea_id)

    def get_otherarea_map_relations_by_map(self, map_id):
        """根据地图ID获取其他区域关联"""
        OtherareaMap = apps.get_model('core', 'OtherareaMap')
        return OtherareaMap.objects.filter(map_id=map_id)


class SearchElementContext:
    """搜索元素上下文，用于处理关联关系"""

    @staticmethod
    def get_storearea_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取店铺区域ID"""
        StoreareaMap = apps.get_model('core', 'StoreareaMap')
        Storearea = apps.get_model('core', 'Storearea')

        # 获取该地图的所有storearea关联
        storearea_maps = StoreareaMap.objects.filter(map_id=map_id)
        storearea_ids = [sm.storearea_id for sm in storearea_maps]

        # 如果提供了类型参数，则进一步过滤
        if type_id is not None:
            storeareas = Storearea.objects.filter(
                id__in=storearea_ids,
                type=type_id,
                is_active=True
            )
            storearea_ids = [storearea.id for storearea in storeareas]

        return storearea_ids

    @staticmethod
    def get_eventarea_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取活动区域ID"""
        EventareaMap = apps.get_model('core', 'EventareaMap')
        Eventarea = apps.get_model('core', 'Eventarea')

        eventarea_maps = EventareaMap.objects.filter(map_id=map_id)
        eventarea_ids = [em.eventarea_id for em in eventarea_maps]

        if type_id is not None:
            eventareas = Eventarea.objects.filter(
                id__in=eventarea_ids,
                type=type_id,
                is_active=True
            )
            eventarea_ids = [eventarea.id for eventarea in eventareas]

        return eventarea_ids

    @staticmethod
    def get_facility_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取设施ID"""
        FacilityMap = apps.get_model('core', 'FacilityMap')
        Facility = apps.get_model('core', 'Facility')

        facility_maps = FacilityMap.objects.filter(map_id=map_id)
        facility_ids = [fm.facility_id for fm in facility_maps]

        if type_id is not None:
            facilities = Facility.objects.filter(
                id__in=facility_ids,
                type=type_id,
                is_active=True
            )
            facility_ids = [facility.id for facility in facilities]

        return facility_ids

    @staticmethod
    def get_otherarea_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取其他区域ID"""
        OtherareaMap = apps.get_model('core', 'OtherareaMap')
        Otherarea = apps.get_model('core', 'Otherarea')

        otherarea_maps = OtherareaMap.objects.filter(map_id=map_id)
        otherarea_ids = [om.otherarea_id for om in otherarea_maps]

        if type_id is not None:
            otherareas = Otherarea.objects.filter(
                id__in=otherarea_ids,
                type=type_id,
                is_active=True
            )
            otherarea_ids = [otherarea.id for otherarea in otherareas]

        return otherarea_ids


================================================================================
文件路径: python-backend\search\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from django.apps import apps


# 使用延迟加载的方式定义序列化器
def get_storearea_serializer():
    Storearea = apps.get_model('core', 'Storearea')

    class StoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            fields = '__all__'

    return StoreareaSerializer


def get_event_serializer():
    Event = apps.get_model('core', 'Event')

    class EventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = '__all__'

    return EventSerializer


def get_eventarea_serializer():
    Eventarea = apps.get_model('core', 'Eventarea')

    class EventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            fields = '__all__'

    return EventareaSerializer


def get_facility_serializer():
    Facility = apps.get_model('core', 'Facility')

    class FacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            fields = '__all__'

    return FacilitySerializer


def get_otherarea_serializer():
    Otherarea = apps.get_model('core', 'Otherarea')

    class OtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            fields = '__all__'

    return OtherareaSerializer


def get_simple_storearea_serializer():
    Storearea = apps.get_model('core', 'Storearea')

    class SimpleStoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            fields = ['id', 'store_name', 'type']

    return SimpleStoreareaSerializer


def get_simple_event_serializer():
    Event = apps.get_model('core', 'Event')

    class SimpleEventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = ['id', 'event_name', 'start_date', 'end_date']

    return SimpleEventSerializer


def get_simple_eventarea_serializer():
    Eventarea = apps.get_model('core', 'Eventarea')

    class SimpleEventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            fields = ['id', 'organizer_name', 'type']

    return SimpleEventareaSerializer


def get_simple_facility_serializer():
    Facility = apps.get_model('core', 'Facility')

    class SimpleFacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            fields = ['id', 'type']

    return SimpleFacilitySerializer


def get_simple_otherarea_serializer():
    Otherarea = apps.get_model('core', 'Otherarea')

    class SimpleOtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            fields = ['id', 'type', 'is_public']

    return SimpleOtherareaSerializer



================================================================================
文件路径: python-backend\search\services.py
--------------------------------------------------------------------------------

from rest_framework import status
from django.apps import apps
from .context import (
    StoreareaContext, EventContext, EventareaContext,
    FacilityContext, OtherareaContext, SearchElementContext
)


class SearchService:
    """搜索服务"""

    def __init__(self):
        self.storearea_ctx = StoreareaContext()
        self.event_ctx = EventContext()
        self.eventarea_ctx = EventareaContext()
        self.facility_ctx = FacilityContext()
        self.otherarea_ctx = OtherareaContext()
        self.element_ctx = SearchElementContext()

    # ========== 店铺搜索功能 ==========

    def get_storearea_by_id(self, storearea_id):
        """获取ID为<>的商铺区域的所有信息"""
        storearea = self.storearea_ctx.get_by_id(storearea_id)
        if not storearea:
            return None, {'error': 'Storearea not found'}, status.HTTP_404_NOT_FOUND
        return storearea, None, None

    def search_storearea_by_name(self, name):
        """按名称寻找店铺区域"""
        if not name:
            return None, {'error': 'Name parameter is required'}, status.HTTP_400_BAD_REQUEST
        storeareas = self.storearea_ctx.search_by_name(name)
        return storeareas, None, None

    def list_storearea_by_type(self, type_param):
        """返回指定类型店铺区域列表"""
        if type_param:
            try:
                type_id = int(type_param)
                storeareas = self.storearea_ctx.filter_by_type(type_id=type_id)
                return storeareas, {'type': type_id}, None
            except ValueError:
                return None, {'error': 'Invalid type parameter'}, status.HTTP_400_BAD_REQUEST
        else:
            storeareas = self.storearea_ctx.filter_by_type()
            return storeareas, None, None

    def get_storearea_events(self, storearea_id):
        """返回指定店铺区域的所有活动ID列表"""
        storearea = self.storearea_ctx.get_by_id(storearea_id)
        if not storearea or not storearea.is_active:
            return None, {'error': 'Storearea not found'}, status.HTTP_404_NOT_FOUND

        EventStorearea = apps.get_model('core', 'EventStorearea')
        event_relations = EventStorearea.objects.filter(storearea_id=storearea_id)
        event_ids = [relation.event_id for relation in event_relations]

        return {'storearea_id': storearea_id, 'event_ids': event_ids}, None, None

    def get_storearea_map_ids(self, storearea_id):
        """获取storearea_id为<>的活动区域所属的map_id"""
        storearea_maps = self.storearea_ctx.get_storearea_map_relations(storearea_id)
        map_ids = [storearea_map.map_id for storearea_map in storearea_maps]
        return {'storearea_id': storearea_id, 'map_ids': map_ids}, None, None

    def get_storearea_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且type为<>的所有storearea的id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            storearea_ids = self.element_ctx.get_storearea_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'storearea_ids': storearea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_all_storearea_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有storearea_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            storearea_ids = self.element_ctx.get_storearea_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'storearea_ids': storearea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST

    # ========== 活动搜索功能 ==========

    def get_event_by_id(self, event_id):
        """按ID寻找活动"""
        event = self.event_ctx.get_by_id(event_id)
        if not event:
            return None, {'error': 'Event not found'}, status.HTTP_404_NOT_FOUND
        return event, None, None

    def search_event_by_name(self, name):
        """按名称寻找活动"""
        if not name:
            return None, {'error': 'Name parameter is required'}, status.HTTP_400_BAD_REQUEST
        events = self.event_ctx.search_by_name(name)
        return events, None, None

    def list_event_by_type(self, type_param):
        """返回指定类型活动列表"""
        events = self.event_ctx.filter_active_events()

        if type_param:
            try:
                type_id = int(type_param)
                EventEventarea = apps.get_model('core', 'EventEventarea')
                event_ids = EventEventarea.objects.filter(
                    eventarea__type=type_id
                ).values_list('event_id', flat=True).distinct()

                events = events.filter(id__in=event_ids)
                return events, {'type': type_id}, None
            except ValueError:
                return None, {'error': 'Invalid type parameter'}, status.HTTP_400_BAD_REQUEST
        else:
            return events, None, None

    def get_event_areas(self, event_id):
        """返回参加该活动的区域ID列表"""
        event = self.event_ctx.get_by_id(event_id)
        if not event:
            return None, {'error': 'Event not found'}, status.HTTP_404_NOT_FOUND

        storearea_relations = self.event_ctx.get_event_storearea_relations(event_id)
        storearea_ids = [relation.storearea_id for relation in storearea_relations]

        eventarea_relations = self.event_ctx.get_event_eventarea_relations(event_id)
        eventarea_ids = [relation.eventarea_id for relation in eventarea_relations]

        result = {
            'event_id': event_id,
            'storearea_ids': storearea_ids,
            'eventarea_ids': eventarea_ids,
            'all_area_ids': storearea_ids + eventarea_ids
        }
        return result, None, None

    # ========== 活动区域功能 ==========

    def get_eventarea_by_id(self, eventarea_id):
        """获取id为<>的活动区域的所有信息"""
        eventarea = self.eventarea_ctx.get_by_id(eventarea_id)
        if not eventarea:
            return None, {'error': 'Eventarea not found'}, status.HTTP_404_NOT_FOUND
        return eventarea, None, None

    def get_eventarea_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且 type为<>的所有eventarea的id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            eventarea_ids = self.element_ctx.get_eventarea_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'eventarea_ids': eventarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_eventarea_map_ids(self, eventarea_id):
        """获取eventarea_id为<>的活动区域所属的map_id"""
        eventarea_maps = self.eventarea_ctx.get_eventarea_map_relations(eventarea_id)
        map_ids = [eventarea_map.map_id for eventarea_map in eventarea_maps]
        return {'eventarea_id': eventarea_id, 'map_ids': map_ids}, None, None

    def get_all_eventarea_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有eventarea_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            eventarea_ids = self.element_ctx.get_eventarea_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'eventarea_ids': eventarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST

    # ========== 设施功能 ==========

    def get_facility_by_id(self, facility_id):
        """获取id为<>的设施的所有信息"""
        facility = self.facility_ctx.get_by_id(facility_id)
        if not facility:
            return None, {'error': 'Facility not found'}, status.HTTP_404_NOT_FOUND
        return facility, None, None

    def get_facility_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且type为<>的所有设施id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            facility_ids = self.element_ctx.get_facility_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'facility_ids': facility_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_facility_map_ids(self, facility_id):
        """获取facility_id为<>的活动区域所属的map_id"""
        facility_maps = self.facility_ctx.get_facility_map_relations(facility_id)
        map_ids = [facility_map.map_id for facility_map in facility_maps]
        return {'facility_id': facility_id, 'map_ids': map_ids}, None, None

    def get_all_facility_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有facility_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            facility_ids = self.element_ctx.get_facility_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'facility_ids': facility_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST

    # ========== 其他区域功能 ==========

    def get_otherarea_by_id(self, otherarea_id):
        """获取id为<>的其他区域的所有信息"""
        otherarea = self.otherarea_ctx.get_by_id(otherarea_id)
        if not otherarea:
            return None, {'error': 'Otherarea not found'}, status.HTTP_404_NOT_FOUND
        return otherarea, None, None

    def get_otherarea_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且type为<>的所有otherarea的id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            otherarea_ids = self.element_ctx.get_otherarea_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'otherarea_ids': otherarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_otherarea_map_ids(self, otherarea_id):
        """获取otherarea_id为<>的活动区域所属的map_id"""
        otherarea_maps = self.otherarea_ctx.get_otherarea_map_relations(otherarea_id)
        map_ids = [otherarea_map.map_id for otherarea_map in otherarea_maps]
        return {'otherarea_id': otherarea_id, 'map_ids': map_ids}, None, None

    def get_all_otherarea_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有otherarea_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            otherarea_ids = self.element_ctx.get_otherarea_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'otherarea_ids': otherarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST


================================================================================
文件路径: python-backend\search\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\search\urls.py
--------------------------------------------------------------------------------

from django.urls import path
from . import views

urlpatterns = [
    # Search店铺功能
    path('storearea/<int:storearea_id>/', views.storearea_by_id, name='storearea-by-id'),
    path('storearea/search/', views.storearea_search, name='storearea-search'),
    path('storearea/list/', views.storearea_list_by_type, name='storearea-list-by-type'),
    path('storearea/<int:storearea_id>/events/', views.storearea_events, name='storearea-events'),

    # 新增的店铺区域功能
    path('storearea/<int:storearea_id>/map/', views.storearea_map_ids, name='storearea-map-ids'),
    path('storearea/list/map/', views.storearea_ids_by_map_and_type, name='storearea-ids-by-map-type'),
    path('storearea/list/all_by_map/', views.all_storearea_ids_by_map, name='all-storearea-ids-by-map'),

    # Search活动功能
    path('event/<int:event_id>/', views.event_by_id, name='event-by-id'),
    path('event/search/', views.event_search, name='event-search'),
    path('event/list/', views.event_list_by_type, name='event-list-by-type'),
    path('event/<int:event_id>/areas/', views.event_areas, name='event-areas'),

    # 新增的活动区域功能
    path('eventarea/<int:eventarea_id>/', views.eventarea_by_id, name='eventarea-by-id'),
    path('eventarea/list/ids_by_map_type/', views.eventarea_ids_by_map_and_type, name='eventarea-ids-by-map-type'),
    path('eventarea/<int:eventarea_id>/map/', views.eventarea_map_ids, name='eventarea-map-ids'),
    path('eventarea/list/all_by_map/', views.all_eventarea_ids_by_map, name='all-eventarea-ids-by-map'),

    # 新增的设施功能
    path('facility/<int:facility_id>/', views.facility_by_id, name='facility-by-id'),
    path('facility/list/ids_by_map_type/', views.facility_ids_by_map_and_type, name='facility-ids-by-map-type'),
    path('facility/<int:facility_id>/map/', views.facility_map_ids, name='facility-map-ids'),
    path('facility/list/all_by_map/', views.all_facility_ids_by_map, name='all-facility-ids-by-map'),

    # 新增的其他区域功能
    path('otherarea/<int:otherarea_id>/', views.otherarea_by_id, name='otherarea-by-id'),
    path('otherarea/list/ids_by_map_type/', views.otherarea_ids_by_map_and_type, name='otherarea-ids-by-map-type'),
    path('otherarea/<int:otherarea_id>/map/', views.otherarea_map_ids, name='otherarea-map-ids'),
    path('otherarea/list/all_by_map/', views.all_otherarea_ids_by_map, name='all-otherarea-ids-by-map'),
]


================================================================================
文件路径: python-backend\search\views.py
--------------------------------------------------------------------------------

from rest_framework.decorators import api_view
from rest_framework.response import Response
from .services import SearchService
from .serializers import (
    get_storearea_serializer, get_simple_storearea_serializer,
    get_event_serializer, get_simple_event_serializer,
    get_eventarea_serializer, get_simple_eventarea_serializer,
    get_facility_serializer, get_simple_facility_serializer,
    get_otherarea_serializer, get_simple_otherarea_serializer
)

search_service = SearchService()


# ========== 店铺搜索功能 ==========

@api_view(['GET'])
def storearea_by_id(request, storearea_id):
    """获取id为<>的商铺区域的所有信息"""
    result, error, status_code = search_service.get_storearea_by_id(storearea_id)
    if error:
        return Response(error, status=status_code)

    StoreareaSerializer = get_storearea_serializer()
    serializer = StoreareaSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def storearea_search(request):
    """按名称寻找店铺区域"""
    name = request.GET.get('name', '').strip()
    result, error, status_code = search_service.search_storearea_by_name(name)
    if error:
        return Response(error, status=status_code)

    StoreareaSerializer = get_storearea_serializer()
    serializer = StoreareaSerializer(result, many=True)
    return Response(serializer.data)


@api_view(['GET'])
def storearea_list_by_type(request):
    """返回指定类型店铺区域列表"""
    type_param = request.GET.get('type', '').strip()
    result, extra, error = search_service.list_storearea_by_type(type_param)
    if error:
        return Response(error, status=extra)

    if type_param:
        StoreareaSerializer = get_storearea_serializer()
        serializer = StoreareaSerializer(result, many=True)
        response_data = {'type': extra['type'], 'storeareas': serializer.data}
    else:
        categorized = {}
        SimpleStoreareaSerializer = get_simple_storearea_serializer()
        for storearea in result:
            type_key = storearea.type or 0
            if type_key not in categorized:
                categorized[type_key] = []
            serializer = SimpleStoreareaSerializer(storearea)
            categorized[type_key].append(serializer.data)
        response_data = categorized

    return Response(response_data)


@api_view(['GET'])
def storearea_events(request, storearea_id):
    """返回指定店铺区域的所有活动ID列表"""
    result, error, status_code = search_service.get_storearea_events(storearea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def storearea_map_ids(request, storearea_id):
    """获取storearea_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_storearea_map_ids(storearea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def storearea_ids_by_map_and_type(request):
    """获取map_id为<> 且type为<>的所有storearea的id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_storearea_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_storearea_ids_by_map(request):
    """获取map_id为<>的地图对应的所有storearea_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_storearea_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 活动搜索功能 ==========

@api_view(['GET'])
def event_by_id(request, event_id):
    """按ID寻找活动"""
    result, error, status_code = search_service.get_event_by_id(event_id)
    if error:
        return Response(error, status=status_code)

    EventSerializer = get_event_serializer()
    serializer = EventSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def event_search(request):
    """按名称寻找活动"""
    name = request.GET.get('name', '').strip()
    result, error, status_code = search_service.search_event_by_name(name)
    if error:
        return Response(error, status=status_code)

    EventSerializer = get_event_serializer()
    serializer = EventSerializer(result, many=True)
    return Response(serializer.data)


@api_view(['GET'])
def event_list_by_type(request):
    """返回指定类型活动列表"""
    type_param = request.GET.get('type', '').strip()
    result, extra, error = search_service.list_event_by_type(type_param)
    if error:
        return Response(error, status=extra)

    if type_param:
        EventSerializer = get_event_serializer()
        serializer = EventSerializer(result, many=True)
        response_data = {'type': extra['type'], 'events': serializer.data}
    else:
        categorized = {}
        SimpleEventSerializer = get_simple_event_serializer()

        for event in result:
            # 获取该活动关联的所有Eventarea类型
            from django.apps import apps
            EventEventarea = apps.get_model('core', 'EventEventarea')
            eventarea_types = EventEventarea.objects.filter(
                event_id=event.id
            ).values_list('eventarea__type', flat=True).distinct()

            if not eventarea_types:
                type_key = 0
                if type_key not in categorized:
                    categorized[type_key] = []
                serializer = SimpleEventSerializer(event)
                categorized[type_key].append(serializer.data)
            else:
                for eventarea_type in eventarea_types:
                    type_key = eventarea_type or 0
                    if type_key not in categorized:
                        categorized[type_key] = []

                    serializer = SimpleEventSerializer(event)
                    categorized[type_key].append(serializer.data)

        response_data = categorized

    return Response(response_data)


@api_view(['GET'])
def event_areas(request, event_id):
    """返回参加该活动的区域ID列表"""
    result, error, status_code = search_service.get_event_areas(event_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 活动区域功能 ==========

@api_view(['GET'])
def eventarea_by_id(request, eventarea_id):
    """获取id为<>的活动区域的所有信息"""
    result, error, status_code = search_service.get_eventarea_by_id(eventarea_id)
    if error:
        return Response(error, status=status_code)

    EventareaSerializer = get_eventarea_serializer()
    serializer = EventareaSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def eventarea_ids_by_map_and_type(request):
    """获取map_id为<> 且 type为<>的所有eventarea的id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_eventarea_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def eventarea_map_ids(request, eventarea_id):
    """获取eventarea_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_eventarea_map_ids(eventarea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_eventarea_ids_by_map(request):
    """获取map_id为<>的地图对应的所有eventarea_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_eventarea_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 设施功能 ==========

@api_view(['GET'])
def facility_by_id(request, facility_id):
    """获取id为<>的设施的所有信息"""
    result, error, status_code = search_service.get_facility_by_id(facility_id)
    if error:
        return Response(error, status=status_code)

    FacilitySerializer = get_facility_serializer()
    serializer = FacilitySerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def facility_ids_by_map_and_type(request):
    """获取map_id为<> 且type为<>的所有设施id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_facility_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def facility_map_ids(request, facility_id):
    """获取facility_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_facility_map_ids(facility_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_facility_ids_by_map(request):
    """获取map_id为<>的地图对应的所有facility_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_facility_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 其他区域功能 ==========

@api_view(['GET'])
def otherarea_by_id(request, otherarea_id):
    """获取id为<>的其他区域的所有信息"""
    result, error, status_code = search_service.get_otherarea_by_id(otherarea_id)
    if error:
        return Response(error, status=status_code)

    OtherareaSerializer = get_otherarea_serializer()
    serializer = OtherareaSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def otherarea_ids_by_map_and_type(request):
    """获取map_id为<> 且type为<>的所有otherarea的id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_otherarea_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def otherarea_map_ids(request, otherarea_id):
    """获取otherarea_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_otherarea_map_ids(otherarea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_otherarea_ids_by_map(request):
    """获取map_id为<>的地图对应的所有otherarea_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_otherarea_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)



================================================================================
文件路径: python-backend\search\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\search\migrations\__init__.py
--------------------------------------------------------------------------------






================================================================================
文件路径: python-backend\manage.py
--------------------------------------------------------------------------------

#!/usr/bin/env python
"""
Command-line utility for administrative tasks.

# For more information about this file, visit
# https://docs.djangoproject.com/en/2.1/ref/django-admin/
"""

import os
import sys

import django

if __name__ == '__main__':
    os.environ.setdefault(
        'DJANGO_SETTINGS_MODULE',
        'python_backend.settings')
    django.setup()

    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)



================================================================================
文件路径: python-backend\requirements.txt
--------------------------------------------------------------------------------

Django==5.2.8
asgiref==3.10.0
pip==25.0.1
psycopg2-binary==2.9.11
sqlparse==0.5.3
tzdata==2025.2
virtualenv==12.1.1
djangorestframework==3.15.2
markdown==3.7
django-filter==24.3
django-cors-headers==4.0.0
ezdxf==1.1.0


================================================================================
文件路径: python-backend\client\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\client\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class ClientConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'client'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\client\models.py
--------------------------------------------------------------------------------

from django.db import models

# Create your models here.



================================================================================
文件路径: python-backend\client\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\client\views.py
--------------------------------------------------------------------------------

from django.shortcuts import render

# Create your views here.
from rest_framework import viewsets, status

from rest_framework.decorators import action

from rest_framework.response import Response


================================================================================
文件路径: python-backend\client\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\client\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\core\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\core\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig

class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core'


================================================================================
文件路径: python-backend\core\context.py
--------------------------------------------------------------------------------

from core.models import *
from django.db.models import Q

class BaseContext:
    """基础 CRUD Context"""
    def __init__(self, model):
        self.model = model

    def get_by_id(self, pk):
        try:
            return self.model.objects.get(pk=pk)
        except self.model.DoesNotExist:
            return None

    def list_all(self):
        return self.model.objects.all()

    def create(self, **kwargs):
        return self.model.objects.create(**kwargs)

    def update(self, instance, **kwargs):
        for key, value in kwargs.items():
            setattr(instance, key, value)
        instance.save()
        return instance

    def delete(self, instance):
        instance.delete()


================================================================================
文件路径: python-backend\core\models.py
--------------------------------------------------------------------------------

from django.contrib.gis.db import models

# Create your models here.
class Admin(models.Model):
    account = models.CharField(unique=True, max_length=64)
    password = models.CharField(max_length=256)
    name = models.CharField(max_length=64, blank=True, null=True)

    class Meta:
        db_table = 'admin'
        # managed = False


class Building(models.Model):
    name = models.CharField(unique=True, max_length=64)
    address = models.CharField(max_length=256)
    description = models.CharField(max_length=256, blank=True, null=True)

    class Meta:
        db_table = 'building'
        # managed = False


class Event(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    description = models.CharField(max_length=256, blank=True, null=True)
    event_name = models.CharField(max_length=64)
    start_date = models.DateTimeField()
    end_date = models.DateTimeField()
    image_url = models.CharField(max_length=256, blank=True, null=True)

    class Meta:
        db_table = 'event'
        # managed = False


class EventEventarea(models.Model):
    pk = models.CompositePrimaryKey('event_id', 'eventarea_id')
    event = models.ForeignKey(Event, on_delete=models.CASCADE)
    eventarea = models.ForeignKey('Eventarea', on_delete=models.CASCADE)

    class Meta:
        db_table = 'event_eventarea'
        # managed = False
        # unique_together = (('event', 'eventarea'),)


class EventStorearea(models.Model):
    pk = models.CompositePrimaryKey('event_id', 'storearea_id')
    event = models.ForeignKey(Event, on_delete=models.CASCADE)
    storearea = models.ForeignKey('Storearea', on_delete=models.CASCADE)

    class Meta:
        db_table = 'event_storearea'
        # unique_together = (('event', 'storearea'),)
        # managed = False


class Eventarea(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    shape = models.PolygonField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    organizer_name = models.CharField(max_length=64)
    organizer_phone = models.CharField(max_length=16)
    type = models.IntegerField(blank=True, null=True)

    class Meta:
        db_table = 'eventarea'
        # managed = False


class EventareaMap(models.Model):
    pk = models.CompositePrimaryKey('eventarea_id', 'map_id')
    eventarea = models.ForeignKey(Eventarea, on_delete=models.CASCADE)
    map = models.ForeignKey('Map', on_delete=models.CASCADE)

    class Meta:
        db_table = 'eventarea_map'
        # unique_together = (('eventarea', 'map'),)
        # managed = False


class Facility(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    location = models.PointField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    type = models.IntegerField()

    class Meta:
        db_table = 'facility'
        # managed = False


class FacilityMap(models.Model):
    pk = models.CompositePrimaryKey('facility_id', 'map_id')
    facility = models.ForeignKey(Facility, on_delete=models.CASCADE)
    map = models.ForeignKey('Map', on_delete=models.CASCADE)

    class Meta:
        db_table = 'facility_map'
        # unique_together = (('facility', 'map'),)
        # managed = False


class Map(models.Model):
    building = models.ForeignKey(Building, models.CASCADE)
    floor_number = models.IntegerField()
    detail = models.GeometryCollectionField(srid=2385)

    class Meta:
        db_table = 'map'
        unique_together = (('building', 'floor_number'),)
        # managed = False


class Otherarea(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    shape = models.PolygonField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    type = models.IntegerField()
    is_public = models.BooleanField(blank=True, null=True)

    class Meta:
        db_table = 'otherarea'
        # managed = False


class OtherareaMap(models.Model):
    pk = models.CompositePrimaryKey('otherarea_id', 'map_id')
    otherarea = models.ForeignKey(Otherarea, on_delete=models.CASCADE)
    map = models.ForeignKey(Map, on_delete=models.CASCADE)

    class Meta:
        db_table = 'otherarea_map'
        # managed = False
        # unique_together = (('otherarea', 'map'),)


class Storearea(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    shape = models.PolygonField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    store_name = models.CharField(max_length=64)
    owner_name = models.CharField(max_length=64)
    owner_phone = models.CharField(max_length=16)
    logo_url = models.CharField(max_length=256, blank=True, null=True)
    open_time = models.TimeField(blank=True, null=True)
    close_time = models.TimeField(blank=True, null=True)
    type = models.IntegerField(blank=True, null=True)
    api_url = models.CharField(max_length=256, blank=True, null=True)

    class Meta:
        db_table = 'storearea'
        # managed = False


class StoreareaMap(models.Model):
    pk = models.CompositePrimaryKey('storearea_id', 'map_id')
    storearea = models.ForeignKey(Storearea, on_delete=models.CASCADE)
    map = models.ForeignKey(Map, on_delete=models.CASCADE)

    class Meta:
        db_table = 'storearea_map'
        # unique_together = (('storearea', 'map'),)
        # managed = False


================================================================================
文件路径: python-backend\core\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\core\views.py
--------------------------------------------------------------------------------

from django.shortcuts import render

# Create your views here.



================================================================================
文件路径: python-backend\core\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\core\migrations\0001_initial.py
--------------------------------------------------------------------------------

# Generated by Django 5.2.8 on 2025-12-10 02:55

import django.contrib.gis.db.models.fields
import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Admin',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('account', models.CharField(max_length=64, unique=True)),
                ('password', models.CharField(max_length=256)),
                ('name', models.CharField(blank=True, max_length=64, null=True)),
            ],
            options={
                'db_table': 'admin',
            },
        ),
        migrations.CreateModel(
            name='Building',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=64, unique=True)),
                ('address', models.CharField(max_length=256)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
            ],
            options={
                'db_table': 'building',
            },
        ),
        migrations.CreateModel(
            name='Event',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('event_name', models.CharField(max_length=64)),
                ('start_date', models.DateTimeField()),
                ('end_date', models.DateTimeField()),
                ('image_url', models.CharField(blank=True, max_length=256, null=True)),
            ],
            options={
                'db_table': 'event',
            },
        ),
        migrations.CreateModel(
            name='Eventarea',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('shape', django.contrib.gis.db.models.fields.PolygonField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('organizer_name', models.CharField(max_length=64)),
                ('organizer_phone', models.CharField(max_length=16)),
                ('type', models.IntegerField(blank=True, null=True)),
            ],
            options={
                'db_table': 'eventarea',
            },
        ),
        migrations.CreateModel(
            name='Facility',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('location', django.contrib.gis.db.models.fields.PointField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('type', models.IntegerField()),
            ],
            options={
                'db_table': 'facility',
            },
        ),
        migrations.CreateModel(
            name='Otherarea',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('shape', django.contrib.gis.db.models.fields.PolygonField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('type', models.IntegerField()),
                ('is_public', models.BooleanField(blank=True, null=True)),
            ],
            options={
                'db_table': 'otherarea',
            },
        ),
        migrations.CreateModel(
            name='Storearea',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('shape', django.contrib.gis.db.models.fields.PolygonField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('store_name', models.CharField(max_length=64)),
                ('owner_name', models.CharField(max_length=64)),
                ('owner_phone', models.CharField(max_length=16)),
                ('logo_url', models.CharField(blank=True, max_length=256, null=True)),
                ('open_time', models.TimeField(blank=True, null=True)),
                ('close_time', models.TimeField(blank=True, null=True)),
                ('type', models.IntegerField(blank=True, null=True)),
                ('api_url', models.CharField(blank=True, max_length=256, null=True)),
            ],
            options={
                'db_table': 'storearea',
            },
        ),
        migrations.CreateModel(
            name='EventEventarea',
            fields=[
                ('pk', models.CompositePrimaryKey('event_id', 'eventarea_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('event', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.event')),
                ('eventarea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.eventarea')),
            ],
            options={
                'db_table': 'event_eventarea',
            },
        ),
        migrations.CreateModel(
            name='Map',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('floor_number', models.IntegerField()),
                ('detail', django.contrib.gis.db.models.fields.GeometryCollectionField(srid=2385)),
                ('building', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.building')),
            ],
            options={
                'db_table': 'map',
                'unique_together': {('building', 'floor_number')},
            },
        ),
        migrations.CreateModel(
            name='FacilityMap',
            fields=[
                ('pk', models.CompositePrimaryKey('facility_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('facility', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.facility')),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
            ],
            options={
                'db_table': 'facility_map',
            },
        ),
        migrations.CreateModel(
            name='EventareaMap',
            fields=[
                ('pk', models.CompositePrimaryKey('eventarea_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('eventarea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.eventarea')),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
            ],
            options={
                'db_table': 'eventarea_map',
            },
        ),
        migrations.CreateModel(
            name='OtherareaMap',
            fields=[
                ('pk', models.CompositePrimaryKey('otherarea_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
                ('otherarea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.otherarea')),
            ],
            options={
                'db_table': 'otherarea_map',
            },
        ),
        migrations.CreateModel(
            name='EventStorearea',
            fields=[
                ('pk', models.CompositePrimaryKey('event_id', 'storearea_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('event', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.event')),
                ('storearea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.storearea')),
            ],
            options={
                'db_table': 'event_storearea',
            },
        ),
        migrations.CreateModel(
            name='StoreareaMap',
            fields=[
                ('pk', models.CompositePrimaryKey('storearea_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
                ('storearea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.storearea')),
            ],
            options={
                'db_table': 'storearea_map',
            },
        ),
    ]



================================================================================
文件路径: python-backend\core\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\editor\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\editor\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class EditorConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'editor'



================================================================================
文件路径: python-backend\editor\context.py
--------------------------------------------------------------------------------

from django.contrib.gis.geos import GEOSGeometry
from core.models import (
    Event,
    Storearea,
    StoreareaMap,
    EventStorearea,
    EventEventarea,
    Eventarea,
    EventareaMap,
    Otherarea,
    OtherareaMap,
    Facility,
    FacilityMap
)


class StoreareaContext:
    """
    店铺区域（Storearea）的数据访问层
    负责与数据库交互，仅提供shape属性相关的操作
    """

    @staticmethod
    def get_all():
        """获取所有店铺区域"""
        return Storearea.objects.all()

    @staticmethod
    def get_by_id(storearea_id):
        """根据ID获取店铺区域"""
        return Storearea.objects.filter(id=storearea_id).first()

    @staticmethod
    def create(shape, map_id=None):
        """创建新的店铺区域，并可选绑定到指定地图"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            # 这样无论是WKT还是GeoJSON格式，都会使用正确的SRID
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        storearea = Storearea.objects.create(shape=shape_geom)
        # 绑定到地图
        if map_id is not None:
            StoreareaMap.objects.create(storearea=storearea, map_id=map_id)
        return storearea

    @staticmethod
    def update_shape(storearea_id, shape):
        """更新店铺区域的形状"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        Storearea.objects.filter(id=storearea_id).update(shape=shape_geom)
        return StoreareaContext.get_by_id(storearea_id)

    @staticmethod
    def delete(storearea_id):
        """删除店铺区域"""
        Storearea.objects.filter(id=storearea_id).delete()

    @staticmethod
    def get_events_by_storearea(storearea_id):
        """获取店铺关联的所有活动ID"""
        event_relations = EventStorearea.objects.filter(storearea_id=storearea_id)
        return [relation.event_id for relation in event_relations]


class EventContext:
    """
    活动（Event）的数据访问层
    负责与数据库交互，仅提供shape属性相关的操作
    """

    @staticmethod
    def get_all():
        """获取所有活动"""
        return Event.objects.all()

    @staticmethod
    def get_by_id(event_id):
        """根据ID获取活动"""
        return Event.objects.filter(id=event_id).first()



    @staticmethod
    def get_storeareas_by_event(event_id):
        """获取活动关联的所有店铺区域ID"""
        storearea_relations = EventStorearea.objects.filter(event_id=event_id)
        return [relation.storearea_id for relation in storearea_relations]

    @staticmethod
    def get_eventareas_by_event(event_id):
        """获取活动关联的所有活动区域ID"""
        eventarea_relations = EventEventarea.objects.filter(event_id=event_id)
        return [relation.eventarea_id for relation in eventarea_relations]

    @staticmethod
    def add_storearea_relation(event_id, storearea_id):
        """添加活动与店铺区域的关联关系"""
        return EventStorearea.objects.get_or_create(event_id=event_id, storearea_id=storearea_id)

    @staticmethod
    def remove_storearea_relation(event_id, storearea_id):
        """移除活动与店铺区域的关联关系"""
        return EventStorearea.objects.filter(event_id=event_id, storearea_id=storearea_id).delete()

    @staticmethod
    def add_eventarea_relation(event_id, eventarea_id):
        """添加活动与活动区域的关联关系"""
        return EventEventarea.objects.get_or_create(event_id=event_id, eventarea_id=eventarea_id)

    @staticmethod
    def remove_eventarea_relation(event_id, eventarea_id):
        """移除活动与活动区域的关联关系"""
        return EventEventarea.objects.filter(event_id=event_id, eventarea_id=eventarea_id).delete()


class EventareaContext:
    """
    活动区域（Eventarea）的数据访问层
    负责与数据库交互，提供基本的CRUD操作
    """

    @staticmethod
    def get_all():
        """获取所有活动区域"""
        return Eventarea.objects.all()

    @staticmethod
    def get_by_id(eventarea_id):
        """根据ID获取活动区域"""
        return Eventarea.objects.filter(id=eventarea_id).first()

    @staticmethod
    def create(shape, map_id=None):
        """创建新的活动区域，并可选绑定到指定地图"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        eventarea = Eventarea.objects.create(shape=shape_geom)
        if map_id is not None:
            EventareaMap.objects.create(eventarea=eventarea, map_id=map_id)
        return eventarea

    @staticmethod
    def update_shape(eventarea_id, shape):
        """更新活动区域的形状"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        Eventarea.objects.filter(id=eventarea_id).update(shape=shape_geom)
        return EventareaContext.get_by_id(eventarea_id)

    @staticmethod
    def delete(eventarea_id):
        """删除活动区域"""
        Eventarea.objects.filter(id=eventarea_id).delete()


class OtherareaContext:
    """
    其他区域（Otherarea）的数据访问层
    负责与数据库交互，提供基本的CRUD操作
    """

    @staticmethod
    def get_all():
        """获取所有其他区域"""
        return Otherarea.objects.all()

    @staticmethod
    def get_by_id(otherarea_id):
        """根据ID获取其他区域"""
        return Otherarea.objects.filter(id=otherarea_id).first()

    @staticmethod
    def create(shape, map_id=None, type_val=None):
        """创建新的其他区域，并可选绑定到指定地图"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        otherarea = Otherarea.objects.create(
            shape=shape_geom,
            type=type_val if type_val is not None else 0  # 默认 0，避免 NOT NULL 约束报错
        )
        if map_id is not None:
            OtherareaMap.objects.create(otherarea=otherarea, map_id=map_id)
        return otherarea

    @staticmethod
    def update_shape(otherarea_id, shape):
        """更新其他区域的形状"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        Otherarea.objects.filter(id=otherarea_id).update(shape=shape_geom)
        return OtherareaContext.get_by_id(otherarea_id)

    @staticmethod
    def delete(otherarea_id):
        """删除其他区域"""
        Otherarea.objects.filter(id=otherarea_id).delete()


class FacilityContext:
    """
    设施（Facility）的数据访问层
    """

    @staticmethod
    def get_all():
        return Facility.objects.all()

    @staticmethod
    def get_by_id(facility_id):
        return Facility.objects.filter(id=facility_id).first()

    @staticmethod
    def create(location, map_id=None, type_val=None):
        try:
            loc_geom = GEOSGeometry(location)
            if loc_geom.srid != 2385:
                loc_geom.srid = 2385
        except Exception as e:
            raise ValueError(f"Invalid spatial data: {str(e)}")

        facility = Facility.objects.create(
            location=loc_geom,
            type=type_val if type_val is not None else 0
        )
        if map_id is not None:
            FacilityMap.objects.create(facility=facility, map_id=map_id)
        return facility

    @staticmethod
    def update_location(facility_id, location):
        """更新设施位置"""
        try:
            loc_geom = GEOSGeometry(location)
            if loc_geom.srid != 2385:
                loc_geom.srid = 2385
        except Exception as e:
            raise ValueError(f"Invalid spatial data: {str(e)}")

        Facility.objects.filter(id=facility_id).update(location=loc_geom)
        return FacilityContext.get_by_id(facility_id)

    @staticmethod
    def delete(facility_id):
        Facility.objects.filter(id=facility_id).delete()


================================================================================
文件路径: python-backend\editor\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from django.apps import apps


def get_storearea_serializer():
    """获取 Storearea 序列化器"""
    Storearea = apps.get_model('core', 'Storearea')

    class StoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            fields = '__all__'
            # 由于使用了 managed=False，需要明确指定字段
            # 但 ModelSerializer 会自动从模型获取字段

    return StoreareaSerializer


def get_event_serializer():
    """获取 Event 序列化器"""
    Event = apps.get_model('core', 'Event')

    class EventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = '__all__'

    return EventSerializer


def get_eventarea_serializer():
    """获取活动区域序列化器"""
    Eventarea = apps.get_model('core', 'Eventarea')
    
    class EventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            fields = '__all__'
    
    return EventareaSerializer


def get_otherarea_serializer():
    """获取其他区域序列化器"""
    Otherarea = apps.get_model('core', 'Otherarea')
    
    class OtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            fields = '__all__'
    
    return OtherareaSerializer


def get_facility_serializer():
    """获取设施序列化器"""
    Facility = apps.get_model('core', 'Facility')

    class FacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            fields = '__all__'

    return FacilitySerializer

def get_map_serializer():
    Map = apps.get_model('core', 'Map')
    class MapSerializer(serializers.ModelSerializer):
        class Meta:
            model = Map
            fields = '__all__'
    return MapSerializer


================================================================================
文件路径: python-backend\editor\services.py
--------------------------------------------------------------------------------

from .context import StoreareaContext, EventContext, EventareaContext, OtherareaContext,FacilityContext
from map.context import MapContext
from django.contrib.gis.geos import GeometryCollection, Polygon, Point
from django.db import transaction
import ezdxf
import io


class StoreareaService:
    """
    店铺区域（Storearea）的业务层
    负责处理业务逻辑，调用数据访问层方法，仅处理shape属性相关操作
    """

    @staticmethod
    def get_all_storeareas():
        """获取所有店铺区域"""
        return StoreareaContext.get_all()

    @staticmethod
    def get_storearea_by_id(storearea_id):
        """根据ID获取店铺区域"""
        return StoreareaContext.get_by_id(storearea_id)

    @staticmethod
    def create_storearea(shape, map_id=None):
        """创建新的店铺区域，并可选绑定到指定地图"""
        return StoreareaContext.create(shape, map_id)

    @staticmethod
    def update_shape(storearea_id, shape):
        """更新店铺区域的形状"""
        # 可以在这里添加业务逻辑验证
        return StoreareaContext.update_shape(storearea_id, shape)

    @staticmethod
    def delete_storearea(storearea_id):
        """删除店铺区域"""
        # 可以在这里添加业务逻辑验证
        return StoreareaContext.delete(storearea_id)

    @staticmethod
    def get_events_for_storearea(storearea_id):
        """获取店铺关联的所有活动ID"""
        return StoreareaContext.get_events_by_storearea(storearea_id)


class EventService:
    """
    活动（Event）的业务层
    负责处理业务逻辑，调用数据访问层方法，仅处理shape属性相关操作
    """

    @staticmethod
    def get_all_events():
        """获取所有活动"""
        return EventContext.get_all()

    @staticmethod
    def get_event_by_id(event_id):
        """根据ID获取活动"""
        return EventContext.get_by_id(event_id)



    @staticmethod
    def get_areas_for_event(event_id):
        """获取活动关联的所有区域ID（包括店铺区域和活动区域）"""
        storearea_ids = EventContext.get_storeareas_by_event(event_id)
        eventarea_ids = EventContext.get_eventareas_by_event(event_id)
        return {
            'storearea_ids': storearea_ids,
            'eventarea_ids': eventarea_ids,
            'all_area_ids': storearea_ids + eventarea_ids
        }

    @staticmethod
    def add_storearea_to_event(event_id, storearea_id):
        """添加活动与店铺区域的关联关系"""
        # 可以在这里添加业务逻辑验证（如检查活动和店铺是否存在等）
        return EventContext.add_storearea_relation(event_id, storearea_id)

    @staticmethod
    def remove_storearea_from_event(event_id, storearea_id):
        """移除活动与店铺区域的关联关系"""
        # 可以在这里添加业务逻辑验证
        return EventContext.remove_storearea_relation(event_id, storearea_id)

    @staticmethod
    def add_eventarea_to_event(event_id, eventarea_id):
        """添加活动与活动区域的关联关系"""
        # 可以在这里添加业务逻辑验证（如检查活动和活动区域是否存在等）
        return EventContext.add_eventarea_relation(event_id, eventarea_id)

    @staticmethod
    def remove_eventarea_from_event(event_id, eventarea_id):
        """移除活动与活动区域的关联关系"""
        # 可以在这里添加业务逻辑验证
        return EventContext.remove_eventarea_relation(event_id, eventarea_id)


class EventareaService:
    """
    活动区域（Eventarea）的业务层
    负责处理业务逻辑，调用数据访问层方法
    注意：在editor模块中只处理shape属性的更新
    """

    @staticmethod
    def get_all_eventareas():
        """获取所有活动区域"""
        return EventareaContext.get_all()

    @staticmethod
    def get_eventarea_by_id(eventarea_id):
        """根据ID获取活动区域"""
        return EventareaContext.get_by_id(eventarea_id)

    @staticmethod
    def create_eventarea(shape, map_id=None):
        """创建新的活动区域，并可选绑定到指定地图"""
        return EventareaContext.create(shape, map_id)

    @staticmethod
    def update_eventarea_shape(eventarea_id, shape):
        """更新活动区域的形状"""
        # 可以在这里添加业务逻辑验证（如形状有效性检查等）
        return EventareaContext.update_shape(eventarea_id, shape)

    @staticmethod
    def delete_eventarea(eventarea_id):
        """删除活动区域"""
        # 可以在这里添加业务逻辑验证
        return EventareaContext.delete(eventarea_id)


class OtherareaService:
    """
    其他区域（Otherarea）的业务层
    负责处理业务逻辑，调用数据访问层方法
    注意：在editor模块中只处理shape属性的更新
    """

    @staticmethod
    def get_all_otherareas():
        """获取所有其他区域"""
        return OtherareaContext.get_all()

    @staticmethod
    def get_otherarea_by_id(otherarea_id):
        """根据ID获取其他区域"""
        return OtherareaContext.get_by_id(otherarea_id)

    @staticmethod
    def create_otherarea(shape, map_id=None, type_val=None):
        """创建新的其他区域，并可选绑定到指定地图"""
        return OtherareaContext.create(shape, map_id, type_val)

    @staticmethod
    def update_otherarea_shape(otherarea_id, shape):
        """更新其他区域的形状"""
        # 可以在这里添加业务逻辑验证（如形状有效性检查等）
        return OtherareaContext.update_shape(otherarea_id, shape)

    @staticmethod
    def delete_otherarea(otherarea_id):
        """删除其他区域"""
        # 可以在这里添加业务逻辑验证
        return OtherareaContext.delete(otherarea_id)

class FacilityService:
    """
    设施（Facility）的业务层
    """
    @staticmethod
    def get_all_facilities():
        return FacilityContext.get_all()

    @staticmethod
    def get_facility_by_id(facility_id):
        return FacilityContext.get_by_id(facility_id)

    @staticmethod
    def create_facility(location, map_id=None, type_val=None):
        return FacilityContext.create(location, map_id, type_val)

    @staticmethod
    def update_facility_location(facility_id, location):
        return FacilityContext.update_location(facility_id, location)

    @staticmethod
    def delete_facility(facility_id):
        return FacilityContext.delete(facility_id)


class MapEditorService:
    """
    地图编辑服务：处理地图及关联要素的创建、导入
    """

    # 定义 CAD 图层名称到业务类型的映射
    LAYER_MAPPING = {
        'FLOOR_OUTLINE': 'floor',  # 底图外框
        'VOIDS': 'hole',  # 底图镂空
        'AREA_STORE': 'storearea',  # 店铺区域
        'AREA_EVENT': 'eventarea',  # 活动区域
        'AREA_OTHER': 'otherarea',  # 其他区域
        'FACILITIES': 'facility'  # 设施
    }

    @staticmethod
    def create_map(building_id, floor_number, file=None):
        map_ctx = MapContext()

        # 1. 业务校验
        if map_ctx.check_exists(building_id, floor_number):
            raise ValueError("该建筑的此楼层已存在地图")

        try:
            with transaction.atomic():
                # 2. 解析 DXF 数据
                if file:
                    dxf_data = MapEditorService._parse_dxf_layers(file)
                else:
                    # 手动模式默认数据
                    dxf_data = {
                        'floor': Polygon(((0, 0), (0, 100), (100, 100), (100, 0), (0, 0)), srid=2385),
                        'holes': [],
                        'storearea': [],
                        'eventarea': [],
                        'otherarea': [],
                        'facility': []
                    }

                # 3. 组装并创建 Map (底图)
                # 将外框和镂空组合成 GeometryCollection
                if not dxf_data['floor']:
                    raise ValueError("DXF 中未找到 FLOOR_OUTLINE 图层或有效的闭合外轮廓")

                # 组合 list: [外框, 洞1, 洞2...]
                map_geometry_list = [dxf_data['floor']] + dxf_data['holes']
                map_geometry = GeometryCollection(map_geometry_list, srid=2385)

                # 调用 Context 创建地图
                new_map = map_ctx.create_map_record(building_id, floor_number, map_geometry)

                # 4. 创建关联实体 (调用 editor.context 中的各 Context)
                # 注意：editor.context.create 方法通常只接收 shape/location 和 map_id

                # A. 创建店铺
                for shape in dxf_data['storearea']:
                    # 这里可以根据需求生成默认名称，例如 "导入的店铺"
                    StoreareaContext.create(shape=shape, map_id=new_map.id)

                # B. 创建活动区
                for shape in dxf_data['eventarea']:
                    EventareaContext.create(shape=shape, map_id=new_map.id)

                # C. 创建其他区域
                for shape in dxf_data['otherarea']:
                    # type_val 默认为 0
                    OtherareaContext.create(shape=shape, map_id=new_map.id, type_val=0)

                # D. 创建设施 (点)
                for location in dxf_data['facility']:
                    # FacilityContext.create 接收 Point 对象
                    FacilityContext.create(location=location, map_id=new_map.id, type_val=0)

                return new_map

        except Exception as e:
            # 捕获异常并回滚事务（由 transaction.atomic 自动处理回滚，这里重新抛出以便 View 层捕获）
            raise ValueError(f"创建地图失败: {str(e)}")

    @staticmethod
    def _parse_dxf_layers(uploaded_file):
        """
        解析 DXF 文件，按图层分类提取几何数据
        """
        try:
            # === 修复逻辑开始 ===
            # 1. 统一转换为二进制流 (Binary Stream)
            binary_stream = None
            if isinstance(uploaded_file, bytes):
                binary_stream = io.BytesIO(uploaded_file)
            elif hasattr(uploaded_file, 'read'):
                # 已经是流对象 (BytesIO 或 Django UploadedFile)
                binary_stream = uploaded_file
            else:
                raise ValueError("不支持的文件输入类型")

            # 2. 确保指针在开头
            if hasattr(binary_stream, 'seek'):
                binary_stream.seek(0)

            # 3. 将二进制流包装为文本流 (Text Stream)
            # ezdxf.read() 需要读取字符串。DXF 通常是 cp1252 或 utf-8。
            # 使用 errors='ignore' 防止因为编码问题导致解析完全失败
            text_stream = io.TextIOWrapper(binary_stream, encoding='utf-8', errors='ignore')

            # 4. 读取 DXF
            doc = ezdxf.read(text_stream)
            # === 修复逻辑结束 ===

            msp = doc.modelspace()

            result = {
                'floor': None,
                'holes': [],
                'storearea': [],
                'eventarea': [],
                'otherarea': [],
                'facility': []
            }

            # 遍历所有实体
            for entity in msp:
                # 增加容错：有些实体可能没有 layer 属性
                if not hasattr(entity.dxf, 'layer'):
                    continue

                layer_name = entity.dxf.layer.upper()

                if layer_name not in MapEditorService.LAYER_MAPPING:
                    continue

                target_type = MapEditorService.LAYER_MAPPING[layer_name]

                # --- 处理多边形 (区域/楼层) ---
                if entity.dxftype() == 'LWPOLYLINE':
                    if not entity.closed:
                        continue  # 忽略未闭合的线

                    points = []
                    # 坐标转换：毫米 -> 米
                    for p in entity.get_points():
                        points.append((p[0] / 1000.0, p[1] / 1000.0))

                    # 确保首尾闭合
                    if points[0] != points[-1]:
                        points.append(points[0])

                    if len(points) >= 4:
                        poly = Polygon(points, srid=2385)

                        if target_type == 'floor':
                            # 假设图纸里只有一个最大的框是地板，如果有多个，暂取第一个或覆盖
                            if result['floor'] is None:
                                result['floor'] = poly
                            else:
                                # 如果有多个 FLOOR_OUTLINE，简单的逻辑是看谁面积大
                                if poly.area > result['floor'].area:
                                    result['floor'] = poly
                        elif target_type == 'hole':
                            result['holes'].append(poly)
                        elif target_type in ['storearea', 'eventarea', 'otherarea']:
                            result[target_type].append(poly)

                # --- 处理点/圆 (设施) ---
                elif entity.dxftype() in ['CIRCLE', 'POINT']:
                    if target_type == 'facility':
                        x, y = 0, 0
                        if entity.dxftype() == 'CIRCLE':
                            # 圆取圆心
                            center = entity.dxf.center
                            x, y = center.x / 1000.0, center.y / 1000.0
                        else:
                            # 点取坐标
                            loc = entity.dxf.location
                            x, y = loc.x / 1000.0, loc.y / 1000.0

                        point = Point(x, y, srid=2385)
                        result['facility'].append(point)

            return result

        except Exception as e:
            # 增加一些调试信息
            import traceback
            traceback.print_exc()
            raise ValueError(f"DXF 解析内部错误: {str(e)}")


================================================================================
文件路径: python-backend\editor\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\editor\urls.py
--------------------------------------------------------------------------------

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

# 创建路由器并注册视图集
router = DefaultRouter()
router.register(r'storearea', views.StoreareaViewSet, basename='editor_storearea')
router.register(r'event', views.EventViewSet, basename='editor_event')
router.register(r'eventarea', views.EventareaViewSet, basename='editor_eventarea')
router.register(r'otherarea', views.OtherareaViewSet, basename='editor_otherarea')
router.register(r'facility', views.FacilityViewSet, basename='editor_facility')
router.register(r'map', views.MapEditorViewSet, basename='editor_map')

urlpatterns = [
    # 包含路由器生成的所有URL
    path('', include(router.urls)),
]




================================================================================
文件路径: python-backend\editor\views.py
--------------------------------------------------------------------------------

import base64
import io
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from django.shortcuts import get_object_or_404
from rest_framework.parsers import JSONParser
from .serializers import get_storearea_serializer, get_event_serializer, get_eventarea_serializer, get_otherarea_serializer, get_facility_serializer, get_map_serializer
from .services import StoreareaService, EventService, EventareaService, OtherareaService, FacilityService, MapEditorService


class StoreareaViewSet(viewsets.ModelViewSet):
    """
    店铺区域（Storearea）的视图集
    
    注意：在editor模块中只处理shape属性的更新，其他属性在management中实现
    
    支持的操作：
    - GET /api/editor/storearea/ - 获取所有店铺区域列表
    - GET /api/editor/storearea/{id}/ - 获取指定店铺区域详情
    - POST /api/editor/storearea/ - 创建店铺区域（仅支持shape属性）
    - PATCH /api/editor/storearea/{id}/ - 部分更新店铺区域（仅支持shape属性）
    - DELETE /api/editor/storearea/{id}/ - 删除店铺区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_storearea_serializer()
    
    def get_queryset(self):
        """获取所有店铺区域"""
        return StoreareaService.get_all_storeareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有店铺区域列表"""
        storeareas = StoreareaService.get_all_storeareas()
        serializer = self.get_serializer(storeareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定店铺区域详情"""
        storearea = get_object_or_404(StoreareaService.get_all_storeareas(), pk=pk)
        serializer = self.get_serializer(storearea)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新店铺区域"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """部分更新店铺区域（仅支持shape属性）"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be updated in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        storearea = get_object_or_404(StoreareaService.get_all_storeareas(), pk=pk)
        shape = request.data.get('shape')
        
        updated_storearea = StoreareaService.update_shape(pk, shape)
        serializer = self.get_serializer(updated_storearea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建店铺区域（仅支持shape属性），并绑定到指定地图"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be provided when creating storearea in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        shape = request.data.get('shape')
        map_id = request.data.get('map_id')
        new_storearea = StoreareaService.create_storearea(shape, map_id)
        serializer = self.get_serializer(new_storearea)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    def destroy(self, request, pk=None):
        """删除店铺区域"""
        StoreareaService.delete_storearea(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)
    
    @action(detail=True, methods=['get'])
    def events(self, request, pk=None):
        """获取店铺关联的所有活动ID"""
        event_ids = StoreareaService.get_events_for_storearea(pk)
        return Response({
            'storearea_id': pk,
            'event_ids': event_ids
        })


class EventViewSet(viewsets.ModelViewSet):
    """
    活动（Event）的视图集
    
    注意：Event模型没有shape字段，因此不支持shape属性更新

    支持的操作：
    - GET /api/editor/event/ - 获取所有活动列表
    - GET /api/editor/event/{id}/ - 获取指定活动详情
    - GET /api/editor/event/{id}/areas/ - 获取活动关联的所有区域ID
    - POST/DELETE /api/editor/event/{id}/storeareas/ - 管理活动与店铺区域的关联关系
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_event_serializer()
    
    def get_queryset(self):
        """获取所有活动"""
        return EventService.get_all_events()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动列表"""
        events = EventService.get_all_events()
        serializer = self.get_serializer(events, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动详情"""
        event = get_object_or_404(EventService.get_all_events(), pk=pk)
        serializer = self.get_serializer(event)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新活动"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """不允许在editor模块中更新活动"""
        return Response(
            {'error': 'Update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def create(self, request, *args, **kwargs):
        """不允许在editor模块中创建活动"""
        return Response(
            {'error': 'Create not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def destroy(self, request, pk=None):
        """不允许在editor模块中删除活动"""
        return Response(
            {'error': 'Delete not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    @action(detail=True, methods=['get'])
    def areas(self, request, pk=None):
        """获取活动关联的所有区域ID（包括店铺区域和活动区域）"""
        areas = EventService.get_areas_for_event(pk)
        return Response({
            'event_id': pk,
            'storearea_ids': areas['storearea_ids'],
            'eventarea_ids': areas['eventarea_ids'],
            'all_area_ids': areas['all_area_ids']
        })
    
    @action(detail=True, methods=['post', 'delete'])
    def storeareas(self, request, pk=None):
        """管理活动与店铺区域的关联关系"""
        if request.method == 'POST':
            # 添加关联
            storearea_id = request.data.get('storearea_id')
            if not storearea_id:
                return Response(
                    {'error': 'storearea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            relation, created = EventService.add_storearea_to_event(pk, storearea_id)
            
            if created:
                return Response(
                    {'message': 'Relation created successfully'},
                    status=status.HTTP_201_CREATED
                )
            else:
                return Response(
                    {'message': 'Relation already exists'},
                    status=status.HTTP_200_OK
                )
        
        elif request.method == 'DELETE':
            # 删除关联
            storearea_id = request.data.get('storearea_id')
            if not storearea_id:
                return Response(
                    {'error': 'storearea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            deleted_count, _ = EventService.remove_storearea_from_event(pk, storearea_id)
            
            if deleted_count > 0:
                return Response(
                    {'message': 'Relation deleted successfully'},
                    status=status.HTTP_204_NO_CONTENT
                )
            else:
                return Response(
                    {'error': 'Relation not found'},
                    status=status.HTTP_404_NOT_FOUND
                )


class EventareaViewSet(viewsets.ModelViewSet):
    """
    活动区域（Eventarea）的视图集
    
    注意：在editor模块中只处理shape属性的更新，其他属性在management中实现
    
    支持的操作：
    - GET /api/editor/eventarea/ - 获取所有活动区域列表
    - GET /api/editor/eventarea/{id}/ - 获取指定活动区域详情
    - POST /api/editor/eventarea/ - 创建活动区域（仅支持shape属性）
    - PATCH /api/editor/eventarea/{id}/ - 部分更新活动区域（仅支持shape属性）
    - DELETE /api/editor/eventarea/{id}/ - 删除活动区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_eventarea_serializer()
    
    def get_queryset(self):
        """获取所有活动区域"""
        return EventareaService.get_all_eventareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动区域列表"""
        eventareas = EventareaService.get_all_eventareas()
        serializer = self.get_serializer(eventareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动区域详情"""
        eventarea = get_object_or_404(EventareaService.get_all_eventareas(), pk=pk)
        serializer = self.get_serializer(eventarea)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新活动区域"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """部分更新活动区域（仅支持shape属性）"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be updated in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        eventarea = get_object_or_404(EventareaService.get_all_eventareas(), pk=pk)
        shape = request.data.get('shape')
        
        updated_eventarea = EventareaService.update_eventarea_shape(pk, shape)
        serializer = self.get_serializer(updated_eventarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建活动区域（仅支持shape属性），并绑定到指定地图"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be provided when creating eventarea in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        shape = request.data.get('shape')
        map_id = request.data.get('map_id')
        new_eventarea = EventareaService.create_eventarea(shape, map_id)
        serializer = self.get_serializer(new_eventarea)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    def destroy(self, request, pk=None):
        """删除活动区域"""
        EventareaService.delete_eventarea(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)


class OtherareaViewSet(viewsets.ModelViewSet):
    """
    其他区域（Otherarea）的视图集
    
    注意：在editor模块中只处理shape属性的更新，其他属性在management中实现
    
    支持的操作：
    - GET /api/editor/otherarea/ - 获取所有其他区域列表
    - GET /api/editor/otherarea/{id}/ - 获取指定其他区域详情
    - POST /api/editor/otherarea/ - 创建其他区域（仅支持shape属性）
    - PATCH /api/editor/otherarea/{id}/ - 部分更新其他区域（仅支持shape属性）
    - DELETE /api/editor/otherarea/{id}/ - 删除其他区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_otherarea_serializer()
    
    def get_queryset(self):
        """获取所有其他区域"""
        return OtherareaService.get_all_otherareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有其他区域列表"""
        otherareas = OtherareaService.get_all_otherareas()
        serializer = self.get_serializer(otherareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定其他区域详情"""
        otherarea = get_object_or_404(OtherareaService.get_all_otherareas(), pk=pk)
        serializer = self.get_serializer(otherarea)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新其他区域"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """部分更新其他区域（仅支持shape属性）"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be updated in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        otherarea = get_object_or_404(OtherareaService.get_all_otherareas(), pk=pk)
        shape = request.data.get('shape')
        
        updated_otherarea = OtherareaService.update_otherarea_shape(pk, shape)
        serializer = self.get_serializer(updated_otherarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建其他区域（仅支持shape属性），并绑定到指定地图"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be provided when creating otherarea in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        shape = request.data.get('shape')
        map_id = request.data.get('map_id')
        type_val = request.data.get('type')
        new_otherarea = OtherareaService.create_otherarea(shape, map_id, type_val)
        serializer = self.get_serializer(new_otherarea)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    def destroy(self, request, pk=None):
        """删除其他区域"""
        OtherareaService.delete_otherarea(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)
    
    @action(detail=True, methods=['post', 'delete'])
    def eventareas(self, request, pk=None):
        """管理活动与活动区域的关联关系"""
        if request.method == 'POST':
            # 添加关联
            eventarea_id = request.data.get('eventarea_id')
            if not eventarea_id:
                return Response(
                    {'error': 'eventarea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            relation, created = EventService.add_eventarea_to_event(pk, eventarea_id)
            
            if created:
                return Response(
                    {'message': 'Relation created successfully'},
                    status=status.HTTP_201_CREATED
                )
            else:
                return Response(
                    {'message': 'Relation already exists'},
                    status=status.HTTP_200_OK
                )
        
        elif request.method == 'DELETE':
            # 删除关联
            eventarea_id = request.data.get('eventarea_id')
            if not eventarea_id:
                return Response(
                    {'error': 'eventarea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            deleted_count, _ = EventService.remove_eventarea_from_event(pk, eventarea_id)
            
            if deleted_count > 0:
                return Response(
                    {'message': 'Relation deleted successfully'},
                    status=status.HTTP_204_NO_CONTENT
                )
            else:
                return Response(
                    {'error': 'Relation not found'},
                    status=status.HTTP_404_NOT_FOUND
                )


class FacilityViewSet(viewsets.ModelViewSet):
    """
    设施（Facility）的视图集
    支持操作：更新位置 (PATCH)
    """

    def get_serializer_class(self):
        return get_facility_serializer()

    def get_queryset(self):
        return FacilityService.get_all_facilities()

    def list(self, request, *args, **kwargs):
        facilities = FacilityService.get_all_facilities()
        serializer = self.get_serializer(facilities, many=True)
        return Response(serializer.data)

    def retrieve(self, request, pk=None):
        facility = get_object_or_404(FacilityService.get_all_facilities(), pk=pk)
        serializer = self.get_serializer(facility)
        return Response(serializer.data)

    def partial_update(self, request, pk=None):
        """部分更新设施（仅支持 location 属性）"""
        if 'location' not in request.data:
            return Response(
                {'error': 'Only location attribute can be updated in editor module'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # 检查 ID 是否存在
        get_object_or_404(FacilityService.get_all_facilities(), pk=pk)

        location = request.data.get('location')
        updated_facility = FacilityService.update_facility_location(pk, location)
        serializer = self.get_serializer(updated_facility)
        return Response(serializer.data)

    def create(self, request, *args, **kwargs):
        if 'location' not in request.data:
            return Response(
                {'error': 'Location is required'}, status=status.HTTP_400_BAD_REQUEST
            )

        location = request.data.get('location')
        map_id = request.data.get('map_id')
        type_val = request.data.get('type')

        new_facility = FacilityService.create_facility(location, map_id, type_val)
        serializer = self.get_serializer(new_facility)
        return Response(serializer.data, status=status.HTTP_201_CREATED)

    def destroy(self, request, pk=None):
        FacilityService.delete_facility(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)


class MapEditorViewSet(viewsets.ViewSet):
    """
    地图创建与编辑视图
    POST /api/editor/map/
    """
    # 既然前端改用 JSON，这里只需要 JSONParser
    parser_classes = (JSONParser,)

    def create(self, request):
        building_id = request.data.get('building_id')
        floor_number = request.data.get('floor_number')

        # 获取 Base64 字符串 (格式通常为 "data:application/dxf;base64,......")
        file_data_url = request.data.get('file_data')

        if not building_id or not floor_number:
            return Response({"error": "缺少建筑ID或楼层号"}, status=status.HTTP_400_BAD_REQUEST)

        dxf_file_stream = None
        if file_data_url:
            try:
                # 1. 分离头部 (如果有) 和 内容
                if ',' in file_data_url:
                    header, data_str = file_data_url.split(',', 1)
                else:
                    data_str = file_data_url

                # 2. Base64 解码
                file_bytes = base64.b64decode(data_str)

                # 3. 转为二进制流 (BytesIO 实现了 read() 方法，ezdxf 可直接读取)
                dxf_file_stream = io.BytesIO(file_bytes)
                # 为了让 ezdxf 读取文本模式更安全，有时需要 TextIOWrapper，
                # 但 ezdxf.read() 通常也能处理 bytes。我们先传 bytes stream。

            except Exception as e:
                return Response({"error": f"文件解析失败: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            # 调用 Service (Service 逻辑无需修改，它只关心传入的对象有 read() 方法)
            new_map = MapEditorService.create_map(building_id, floor_number, dxf_file_stream)

            Serializer = get_map_serializer()
            return Response(Serializer(new_map).data, status=status.HTTP_201_CREATED)

        except ValueError as e:
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)


================================================================================
文件路径: python-backend\editor\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\editor\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\guide\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\guide\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class GuideConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'guide'



================================================================================
文件路径: python-backend\guide\context.py
--------------------------------------------------------------------------------

from django.contrib.gis.geos import Polygon, Point
from typing import Tuple, List, Optional

# 导入所有涉及的模型
from core.models import Map, Storearea, Eventarea, Otherarea, Facility, StoreareaMap, EventareaMap, OtherareaMap, \
    FacilityMap


class GuideContext:  # 不继承 BaseContext
    """
    导航模块数据上下文
    职责：只负责从数据库提取几何数据，不负责路径计算逻辑
    """

    @staticmethod
    def get_map_geometry_data(map_id: int) -> Tuple[Optional[Polygon], List[Polygon], List[Polygon]]:
        """
        一次性获取地图的边界、原始镂空以及所有障碍物

        :param map_id: 地图 ID
        :return: (outer_shell, holes, obstacles)
        """
        # 1. 获取地图底图对象
        try:
            map_obj = Map.objects.get(pk=map_id)
        except Map.DoesNotExist:
            return None, [], []

        # 2. 解析地图底图 (GeometryCollection)
        # detail[0] 通常是地板外轮廓 (Polygon)
        # detail[1:] 是地板内部的镂空 (Polygon list)
        if not map_obj.detail or len(map_obj.detail) == 0:
            return None, [], []

        outer_shell = map_obj.detail[0]
        # 确保它是 Polygon，防止脏数据
        if not isinstance(outer_shell, Polygon):
            return None, [], []

        holes = []
        # 可能有镂空，也可能没有镂空
        if len(map_obj.detail) > 1:
            holes = list(map_obj.detail[1:])

        # 3. 获取所有业务层面的障碍物
        # 将所有障碍物统一合并到一个列表中返回
        obstacles = []

        # --- A. 获取商铺区域 (Polygon) ---
        stores = Storearea.objects.filter(
            storeareamap__map_id=map_id,
            shape__isnull=False
        ).values_list('shape', flat=True)
        obstacles.extend(stores)

        # --- B. 获取活动区域 (Polygon) ---
        events = Eventarea.objects.filter(
            eventareamap__map_id=map_id,
            shape__isnull=False
        ).values_list('shape', flat=True)
        obstacles.extend(events)

        # --- C. 获取其他区域 (Polygon) ---
        others = Otherarea.objects.filter(
            otherareamap__map_id=map_id,
            shape__isnull=False
        ).values_list('shape', flat=True)
        obstacles.extend(others)

        # --- D. 获取设施 (Point -> Polygon) ---
        facilities = Facility.objects.filter(
            facilitymap__map_id=map_id,
            location__isnull=False
        ).values_list('location', flat=True)
        # 将设施点膨胀后放入障碍物列表
        for point in facilities:
            # buffer(0.5) 表示以点为中心，半径 0.5 米的圆
            if isinstance(point, Point):
                obstacles.append(point.buffer(0.5))

        return outer_shell, holes, obstacles



================================================================================
文件路径: python-backend\guide\services.py
--------------------------------------------------------------------------------

# import networkx as nx
# from django.contrib.gis.geos import Point, LineString
# from map.context import MapContext
# from map.services import MapServices  # 复用校验逻辑
#
#
# class GuideService:
#
#     def __init__(self, map_id: int):
#         self.map_id = map_id
#         # 通过 Context 获取数据
#         self.outer_shell, self.holes = MapContext.get_map_geometry(map_id)
#         # 获取所有障碍物 (Map镂空 + 实体店铺 + 设施)
#         # 这里的 obstacles 是纯几何对象列表
#         self.obstacles = list(self.holes) + MapContext.get_all_obstacles(map_id)
#
#     # --- 接口 5: 完善导航接口 ---
#     def find_path(self, start_point: Point, end_point: Point):
#         """
#         计算单楼层内的两点路径
#         """
#         if not self.outer_shell:
#             return {"success": False, "message": "Map not initialized"}
#
#         # 0. 校验起终点合法性 (复用 MapService 的逻辑)
#         # 注意：这里我们假设 MapService 是无状态的工具类
#         valid_start, msg_start = MapService.check_area_placement(start_point, self.map_id)
#         # 对终点的检查可能需要放宽（因为终点可能就在店铺门口），这里暂时严格检查
#         valid_end, msg_end = MapService.check_area_placement(end_point, self.map_id)
#
#         if not valid_start:
#             return {"success": False, "message": f"Start point invalid: {msg_start}"}
#         # 如果终点是店铺，check_area_placement 会报错（因为和店铺重合），
#         # 实际逻辑中应该判断终点是否在障碍物内部，如果在内部，应该“弹出”到最近的可行走点。
#         # 此处简化，假设输入点已经处理过。
#
#         # 1. 构建可见性图 (Visibility Graph)
#         graph = nx.Graph()
#
#         # 节点包括：起点、终点、所有障碍物的顶点
#         nodes = [start_point, end_point]
#         for obs in self.obstacles:
#             # 获取多边形外环坐标 (去除最后一个重复点)
#             coords = obs.exterior.coords[:-1]
#             nodes.extend([Point(c, srid=2385) for c in coords])
#
#         # 2. 构建边
#         # 优化：仅在节点数较少时使用全连接 O(N^2)
#         node_ids = range(len(nodes))
#
#         for i in node_ids:
#             graph.add_node(i, pos=(nodes[i].x, nodes[i].y))
#
#         for i in node_ids:
#             for j in range(i + 1, len(nodes)):
#                 p1 = nodes[i]
#                 p2 = nodes[j]
#
#                 if self._is_line_of_sight_clear(p1, p2):
#                     dist = p1.distance(p2)
#                     graph.add_edge(i, j, weight=dist)
#
#         # 3. 计算 Dijkstra
#         try:
#             path_indices = nx.dijkstra_path(graph, source=0, target=1)
#             path_coords = [(nodes[i].x, nodes[i].y) for i in path_indices]
#
#             return {
#                 "success": True,
#                 "distance": nx.dijkstra_path_length(graph, source=0, target=1),
#                 "path": LineString(path_coords, srid=2385),
#                 "steps": path_coords
#             }
#         except nx.NetworkXNoPath:
#             return {
#                 "success": False,
#                 "message": "No walkable path found."
#             }
#
#     def _is_line_of_sight_clear(self, p1: Point, p2: Point) -> bool:
#         """
#         私有方法：判断视线是否被阻挡
#         """
#         line = LineString(p1, p2)
#
#         # 必须在外轮廓内
#         if not self.outer_shell.contains(line):
#             return False
#
#         # 不能穿过任何障碍物
#         for obstacle in self.obstacles:
#             # 使用 relation 或者 intersection 判断
#             if obstacle.intersects(line) and not obstacle.touches(line):
#                 return False
#         return True

from django.contrib.gis.geos import Point, LineString, Polygon
from typing import Tuple, List, Optional
import math
import heapq

# Context 导入
from guide.context import GuideContext


class GridSystem:
    """
    辅助类：网格系统类
    负责将世界坐标(Geo)转换为离散的网格坐标(Grid)
    并管理障碍物矩阵
    """

    def __init__(self, boundary_polygon: Polygon, resolution: float = 0.5):
        """
        :param boundary_polygon: 地图的外轮廓
        :param resolution: 网格精度，例如 0.5 表示每个网格格子 0.5x0.5 米
        """
        self.resolution = resolution
        self.boundary = boundary_polygon
        # 获取多边形 boundary_polygon 的最小最大坐标
        self.min_x, self.min_y, self.max_x, self.max_y = boundary_polygon.extent
        # 计算网格系统的 x方向、 y方向各自的格子总数
        self.width = int(math.ceil((self.max_x - self.min_x) / resolution))  # 这个方法 ceil 是向上取整
        self.height = int(math.ceil((self.max_y - self.min_y) / resolution))
        # 障碍物集合，存储不可行走的网格坐标元组 (gx, gy)
        self.obstacles = set()

    def world_to_grid(self, x: float, y: float) -> Tuple[int, int]:
        """将世界坐标转为网格坐标"""
        gx = int((x - self.min_x) / self.resolution)  # int() 是向下取整
        gy = int((y - self.min_y) / self.resolution)
        return gx, gy

    def grid_to_world(self, gx: int, gy: int) -> Tuple[float, float]:
        """将网格坐标中心转为世界坐标"""
        wx = self.min_x + (gx + 0.5) * self.resolution  # 这里是加上半格的意思，不是加上 0.5 米
        wy = self.min_y + (gy + 0.5) * self.resolution
        return wx, wy

    def mark_obstacles(self, geometry_list: List[Polygon]):
        """
        向 self.obstacles 集合中存储障碍物占据的格子坐标
        某个障碍物占据了哪些格子
        逆向思维：判断这个格子是否在这个障碍物多边形内
        """
        for poly in geometry_list:
            # 1. 性能优化：不要扫描全图，只扫描障碍物所在的那个矩形区域（Bounding Box）
            # poly.extent 返回 (min_x, min_y, max_x, max_y)
            min_x, min_y, max_x, max_y = poly.extent

            # 2. 把这个矩形区域的四个角，转换成网格坐标
            # min_gx, min_gy 是左下角格子的索引
            # max_gx, max_gy 是右上角格子的索引
            min_gx, min_gy = self.world_to_grid(min_x, min_y)
            max_gx, max_gy = self.world_to_grid(max_x, max_y)

            # 3. 修正边界，防止算出负数或者超出地图宽度的索引
            min_gx = max(0, min_gx)
            min_gy = max(0, min_gy)
            max_gx = min(self.width, max_gx + 1)  # +1 是为了保证循环能覆盖到边缘
            max_gy = min(self.height, max_gy + 1)

            # 4. 循环遍历这个小区域内的每一个格子
            for gx in range(min_gx, max_gx):
                for gy in range(min_gy, max_gy):
                    # 算出这个格子中心点在地图上的真实坐标 (wx, wy)
                    wx, wy = self.grid_to_world(gx, gy)

                    # 创建一个临时的点对象
                    cell_center = Point(wx, wy, srid=2385)

                    # 5. 关键判断：如果这个格子的中心点碰到了障碍物，这个格子就是不可走的
                    # intersects() 表示“相交”或“重叠”
                    if poly.intersects(cell_center):
                        self.obstacles.add((gx, gy))

    def is_walkable(self, gx: int, gy: int) -> bool:
        """检查网格点是否在地图内且不是障碍物"""
        # 1. 数组边界检查，严格小于 self.width，因为 self.width 是上取整
        if not (0 <= gx < self.width and 0 <= gy < self.height):
            return False
        # 2. 障碍物检查
        if (gx, gy) in self.obstacles:
            return False
        # 3. 地图边界检查
        # 算出这个格子中心的真实世界坐标
        wx, wy = self.grid_to_world(gx, gy)
        # 构造一个临时的点对象
        point = Point(wx, wy, srid=2385)
        # contains() 表示如果点在多边形内部返回 True，在外部返回 False
        if not self.boundary.contains(point):
            return False

        return True


class RoutePlanService:
    """
    路径规划业务服务层
    """

    def __init__(self):
        # 创建上下文对象
        self.ctx = GuideContext()

    def validate_request_params(self, map_id, start_data, end_data) -> Tuple[bool, str]:
        """
        在View中使用的，对Request请求参数的校验逻辑
        """
        # 1. 必填项校验
        if map_id is None:
            return False, "Missing parameter: map_id"
        if not start_data or not end_data:
            return False, "Missing parameter: start or end coordinates"

        # 2. 字典结构校验
        if not isinstance(start_data, dict) or not isinstance(end_data, dict):
            return False, "Coordinates must be JSON objects with x and y"

        # 3. 坐标数值校验
        try:
            float(start_data.get('x'))
            float(start_data.get('y'))
            float(end_data.get('x'))
            float(end_data.get('y'))
        except (ValueError, TypeError):
            return False, "Coordinates x and y must be valid numbers"

        return True, "Request params are valid"

    def calculate_route(self, map_id: int, start_pt: Point, end_pt: Point) -> Optional[LineString]:
        """
        主入口：计算路径
        """
        # 1. 获取地图几何数据 (调用 Context)
        # 期望返回:
        # outer_shell: Polygon (地图地板轮廓)
        # holes: List[Polygon] (地图本身镂空)
        # obstacles: List[Geometry] (商铺、活动区、其他区域、膨胀后的设施)
        outer_shell, holes, obstacles = self.ctx.get_map_geometry_data(map_id)

        if not outer_shell:
            raise ValueError(f"Map #{map_id} outer_shell missing")

        # 2. 初始化网格系统 (Grid System)
        # 设定分辨率为 0.5 米 (可根据性能需求调整)
        grid_sys = GridSystem(outer_shell, resolution=0.5)

        # 3. 网格化障碍物
        # 将 holes 和 obstacles 合并处理
        all_obstacles = holes + obstacles
        grid_sys.mark_obstacles(all_obstacles)

        # 4. 起点、终点坐标转换
        start_node = grid_sys.world_to_grid(start_pt.x, start_pt.y)
        end_node = grid_sys.world_to_grid(end_pt.x, end_pt.y)

        # 5. 校验起终点有效性
        if not grid_sys.is_walkable(*start_node):
            raise ValueError("Start node is not walkable")
        if not grid_sys.is_walkable(*end_node):
            raise ValueError("End node is not walkable")

        # 6. 执行 A* 算法，返回网格坐标的列表
        path_nodes = self._run_astar(start_node, end_node, grid_sys)

        if not path_nodes:
            return None

        # 7. 结果转换 (Grid Nodes -> Geo LineString)
        # 将网格路径转回世界坐标的折线
        return self._construct_linestring(path_nodes, grid_sys)

    def _run_astar(self, start_node: Tuple[int, int], end_node: Tuple[int, int], grid: GridSystem) \
            -> List[Tuple[int, int]]:
        """
        A* 算法核心逻辑
        :param start_node: (gx, gy) 起点
        :param end_node: (gx, gy) 终点
        :param grid: 网格系统对象，用于判断可行走性
        :return: [(x1, y1), (x2, y2), ...] 路径列表，如果找不到路径返回 None
        """
        # 1. 初始化 open_set (优先队列)，存放 (f_score, node)，可能的扩展节点
        # f_score = g_score + h_score
        open_set = []
        heapq.heappush(open_set, (0, start_node))

        # 2. 初始化记录字典
        # came_from: 记录路径回溯，key=当前节点, value=父节点
        came_from = {}

        # g_score: 从起点到当前节点的实际代价。默认无穷大。
        g_score = {start_node: 0.0}

        # f_score: 预估总代价。默认无穷大。
        # f_score[start_node] = h(start_node, end)
        f_score = {start_node: self._heuristic(start_node, end_node)}

        # 定义移动方向和对应的代价
        # (dx, dy, cost)
        sqrt2 = math.sqrt(2)
        movements = [
            (0, 1, 1.0), (0, -1, 1.0), (1, 0, 1.0), (-1, 0, 1.0),  # 上下右左
            (1, 1, sqrt2), (1, -1, sqrt2), (-1, 1, sqrt2), (-1, -1, sqrt2)  # 对角线
        ]

        # 3. 主循环，当 open_set 非空
        while open_set:
            # 取出 f_score 最小的节点
            current_f, current = heapq.heappop(open_set)

            # --- 成功到达终点 ---
            if current == end_node:
                return self._reconstruct_path(came_from, current)

            # 遍历 8 个邻居
            for dx, dy, move_cost in movements:
                neighbor = (current[0] + dx, current[1] + dy)

                # --- 核心判断：如果邻居不可走则跳过 ---
                if not grid.is_walkable(*neighbor):
                    continue

                # 计算经过当前节点到达邻居的 tentative_g (临时G值)
                tentative_g = g_score[current] + move_cost

                # 如果临时G值小于该邻居之前的G值，或者之前没访问过该邻居 (字典里找不到 neighbor 这个 key，就返回 inf)
                if tentative_g < g_score.get(neighbor, float('inf')):
                    # 更新记录
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g

                    # 计算 f 值 = g + h
                    new_f = tentative_g + self._heuristic(neighbor, end_node)
                    f_score[neighbor] = new_f

                    # 加入优先队列等待处理
                    heapq.heappush(open_set, (new_f, neighbor))

        # 循环结束仍未找到终点
        return None

    def _reconstruct_path(self, came_from: dict, current: Tuple[int, int]) -> List[Tuple[int, int]]:
        """
        私有辅助方法：从终点回溯到起点，重建路径
        """
        total_path = [current]
        while current in came_from:
            current = came_from[current]
            total_path.append(current)

        # 因为是从终点往回找的，所以要反转列表
        return total_path[::-1]

    def _heuristic(self, node_a: Tuple[int, int], node_b: Tuple[int, int]) -> float:
        """
        启发函数 (对角距离)
        """
        delta_x = abs(node_a[0] - node_b[0])
        delta_y = abs(node_a[1] - node_b[1])
        h_value = delta_x + delta_y + (math.sqrt(2) - 2) * min(delta_x, delta_y)
        return h_value

    def _construct_linestring(self, path_nodes: List[Tuple[int, int]], grid: GridSystem) -> LineString:
        """
        将网格节点序列转换为 PostGIS LineString 对象
        """
        points = []
        for gx, gy in path_nodes:
            wx, wy = grid.grid_to_world(gx, gy)
            points.append((wx, wy))

        return LineString(points, srid=2385)



================================================================================
文件路径: python-backend\guide\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase
from unittest.mock import MagicMock, patch
from django.contrib.gis.geos import Polygon, Point, LineString
from guide.services import RoutePlanService, GridSystem
from rest_framework.test import APITestCase
from rest_framework import status
from django.contrib.gis.geos import Polygon, GeometryCollection, Point
from core.models import Map, Building, Storearea, StoreareaMap


class GridSystemTestCase(TestCase):
    """
    测试 GridSystem 类的底层逻辑 (坐标转换、障碍物标记、边界检查)
    """

    def setUp(self):
        # 创建一个 10x10 的正方形地图 (SRID=2385)
        # 坐标范围: (0,0) -> (10,10)
        self.boundary = Polygon(((0, 0), (0, 10), (10, 10), (10, 0), (0, 0)), srid=2385)
        # 分辨率设为 1.0 米，方便计算 (网格大小 10x10)
        self.grid = GridSystem(self.boundary, resolution=1.0)

    def test_coordinate_conversion(self):
        """测试世界坐标与网格坐标的相互转换"""
        # 测试 world_to_grid (向下取整)
        # 坐标 (1.5, 1.5) 应该落在 (1, 1) 格子
        gx, gy = self.grid.world_to_grid(1.5, 1.5)
        self.assertEqual((gx, gy), (1, 1))

        # 测试 grid_to_world (取中心点)
        # 格子 (1, 1) 的中心应该是 (1.5, 1.5)
        wx, wy = self.grid.grid_to_world(1, 1)
        self.assertEqual((wx, wy), (1.5, 1.5))

    def test_mark_obstacles(self):
        """测试障碍物栅格化逻辑"""
        # 创建一个位于地图中心的障碍物 (4,4) 到 (6,6)
        obstacle = Polygon(((4, 4), (4, 6), (6, 6), (6, 4), (4, 4)), srid=2385)

        self.grid.mark_obstacles([obstacle])

        # 检查障碍物内部的点 (5, 5) -> 不可走
        self.assertFalse(self.grid.is_walkable(5, 5))

        # 检查障碍物边缘的点 (网格化后可能会占据边缘)
        # (4, 4) 根据 intersects 判定通常会被占据
        self.assertFalse(self.grid.is_walkable(4, 4))

        # 检查开阔区域的点 (1, 1) -> 可走
        self.assertTrue(self.grid.is_walkable(1, 1))

    def test_boundary_check_complex_shape(self):
        """
        测试不规则形状地图的边界检查 (L型地图)
        验证 is_walkable 中的 boundary.contains 逻辑
        """
        # 创建一个 L 型多边形 (缺口在右上角)
        # (0,0) -> (0,10) -> (5,10) -> (5,5) -> (10,5) -> (10,0) -> (0,0)
        l_shape_wkt = "POLYGON((0 0, 0 10, 5 10, 5 5, 10 5, 10 0, 0 0))"
        l_shape = Polygon.from_ewkt(l_shape_wkt)
        l_shape.srid = 2385

        grid = GridSystem(l_shape, resolution=1.0)

        # 1. 测试在地图内的点 (2, 2)
        self.assertTrue(grid.is_walkable(2, 2))

        # 2. 测试在 L 型缺口处的点 (8, 8)
        # 虽然 (8, 8) 在 GridSystem 的数组索引范围内 (width=10, height=10)
        # 但它在物理上位于大楼外部
        self.assertFalse(grid.is_walkable(8, 8))


class RoutePlanServiceTestCase(TestCase):
    """
    测试 A* 算法服务层逻辑
    使用 Mock 屏蔽 Context/数据库 操作
    """

    def setUp(self):
        self.service = RoutePlanService()
        # 基础地图: 20x20 米的正方形
        self.map_boundary = Polygon(((0, 0), (0, 20), (20, 20), (20, 0), (0, 0)), srid=2385)

    @patch('guide.services.GuideContext')
    def test_simple_straight_path(self, MockContext):
        """测试无障碍物的直线路径"""
        # --- Mock 设置 ---
        mock_ctx_instance = MockContext.return_value
        # 返回: (外框, 镂空[], 障碍物[])
        mock_ctx_instance.get_map_geometry_data.return_value = (self.map_boundary, [], [])

        # 替换 service 中的 ctx
        self.service.ctx = mock_ctx_instance

        # --- 执行测试 ---
        start = Point(2, 2, srid=2385)
        end = Point(18, 18, srid=2385)

        # 运行算法
        route = self.service.calculate_route(map_id=1, start_pt=start, end_pt=end)

        # --- 断言 ---
        self.assertIsInstance(route, LineString)
        # 直线距离约为 22.62 米
        # A* 也是走的对角线，长度应该非常接近直线距离
        self.assertAlmostEqual(route.length, start.distance(end), delta=1.0)

    @patch('guide.services.GuideContext')
    def test_obstacle_avoidance(self, MockContext):
        """测试绕行逻辑：起点和终点中间有一堵墙，必须从缺口绕过去"""
        # --- Mock 设置 ---
        mock_ctx_instance = MockContext.return_value

        # 定义障碍物：一堵带缺口的墙
        # 墙的范围：y轴 9到11，x轴 5到20。
        # 这意味着 x轴 0到5 的区域是空的（缺口），路径只能从这里通过。
        wall_with_gap = Polygon(((5, 9), (5, 11), (20, 11), (20, 9), (5, 9)), srid=2385)

        # 模拟 Context 返回：地图边界、无镂空、以及上面定义的障碍物
        mock_ctx_instance.get_map_geometry_data.return_value = (
            self.map_boundary,
            [],
            [wall_with_gap]
        )
        self.service.ctx = mock_ctx_instance

        # --- 执行测试 ---
        # 起点(10, 2) -> 终点(10, 18)
        # 直线连线会被墙挡住 (墙在 y=9~11, x=5~20)
        start = Point(10, 2, srid=2385)
        end = Point(10, 18, srid=2385)

        route = self.service.calculate_route(1, start, end)

        # --- 断言 ---
        self.assertIsNotNone(route)

        # 1. 验证路径长度：肯定大于直线距离 (16米)
        # 直线距离 = 18 - 2 = 16
        self.assertTrue(route.length > 16.0)

        # 2. 验证路径走向：必须经过左侧缺口
        # 获取路径上所有点的 x 坐标
        coords = route.coords
        min_x_in_path = min(p[0] for p in coords)

        # 因为墙是从 x=5 开始的，所以要想过去，路径中至少有一个点的 x 必须小于 5 (或者接近 5)
        # 我们这里断言 < 6.0 是为了留一点网格化精度的余量
        self.assertLess(min_x_in_path, 6.0)

    @patch('guide.services.GuideContext')
    def test_unreachable_target(self, MockContext):
        """测试终点被完全包围无法到达的情况"""
        mock_ctx_instance = MockContext.return_value

        # 障碍物完全包围终点 (10, 10)
        box = Polygon(((8, 8), (8, 12), (12, 12), (12, 8), (8, 8)), srid=2385)

        mock_ctx_instance.get_map_geometry_data.return_value = (self.map_boundary, [], [box])
        self.service.ctx = mock_ctx_instance

        start = Point(2, 2, srid=2385)
        end = Point(10, 10, srid=2385)  # 在盒子里面

        # 预期抛出 ValueError (因为 End node is not walkable)
        # 或者如果 End node 勉强算 walkable 但无法到达，则返回 None
        # 根据 services.py 逻辑，先检查 is_walkable

        # 由于障碍物占位，End point 所在的网格会被标记为 obstacle
        with self.assertRaises(ValueError) as cm:
            self.service.calculate_route(1, start, end)

        self.assertIn("End node is not walkable", str(cm.exception))


class GuideIntegrationTestCase(APITestCase):
    """
    第二步：集成测试
    测试 Views -> Services -> Context -> DB 的完整链路
    """

    def setUp(self):
        # 1. 创建基础建筑 (外键依赖)
        self.building = Building.objects.create(
            name="Test Mall",
            address="123 Test St"
        )

        # 2. 创建地图 (Map)
        # 地图是一个 20x20 的正方形
        # 注意：Map 的 detail 字段是 GeometryCollection
        boundary = Polygon(((0, 0), (0, 20), (20, 20), (20, 0), (0, 0)), srid=2385)
        gc = GeometryCollection(boundary, srid=2385)

        self.map_obj = Map.objects.create(
            building=self.building,
            floor_number=1,
            detail=gc
        )

        # 3. 创建一个商铺 (障碍物)
        # 商铺挡在地图中间 (8,8) 到 (12,12)
        store_shape = Polygon(((8, 8), (8, 12), (12, 12), (12, 8), (8, 8)), srid=2385)
        self.store = Storearea.objects.create(
            store_name="Blocker Store",
            owner_name="Test Owner",
            owner_phone="123",
            shape=store_shape,
            is_active=True  # 确保是激活状态
        )

        # 4. 关联商铺和地图 (建立中间表关系)
        # 注意：根据你的 models.py，StoreareaMap 有两个外键
        StoreareaMap.objects.create(
            storearea=self.store,
            map=self.map_obj
        )

        # API URL (需要你在 urls.py 中配置好，这里假设路径是 /api/guide/route/)
        self.url = '/api/guide/route/'

    def test_route_api_success(self):
        """测试完整的 API 调用流程"""
        # 起点 (2,2)，终点 (18,18)
        # 中间有商铺挡路，应该能规划出路径
        payload = {
            "map_id": self.map_obj.id,
            "start": {"x": 2.0, "y": 2.0},
            "end": {"x": 18.0, "y": 18.0}
        }

        response = self.client.post(self.url, payload, format='json')

        # 1. 验证状态码 200
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        # 2. 验证返回数据结构
        data = response.data
        self.assertIn("route", data)
        self.assertIn("distance", data)
        self.assertIsInstance(data["route"], dict)  # GeoJSON 对象
        self.assertIsInstance(data["route"]["coordinates"], list)

        # 3. 验证距离是否合理 (直线约22米，绕路肯定大于22米)
        self.assertTrue(data["distance"] > 22.0)

        # 打印一下结果看看
        print(f"\n[Integration Test] Route Distance: {data['distance']} meters")

    def test_api_missing_params(self):
        """测试参数缺失情况"""
        payload = {"map_id": self.map_obj.id}  # 缺少 start/end
        response = self.client.post(self.url, payload, format='json')
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

    def test_api_invalid_coordinates(self):
        """测试无效坐标 (起点在墙里)"""
        # 起点 (10, 10) 正好在刚才创建的 Storearea 内部
        payload = {
            "map_id": self.map_obj.id,
            "start": {"x": 10.0, "y": 10.0},
            "end": {"x": 18.0, "y": 18.0}
        }
        response = self.client.post(self.url, payload, format='json')

        # 预期报错：Start node is not walkable
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn("error", response.data)


================================================================================
文件路径: python-backend\guide\views.py
--------------------------------------------------------------------------------

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.contrib.gis.geos import Point
import json

# 导入服务类
from .services import RoutePlanService


class RoutePlanView(APIView):
    """
    POST /api/guide/route/
    接收起点终点坐标，返回路径规划结果
    """
    service_class = RoutePlanService

    def post(self, request):
        service = self.service_class()

        # 读取前端传参
        # 前端传参示例: {"map_id": 1, "start": {"x": 10.0, "y": 20.0}, "end": {"x": 50.0, "y": 60.0}}
        map_id = request.data.get('map_id')
        start_data = request.data.get('start')
        end_data = request.data.get('end')

        # 这一步负责检查参数是否存在、格式是否正确、坐标是否可转换为浮点数
        # 我们不需要在这里写 if-else，全交给 Service
        is_valid, error_msg = service.validate_request_params(map_id, start_data, end_data)

        if not is_valid:
            return Response({"error": error_msg}, status=status.HTTP_400_BAD_REQUEST)

        try:
            # 经过上面的校验，这里可以放心转换，不用担心 KeyError 或 TypeError
            start_point = Point(float(start_data['x']), float(start_data['y']), srid=2385)
            end_point = Point(float(end_data['x']), float(end_data['y']), srid=2385)

        except Exception as e:
            # 极端异常情况
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)

        try:
            # 预期 service 返回一个 LineString 对象
            route_geometry = service.calculate_route(map_id, start_point, end_point)

            if not route_geometry:
                return Response({"error": "Route not found or unreachable"}, status=status.HTTP_404_NOT_FOUND)

            # 构造返回
            response_data = {
                # json.loads(route_geometry.geojson) 将 GeoJSON 字符串转为 Python 字典/列表
                "route": json.loads(route_geometry.geojson),
                # route_geometry.length 自动计算米制长度，然后保留 2 位小数
                "distance": round(route_geometry.length, 2)
            }

            return Response(response_data)

        except Exception as e:
            # 捕获如算法内部抛出的业务异常
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)


================================================================================
文件路径: python-backend\guide\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\guide\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\management\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\management\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class ManagementConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'management'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\management\context.py
--------------------------------------------------------------------------------

from core.models import Eventarea, Otherarea, Event, Storearea, Facility,Admin
from core.context import BaseContext

class EventareaContext:
    """
    活动区域（Eventarea）的数据访问层
    
    提供与Eventarea模型相关的数据操作方法
    """
    
    @staticmethod
    def get_all_eventareas():
        """
        获取所有活动区域
        
        Returns:
            QuerySet: 活动区域的查询集
        """
        return Eventarea.objects.all()
    
    @staticmethod
    def get_eventarea_by_id(eventarea_id):
        """
        根据ID获取活动区域
        
        Args:
            eventarea_id: 活动区域ID
        
        Returns:
            Eventarea: 活动区域对象
        """
        return Eventarea.objects.get(id=eventarea_id)
    
    @staticmethod
    def create_eventarea(data):
        """
        创建新的活动区域
        
        Args:
            data: 活动区域数据
        
        Returns:
            Eventarea: 创建的活动区域对象
        """
        return Eventarea.objects.create(**data)
    
    @staticmethod
    def update_eventarea(eventarea_id, data):
        """
        更新活动区域
        
        Args:
            eventarea_id: 活动区域ID
            data: 更新数据
        
        Returns:
            Eventarea: 更新后的活动区域对象
        """
        eventarea = Eventarea.objects.get(id=eventarea_id)
        for key, value in data.items():
            setattr(eventarea, key, value)
        eventarea.save()
        return eventarea
    
    @staticmethod
    def delete_eventarea(eventarea_id):
        """
        删除活动区域
        
        Args:
            eventarea_id: 活动区域ID
        """
        Eventarea.objects.filter(id=eventarea_id).delete()


class EventContext:
    """
    活动（Event）的数据访问层
    
    提供与Event模型相关的数据操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """
    
    @staticmethod
    def get_all_events():
        """
        获取所有活动
        
        Returns:
            QuerySet: 活动的查询集
        """
        return Event.objects.all()
    
    @staticmethod
    def get_event_by_id(event_id):
        """
        根据ID获取活动
        
        Args:
            event_id: 活动ID
        
        Returns:
            Event: 活动对象
        """
        return Event.objects.get(id=event_id)
    
    @staticmethod
    def create_event(data):
        """
        创建新的活动
        
        Args:
            data: 活动数据
        
        Returns:
            Event: 创建的活动对象
        """
        return Event.objects.create(**data)
    
    @staticmethod
    def update_event(event_id, data):
        """
        更新活动
        
        Args:
            event_id: 活动ID
            data: 更新数据
        
        Returns:
            Event: 更新后的活动对象
        """
        event = Event.objects.get(id=event_id)
        for key, value in data.items():
            setattr(event, key, value)
        event.save()
        return event
    
    @staticmethod
    def delete_event(event_id):
        """
        删除活动
        
        Args:
            event_id: 活动ID
        """
        Event.objects.filter(id=event_id).delete()


class StoreareaContext:
    """
    店铺区域（Storearea）的数据访问层
    
    提供与Storearea模型相关的数据操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """
    
    @staticmethod
    def get_all_storeareas():
        """
        获取所有店铺区域
        
        Returns:
            QuerySet: 店铺区域的查询集
        """
        return Storearea.objects.all()
    
    @staticmethod
    def get_storearea_by_id(storearea_id):
        """
        根据ID获取店铺区域
        
        Args:
            storearea_id: 店铺区域ID
        
        Returns:
            Storearea: 店铺区域对象
        """
        return Storearea.objects.get(id=storearea_id)
    
    @staticmethod
    def create_storearea(data):
        """
        创建新的店铺区域
        
        Args:
            data: 店铺区域数据
        
        Returns:
            Storearea: 创建的店铺区域对象
        """
        return Storearea.objects.create(**data)
    
    @staticmethod
    def update_storearea(storearea_id, data):
        """
        更新店铺区域
        
        Args:
            storearea_id: 店铺区域ID
            data: 更新数据
        
        Returns:
            Storearea: 更新后的店铺区域对象
        """
        storearea = Storearea.objects.get(id=storearea_id)
        for key, value in data.items():
            setattr(storearea, key, value)
        storearea.save()
        return storearea
    
    @staticmethod
    def delete_storearea(storearea_id):
        """
        删除店铺区域
        
        Args:
            storearea_id: 店铺区域ID
        """
        Storearea.objects.filter(id=storearea_id).delete()


class OtherareaContext:
    """
    其他区域（Otherarea）的数据访问层
    
    提供与Otherarea模型相关的数据操作方法
    """
    
    @staticmethod
    def get_all_otherareas():
        """
        获取所有其他区域
        
        Returns:
            QuerySet: 其他区域的查询集
        """
        return Otherarea.objects.all()
    
    @staticmethod
    def get_otherarea_by_id(otherarea_id):
        """
        根据ID获取其他区域
        
        Args:
            otherarea_id: 其他区域ID
        
        Returns:
            Otherarea: 其他区域对象
        """
        return Otherarea.objects.get(id=otherarea_id)
    
    @staticmethod
    def create_otherarea(data):
        """
        创建新的其他区域
        
        Args:
            data: 其他区域数据
        
        Returns:
            Otherarea: 创建的其他区域对象
        """
        return Otherarea.objects.create(**data)
    
    @staticmethod
    def update_otherarea(otherarea_id, data):
        """
        更新其他区域
        
        Args:
            otherarea_id: 其他区域ID
            data: 更新数据
        
        Returns:
            Otherarea: 更新后的其他区域对象
        """
        otherarea = Otherarea.objects.get(id=otherarea_id)
        for key, value in data.items():
            setattr(otherarea, key, value)
        otherarea.save()
        return otherarea
    
    @staticmethod
    def delete_otherarea(otherarea_id):
        """
        删除其他区域
        
        Args:
            otherarea_id: 其他区域ID
        """
        Otherarea.objects.filter(id=otherarea_id).delete()


class FacilityContext:
    """
    设施（Facility）的数据访问层
    
    提供与Facility模型相关的数据操作方法
    注意：location属性由editor模块处理
    """
    
    @staticmethod
    def get_all_facilities():
        """
        获取所有设施
        
        Returns:
            QuerySet: 设施的查询集
        """
        return Facility.objects.all()
    
    @staticmethod
    def get_facility_by_id(facility_id):
        """
        根据ID获取设施
        
        Args:
            facility_id: 设施ID
        
        Returns:
            Facility: 设施对象
        """
        return Facility.objects.get(id=facility_id)
    
    @staticmethod
    def create_facility(data):
        """
        创建新的设施
        
        Args:
            data: 设施数据
        
        Returns:
            Facility: 创建的设施对象
        """
        return Facility.objects.create(**data)
    
    @staticmethod
    def update_facility(facility_id, data):
        """
        更新设施
        
        Args:
            facility_id: 设施ID
            data: 更新数据
        
        Returns:
            Facility: 更新后的设施对象
        """
        facility = Facility.objects.get(id=facility_id)
        for key, value in data.items():
            setattr(facility, key, value)
        facility.save()
        return facility
    
    @staticmethod
    def delete_facility(facility_id):
        """
        删除设施
        
        Args:
            facility_id: 设施ID
        """
        Facility.objects.filter(id=facility_id).delete()

class AdminContext(BaseContext):
    """针对 Admin 模型的基础 CRUD 和查询操作"""
    def __init__(self):
        super().__init__(Admin)

    def get_by_account(self, account: str) -> Admin | None:
        """根据账号名获取 Admin 实例"""
        try:
            return self.model.objects.get(account=account)
        except self.model.DoesNotExist:
            return None


================================================================================
文件路径: python-backend\management\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from django.apps import apps
from core.models import Admin

def get_eventarea_serializer():
    """获取活动区域序列化器"""
    Eventarea = apps.get_model('core', 'Eventarea')
    
    class EventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            exclude = ['shape']
    
    return EventareaSerializer


def get_otherarea_serializer():
    """获取其他区域序列化器"""
    Otherarea = apps.get_model('core', 'Otherarea')
    
    class OtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            exclude = ['shape']
    
    return OtherareaSerializer


def get_event_serializer():
    """获取Event模型的序列化器"""
    Event = apps.get_model('core', 'Event')
    
    class EventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = '__all__'
    
    return EventSerializer


def get_storearea_serializer():
    """获取Storearea模型的序列化器"""
    Storearea = apps.get_model('core', 'Storearea')
    
    class StoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            exclude = ['shape']
    
    return StoreareaSerializer


def get_facility_serializer():
    """获取Facility模型的序列化器"""
    Facility = apps.get_model('core', 'Facility')
    
    class FacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            exclude = ['location']
    
    return FacilitySerializer

# Input Serializers (用于接收前端数据)
class AdminRegisterSerializer(serializers.Serializer):
    """管理员注册输入"""
    account = serializers.CharField(max_length=64)
    password = serializers.CharField(max_length=128, write_only=True)
    name = serializers.CharField(max_length=64, required=False, allow_blank=True)

class AdminLoginSerializer(serializers.Serializer):
    """管理员登录输入"""
    account = serializers.CharField(max_length=64)
    password = serializers.CharField(max_length=128, write_only=True) # write_only: 密码只用于输入，不用于输出

class AdminUpdateSerializer(serializers.Serializer):
    """管理员修改信息输入 (用于 PUT / PATCH)"""
    name = serializers.CharField(max_length=64, required=False, allow_blank=True)
    # 允许修改密码，但必须使用新的字段名 new_password
    new_password = serializers.CharField(max_length=128, required=False, write_only=True)

# Output Serializer (用于返回 Admin 实例信息)
class AdminProfileSerializer(serializers.ModelSerializer):
    """管理员信息的输出格式 (不暴露密码)"""
    class Meta:
        model = Admin
        fields = ['id', 'account', 'name']
        read_only_fields = ['id', 'account'] # 账号和ID不能通过这个接口修改


================================================================================
文件路径: python-backend\management\services.py
--------------------------------------------------------------------------------

from .context import EventareaContext, OtherareaContext, EventContext, StoreareaContext, FacilityContext, AdminContext
from core.models import Admin
from django.contrib.auth.hashers import make_password, check_password
from django.core.exceptions import ValidationError


class AdminService:
    """负责管理员的注册、登录和个人信息修改的业务逻辑"""

    def __init__(self):
        self.ctx = AdminContext()

    def register_admin(self, account: str, password: str, name: str | None = None) -> Admin:
        """注册新管理员"""
        if self.ctx.get_by_account(account):
            raise ValidationError("Admin account already exists.")

        # 1. 密码哈希 (SECURITY CRITICAL)
        hashed_password = make_password(password)

        # 2. 创建实例
        admin_instance = self.ctx.create(
            account=account,
            password=hashed_password,
            name=name
        )
        return admin_instance

    def login_admin(self, account: str, password: str) -> Admin | None:
        """验证管理员登录凭证"""
        admin_instance = self.ctx.get_by_account(account)

        # 1. 检查实例是否存在
        if not admin_instance:
            return None  # 账号不存在

        # 2. 检查密码是否匹配 (使用 check_password 验证哈希值)
        if check_password(password, admin_instance.password):
            return admin_instance  # 登录成功

        return None  # 密码错误

    def update_profile(self, admin_instance: Admin, name: str | None, new_password: str | None) -> Admin:
        """更新管理员信息 (姓名和/或密码)"""
        update_data = {}

        if name is not None:
            update_data['name'] = name

        if new_password:
            # 3. 如果有新密码，哈希后再更新
            update_data['password'] = make_password(new_password)

        return self.ctx.update(admin_instance, **update_data)


class EventareaService:
    """
    活动区域（Eventarea）的业务逻辑层

    提供与Eventarea模型相关的业务逻辑处理方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_eventareas():
        """
        获取所有活动区域

        Returns:
            QuerySet: 活动区域的查询集
        """
        return EventareaContext.get_all_eventareas()

    @staticmethod
    def get_eventarea_by_id(eventarea_id):
        """
        根据ID获取活动区域

        Args:
            eventarea_id: 活动区域ID

        Returns:
            Eventarea: 活动区域对象
        """
        return EventareaContext.get_eventarea_by_id(eventarea_id)

    @staticmethod
    def create_eventarea(data):
        """
        创建新的活动区域

        Args:
            data: 活动区域数据

        Returns:
            Eventarea: 创建的活动区域对象
        """
        # 业务逻辑验证
        # 1. 验证数据完整性
        required_fields = ['is_active', 'description', 'organizer_name', 'organizer_phone', 'type']
        for field in required_fields:
            if field not in data:
                raise ValueError(f"Field '{field}' is required")

        # 2. 验证电话号码格式
        # 这里可以添加更复杂的电话号码验证逻辑
        if len(data['organizer_phone']) < 10:
            raise ValueError("Phone number must be at least 10 characters long")

        # 3. 验证类型是否合法
        valid_types = ['exhibition', 'concert', 'meeting', 'other']  # 根据实际需求调整
        if data['type'] not in valid_types:
            raise ValueError(f"Invalid type. Valid types are: {', '.join(valid_types)}")

        # 4. 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        return EventareaContext.create_eventarea(data)

    @staticmethod
    def update_eventarea(eventarea_id, data):
        """
        更新活动区域

        Args:
            eventarea_id: 活动区域ID
            data: 更新数据

        Returns:
            Eventarea: 更新后的活动区域对象
        """
        # 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        # 如果有其他业务逻辑验证，可以在这里添加

        return EventareaContext.update_eventarea(eventarea_id, data)

    @staticmethod
    def delete_eventarea(eventarea_id):
        """
        删除活动区域

        Args:
            eventarea_id: 活动区域ID
        """
        # 业务逻辑验证
        # 1. 验证活动区域是否存在
        eventarea = EventareaContext.get_eventarea_by_id(eventarea_id)

        # 2. 验证是否有相关联的活动
        if eventarea.event_set.exists():
            raise ValueError("Cannot delete eventarea with associated events")

        return EventareaContext.delete_eventarea(eventarea_id)


class OtherareaService:
    """
    其他区域（Otherarea）的业务逻辑层

    提供与Otherarea模型相关的业务逻辑处理方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_otherareas():
        """
        获取所有其他区域

        Returns:
            QuerySet: 其他区域的查询集
        """
        return OtherareaContext.get_all_otherareas()

    @staticmethod
    def get_otherarea_by_id(otherarea_id):
        """
        根据ID获取其他区域

        Args:
            otherarea_id: 其他区域ID

        Returns:
            Otherarea: 其他区域对象
        """
        return OtherareaContext.get_otherarea_by_id(otherarea_id)

    @staticmethod
    def create_otherarea(data):
        """
        创建新的其他区域

        Args:
            data: 其他区域数据

        Returns:
            Otherarea: 创建的其他区域对象
        """
        # 业务逻辑验证
        # 1. 验证数据完整性
        required_fields = ['is_active', 'description', 'type', 'is_public']
        for field in required_fields:
            if field not in data:
                raise ValueError(f"Field '{field}' is required")

        # 2. 验证类型是否合法
        valid_types = ['restroom', 'parking', 'entrance', 'exit', 'staircase', 'elevator', 'other']  # 根据实际需求调整
        if data['type'] not in valid_types:
            raise ValueError(f"Invalid type. Valid types are: {', '.join(valid_types)}")

        # 3. 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        return OtherareaContext.create_otherarea(data)

    @staticmethod
    def update_otherarea(otherarea_id, data):
        """
        更新其他区域

        Args:
            otherarea_id: 其他区域ID
            data: 更新数据

        Returns:
            Otherarea: 更新后的其他区域对象
        """
        # 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        # 如果有其他业务逻辑验证，可以在这里添加

        return OtherareaContext.update_otherarea(otherarea_id, data)

    @staticmethod
    def delete_otherarea(otherarea_id):
        """
        删除其他区域

        Args:
            otherarea_id: 其他区域ID
        """
        # 业务逻辑验证
        # 1. 验证其他区域是否存在
        otherarea = OtherareaContext.get_otherarea_by_id(otherarea_id)

        # 2. 可以添加其他验证逻辑

        return OtherareaContext.delete_otherarea(otherarea_id)


class EventService:
    """
    活动（Event）的业务逻辑层

    提供与Event模型相关的业务逻辑操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_events():
        """
        获取所有活动

        Returns:
            QuerySet: 活动的查询集
        """
        return EventContext.get_all_events()

    @staticmethod
    def get_event_by_id(event_id):
        """
        根据ID获取活动

        Args:
            event_id: 活动ID

        Returns:
            Event: 活动对象
        """
        return EventContext.get_event_by_id(event_id)

    @staticmethod
    def create_event(data):
        """
        创建新的活动

        Args:
            data: 活动数据

        Returns:
            Event: 创建的活动对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 业务逻辑验证
        # 这里可以添加更多的业务逻辑验证

        return EventContext.create_event(data)

    @staticmethod
    def update_event(event_id, data):
        """
        更新活动

        Args:
            event_id: 活动ID
            data: 更新数据

        Returns:
            Event: 更新后的活动对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 业务逻辑验证
        # 这里可以添加更多的业务逻辑验证

        return EventContext.update_event(event_id, data)

    @staticmethod
    def delete_event(event_id):
        """
        删除活动

        Args:
            event_id: 活动ID
        """
        EventContext.delete_event(event_id)


class StoreareaService:
    """
    店铺区域（Storearea）的业务逻辑层

    提供与Storearea模型相关的业务逻辑操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_storeareas():
        """
        获取所有店铺区域

        Returns:
            QuerySet: 店铺区域的查询集
        """
        return StoreareaContext.get_all_storeareas()

    @staticmethod
    def get_storearea_by_id(storearea_id):
        """
        根据ID获取店铺区域

        Args:
            storearea_id: 店铺区域ID

        Returns:
            Storearea: 店铺区域对象
        """
        return StoreareaContext.get_storearea_by_id(storearea_id)

    @staticmethod
    def create_storearea(data):
        """
        创建新的店铺区域

        Args:
            data: 店铺区域数据

        Returns:
            Storearea: 创建的店铺区域对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 业务逻辑验证
        # 这里可以添加更多的业务逻辑验证

        return StoreareaContext.create_storearea(data)

    @staticmethod
    def update_storearea(storearea_id, data):
        """
        更新店铺区域

        Args:
            storearea_id: 店铺区域ID
            data: 更新数据

        Returns:
            Storearea: 更新后的店铺区域对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 业务逻辑验证
        # 这里可以添加更多的业务逻辑验证

        return StoreareaContext.update_storearea(storearea_id, data)

    @staticmethod
    def delete_storearea(storearea_id):
        """
        删除店铺区域
        
        Args:
            storearea_id: 店铺区域ID
        """
        StoreareaContext.delete_storearea(storearea_id)


class FacilityService:
    """
    设施（Facility）的业务逻辑层
    
    提供与Facility模型相关的业务逻辑处理方法
    注意：location属性由editor模块处理
    """

    @staticmethod
    def get_all_facilities():
        """
        获取所有设施
        
        Returns:
            QuerySet: 设施的查询集
        """
        return FacilityContext.get_all_facilities()

    @staticmethod
    def get_facility_by_id(facility_id):
        """
        根据ID获取设施
        
        Args:
            facility_id: 设施ID
        
        Returns:
            Facility: 设施对象
        """
        return FacilityContext.get_facility_by_id(facility_id)

    @staticmethod
    def create_facility(data):
        """
        创建新的设施
        
        Args:
            data: 设施数据
        
        Returns:
            Facility: 创建的设施对象
        """
        # 业务逻辑验证
        # 1. 验证数据完整性
        required_fields = ['is_active', 'description', 'type']
        for field in required_fields:
            if field not in data:
                raise ValueError(f"Field '{field}' is required")

        # 2. 验证类型是否合法（根据实际需求调整）
        # 这里假设type是整数类型，表示不同的设施类型

        # 3. 如果提供了location属性，将其移除（location属性由editor模块处理）
        if 'location' in data:
            data.pop('location')

        return FacilityContext.create_facility(data)

    @staticmethod
    def update_facility(facility_id, data):
        """
        更新设施
        
        Args:
            facility_id: 设施ID
            data: 更新数据
        
        Returns:
            Facility: 更新后的设施对象
        """
        # 如果提供了location属性，将其移除（location属性由editor模块处理）
        if 'location' in data:
            data.pop('location')

        # 如果有其他业务逻辑验证，可以在这里添加

        return FacilityContext.update_facility(facility_id, data)

    @staticmethod
    def delete_facility(facility_id):
        """
        删除设施
        
        Args:
            facility_id: 设施ID
        """
        # 业务逻辑验证
        # 1. 验证设施是否存在
        facility = FacilityContext.get_facility_by_id(facility_id)

        # 2. 可以添加其他验证逻辑

        return FacilityContext.delete_facility(facility_id)


================================================================================
文件路径: python-backend\management\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.
from rest_framework.test import APITestCase
from rest_framework import status
from django.urls import reverse
from core.models import Admin
from django.contrib.auth.hashers import check_password, make_password


class AdminAuthAPITestCase(APITestCase):
    """
    测试管理员注册、登录、注销接口 (AdminAuthView)
    """

    def setUp(self):
        # 预先定义好路由名称
        self.register_url = reverse('admin-auth', kwargs={'action': 'register'})
        self.login_url = reverse('admin-auth', kwargs={'action': 'login'})
        self.logout_url = reverse('admin-auth', kwargs={'action': 'logout'})
        self.profile_url = reverse('admin-profile')  # 档案管理路由

        # 注册一个测试管理员供后续登录测试使用
        self.account = "testuser"
        self.password = "password123"
        self.admin = Admin.objects.create(
            account=self.account,
            password=make_password(self.password),  # 注意: 这里是明文，在测试中我们会手动进行哈希检查
            name="Original Name"
        )
        # # 注意: 真实的 AdminService.register_admin 会自动哈希密码，但这里我们绕过 Service 直接创建，
        # # 所以必须手动设置哈希后的密码才能通过 login 测试。
        # self.admin.password = check_password(self.password, 'fake_hash')  # 任意哈希值
        # self.admin.save()

    # ------------------ 注册 (Register) 测试 ------------------

    def test_register_success(self):
        """测试成功注册新管理员"""
        data = {"account": "newadmin", "password": "newpassword456", "name": "New Admin"}
        response = self.client.post(self.register_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Admin.objects.count(), 2)
        self.assertEqual(response.data['account'], 'newadmin')

        # 验证密码是否被哈希存储
        new_admin = Admin.objects.get(account='newadmin')
        self.assertTrue(check_password("newpassword456", new_admin.password))

    def test_register_duplicate_account(self):
        """测试注册时账号重复"""
        data = {"account": self.account, "password": "somepassword", "name": "Duplicate User"}
        response = self.client.post(self.register_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('account already exists', response.data['error'].lower())
        self.assertEqual(Admin.objects.count(), 1)  # 确认没有创建新用户

    # ------------------ 登录 (Login) 测试 ------------------

    def test_login_success(self):
        """测试成功登录"""
        data = {"account": self.account, "password": self.password}
        response = self.client.post(self.login_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['account'], self.account)
        # 验证 Session 是否被正确设置 (检查响应中的 session key)
        self.assertIn('sessionid', response.cookies)
        self.assertTrue(self.client.session.get('admin_id'))

    def test_login_failure_wrong_password(self):
        """测试密码错误导致登录失败"""
        data = {"account": self.account, "password": "wrongpassword"}
        response = self.client.post(self.login_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertIn('Invalid account or password', response.data['error'])

    def test_login_failure_non_existent_account(self):
        """测试账号不存在导致登录失败"""
        data = {"account": "nonexistent", "password": "anypassword"}
        response = self.client.post(self.login_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertIn('Invalid account or password', response.data['error'])

    # ------------------ 注销 (Logout) 测试 ------------------

    def test_logout_success(self):
        """测试成功注销"""
        # 先登录以设置 Session
        self.client.post(self.login_url, {"account": self.account, "password": self.password}, format='json')

        # 执行注销
        response = self.client.post(self.logout_url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        # 验证 Session 是否被清除
        self.assertIsNone(self.client.session.get('admin_id'))


class AdminProfileAPITestCase(APITestCase):
    """
    测试管理员档案管理接口 (AdminProfileView)
    """

    def setUp(self):
        self.login_url = reverse('admin-auth', kwargs={'action': 'login'})
        self.profile_url = reverse('admin-profile')

        self.account = "profileuser"
        self.password = "profilepass"

        # 手动创建 Admin 实例,确保密码哈希
        hashed_password = make_password(self.password)
        self.admin = Admin.objects.create(
            account=self.account,
            password=hashed_password,
            name="Profile Target"
        )

        # 登录并获取 Session Cookie
        self.client.post(self.login_url, {"account": self.account, "password": self.password}, format='json')
        # self.admin = Admin.objects.get(account=self.account)  # 获取实例

    # ------------------ 权限 (Authorization) 测试 ------------------

    def test_profile_requires_authentication(self):
        """测试未登录用户无法访问 Profile 接口"""
        self.client.logout()  # 清除 Session
        response_get = self.client.get(self.profile_url, format='json')
        response_put = self.client.put(self.profile_url, {"name": "fail"}, format='json')

        self.assertEqual(response_get.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertEqual(response_put.status_code, status.HTTP_401_UNAUTHORIZED)

    # ------------------ 获取信息 (GET) 测试 ------------------

    def test_get_profile_success(self):
        """测试成功获取个人信息"""
        response = self.client.get(self.profile_url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['account'], self.account)
        self.assertEqual(response.data['name'], "Profile Target")
        self.assertNotIn('password', response.data)  # 确保密码没有被泄露

    # ------------------ 修改信息 (PUT/PATCH) 测试 ------------------

    def test_update_name_success(self):
        """测试成功修改姓名"""
        new_name = "Updated User Name"
        response = self.client.put(self.profile_url, {"name": new_name}, format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['name'], new_name)

        # 验证数据库中的值已更新
        self.admin.refresh_from_db()
        self.assertEqual(self.admin.name, new_name)

    def test_update_password_success(self):
        """测试成功修改密码"""
        new_password = "verysecurepassword"
        response = self.client.put(self.profile_url, {"new_password": new_password}, format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['account'], self.account)

        # 验证新的密码能否用于登录
        self.admin.refresh_from_db()
        self.assertTrue(check_password(new_password, self.admin.password))

        # 验证旧密码失效
        self.assertFalse(check_password(self.password, self.admin.password))

    def test_update_both_success(self):
        """测试同时修改姓名和密码"""
        new_name = "Final Name"
        new_password = "FinalPassword"

        response = self.client.put(self.profile_url,
                                   {"name": new_name, "new_password": new_password},
                                   format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['name'], new_name)

        # 验证数据库
        self.admin.refresh_from_db()
        self.assertEqual(self.admin.name, new_name)
        self.assertTrue(check_password(new_password, self.admin.password))


================================================================================
文件路径: python-backend\management\urls.py
--------------------------------------------------------------------------------

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import EventareaViewSet, OtherareaViewSet, EventViewSet, StoreareaViewSet, FacilityViewSet

# 创建路由器并注册视图集
router = DefaultRouter()
router.register(r'eventarea', EventareaViewSet, basename='management_eventarea')
router.register(r'otherarea', OtherareaViewSet, basename='management_otherarea')
router.register(r'event', EventViewSet, basename='management_event')
router.register(r'storearea', StoreareaViewSet, basename='management_storearea')
router.register(r'facility', FacilityViewSet, basename='management_facility')

urlpatterns = [
    # 包含路由器生成的所有URL
    path('', include(router.urls)),
]



================================================================================
文件路径: python-backend\management\views.py
--------------------------------------------------------------------------------

from rest_framework import viewsets, status
from rest_framework.response import Response
from django.shortcuts import get_object_or_404
from .serializers import get_eventarea_serializer, get_otherarea_serializer, get_event_serializer, get_storearea_serializer, get_facility_serializer
from .services import EventareaService, OtherareaService, EventService, StoreareaService, FacilityService


class EventareaViewSet(viewsets.ModelViewSet):
    """
    活动区域（Eventarea）的视图集
    
    注意：
    - 在management模块中处理除shape属性外的所有其他属性
    - shape属性的操作由editor模块处理
    - 不允许修改shape属性
    
    支持的操作：
    - GET /api/management/eventarea/ - 获取所有活动区域列表
    - GET /api/management/eventarea/{id}/ - 获取指定活动区域详情
    - POST /api/management/eventarea/ - 创建新的活动区域
    - PUT /api/management/eventarea/{id}/ - 完整更新活动区域（不包括shape）
    - PATCH /api/management/eventarea/{id}/ - 部分更新活动区域（不包括shape）
    - DELETE /api/management/eventarea/{id}/ - 删除指定活动区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_eventarea_serializer()
    
    def get_queryset(self):
        """获取所有活动区域"""
        return EventareaService.get_all_eventareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动区域列表"""
        eventareas = EventareaService.get_all_eventareas()
        serializer = self.get_serializer(eventareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动区域详情"""
        eventarea = get_object_or_404(EventareaService.get_all_eventareas(), pk=pk)
        serializer = self.get_serializer(eventarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的活动区域"""
        try:
            # 检查是否包含shape属性，如果包含则移除
            data = request.data.copy()
            if 'shape' in data:
                data.pop('shape')
            
            eventarea = EventareaService.create_eventarea(data)
            serializer = self.get_serializer(eventarea)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新活动区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            eventarea = EventareaService.update_eventarea(pk, request.data)
            serializer = self.get_serializer(eventarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新活动区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            eventarea = EventareaService.update_eventarea(pk, request.data)
            serializer = self.get_serializer(eventarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """删除指定活动区域"""
        try:
            EventareaService.delete_eventarea(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class OtherareaViewSet(viewsets.ModelViewSet):
    """
    其他区域（Otherarea）的视图集
    
    注意：
    - 在management模块中处理除shape属性外的所有其他属性
    - shape属性的操作由editor模块处理
    - 不允许修改shape属性
    
    支持的操作：
    - GET /api/management/otherarea/ - 获取所有其他区域列表
    - GET /api/management/otherarea/{id}/ - 获取指定其他区域详情
    - POST /api/management/otherarea/ - 创建新的其他区域
    - PUT /api/management/otherarea/{id}/ - 完整更新其他区域（不包括shape）
    - PATCH /api/management/otherarea/{id}/ - 部分更新其他区域（不包括shape）
    - DELETE /api/management/otherarea/{id}/ - 删除指定其他区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_otherarea_serializer()
    
    def get_queryset(self):
        """获取所有其他区域"""
        return OtherareaService.get_all_otherareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有其他区域列表"""
        otherareas = OtherareaService.get_all_otherareas()
        serializer = self.get_serializer(otherareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定其他区域详情"""
        otherarea = get_object_or_404(OtherareaService.get_all_otherareas(), pk=pk)
        serializer = self.get_serializer(otherarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的其他区域"""
        try:
            # 检查是否包含shape属性，如果包含则移除
            data = request.data.copy()
            if 'shape' in data:
                data.pop('shape')
            
            otherarea = OtherareaService.create_otherarea(data)
            serializer = self.get_serializer(otherarea)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新其他区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            otherarea = OtherareaService.update_otherarea(pk, request.data)
            serializer = self.get_serializer(otherarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新其他区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            otherarea = OtherareaService.update_otherarea(pk, request.data)
            serializer = self.get_serializer(otherarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """删除指定其他区域"""
        try:
            OtherareaService.delete_otherarea(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class EventViewSet(viewsets.ModelViewSet):
    """
    活动（Event）的视图集
    
    支持的操作：
    - GET /api/management/event/ - 获取所有活动列表
    - GET /api/management/event/{id}/ - 获取指定活动详情
    - POST /api/management/event/ - 创建新的活动
    - PUT /api/management/event/{id}/ - 完整更新活动
    - PATCH /api/management/event/{id}/ - 部分更新活动
    - DELETE /api/management/event/{id}/ - 删除指定活动
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_event_serializer()
    
    def get_queryset(self):
        """获取所有活动"""
        return EventService.get_all_events()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动列表"""
        events = EventService.get_all_events()
        serializer = self.get_serializer(events, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动详情"""
        event = get_object_or_404(EventService.get_all_events(), pk=pk)
        serializer = self.get_serializer(event)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的活动"""
        try:
            event = EventService.create_event(request.data)
            serializer = self.get_serializer(event)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新活动"""
        try:
            event = EventService.update_event(pk, request.data)
            serializer = self.get_serializer(event)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新活动"""
        try:
            event = EventService.update_event(pk, request.data)
            serializer = self.get_serializer(event)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """删除指定活动"""
        try:
            EventService.delete_event(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class StoreareaViewSet(viewsets.ModelViewSet):
    """
    店铺区域（Storearea）的视图集
    
    注意：
    - 不处理shape属性，该属性由editor模块处理
    
    支持的操作：
    - GET /api/management/storearea/ - 获取所有店铺区域列表
    - GET /api/management/storearea/{id}/ - 获取指定店铺区域详情
    - POST /api/management/storearea/ - 创建新的店铺区域
    - PUT /api/management/storearea/{id}/ - 完整更新店铺区域（不包括shape）
    - PATCH /api/management/storearea/{id}/ - 部分更新店铺区域（不包括shape）
    - DELETE /api/management/storearea/{id}/ - 删除指定店铺区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_storearea_serializer()
    
    def get_queryset(self):
        """获取所有店铺区域"""
        return StoreareaService.get_all_storeareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有店铺区域列表"""
        storeareas = StoreareaService.get_all_storeareas()
        serializer = self.get_serializer(storeareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定店铺区域详情"""
        storearea = get_object_or_404(StoreareaService.get_all_storeareas(), pk=pk)
        serializer = self.get_serializer(storearea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的店铺区域"""
        try:
            # 检查是否包含shape属性，如果包含则移除
            data = request.data.copy()
            if 'shape' in data:
                data.pop('shape')
            
            storearea = StoreareaService.create_storearea(data)
            serializer = self.get_serializer(storearea)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新店铺区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            storearea = StoreareaService.update_storearea(pk, request.data)
            serializer = self.get_serializer(storearea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新店铺区域（不包括shape）"""
        try:
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in request.data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            storearea = StoreareaService.update_storearea(pk, request.data)
            serializer = self.get_serializer(storearea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """
        删除指定店铺区域
        """
        try:
            StoreareaService.delete_storearea(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class FacilityViewSet(viewsets.ModelViewSet):
    """
    设施（Facility）的视图集
    
    注意：
    - 在management模块中处理除location属性外的所有其他属性
    - location属性的操作由editor模块处理
    - 不允许修改location属性
    
    支持的操作：
    - GET /api/management/facility/ - 获取所有设施列表
    - GET /api/management/facility/{id}/ - 获取指定设施详情
    - POST /api/management/facility/ - 创建新的设施
    - PUT /api/management/facility/{id}/ - 完整更新设施（不包括location）
    - PATCH /api/management/facility/{id}/ - 部分更新设施（不包括location）
    - DELETE /api/management/facility/{id}/ - 删除指定设施
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_facility_serializer()
    
    def get_queryset(self):
        """获取所有设施"""
        return FacilityService.get_all_facilities()
    
    def list(self, request, *args, **kwargs):
        """获取所有设施列表"""
        facilities = FacilityService.get_all_facilities()
        serializer = self.get_serializer(facilities, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定设施详情"""
        facility = get_object_or_404(FacilityService.get_all_facilities(), pk=pk)
        serializer = self.get_serializer(facility)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的设施"""
        try:
            # 检查是否包含location属性，如果包含则移除
            data = request.data.copy()
            if 'location' in data:
                data.pop('location')
            
            facility = FacilityService.create_facility(data)
            serializer = self.get_serializer(facility)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新设施（不包括location）"""
        try:
            # 检查是否包含location属性，如果包含则返回错误
            if 'location' in request.data:
                return Response(
                    {'error': 'Location attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            facility = FacilityService.update_facility(pk, request.data)
            serializer = self.get_serializer(facility)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新设施（不包括location）"""
        try:
            # 检查是否包含location属性，如果包含则返回错误
            if 'location' in request.data:
                return Response(
                    {'error': 'Location attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            facility = FacilityService.update_facility(pk, request.data)
            serializer = self.get_serializer(facility)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """删除指定设施"""
        try:
            FacilityService.delete_facility(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.core.exceptions import ValidationError
from django.http import HttpRequest

from .services import AdminService
from .serializers import AdminRegisterSerializer, AdminLoginSerializer, AdminUpdateSerializer, AdminProfileSerializer
from core.models import Admin
from core.context import BaseContext


class AdminAuthMixin:
    """一个简单的用于检查管理员登录状态并加载 Admin 实例的 Mixin"""
    @staticmethod
    def get_admin_user(request: HttpRequest) -> Admin | None:
        admin_id = request.session.get('admin_id')
        if admin_id:
            try:
                # 使用 BaseContext 或 AdminContext 获取实例
                return BaseContext(Admin).get_by_id(admin_id)
            except Admin.DoesNotExist:
                del request.session['admin_id']  # 清理过期会话
                return None
        return None


class AdminAuthView(APIView):
    """
    处理管理员的注册、登录、注销
    POST /api/management/auth/register/
    POST /api/management/auth/login/
    POST /api/management/auth/logout/
    """
    service_class = AdminService

    def post(self, request, action):
        service = self.service_class()

        if action == 'register':
            serializer = AdminRegisterSerializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            try:
                admin = service.register_admin(**serializer.validated_data)
                return Response(AdminProfileSerializer(admin).data, status=status.HTTP_201_CREATED)
            except ValidationError as e:
                return Response({"error": e.message}, status=status.HTTP_400_BAD_REQUEST)

        elif action == 'login':
            serializer = AdminLoginSerializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            admin = service.login_admin(**serializer.validated_data)

            if admin:
                # 登录成功：在 session 中设置 ID
                request.session['admin_id'] = admin.id
                return Response(AdminProfileSerializer(admin).data, status=status.HTTP_200_OK)
            else:
                return Response({"error": "Invalid account or password"}, status=status.HTTP_401_UNAUTHORIZED)

        elif action == 'logout':
            if 'admin_id' in request.session:
                del request.session['admin_id']  # 清除 session
            return Response({"message": "Logout successful"}, status=status.HTTP_200_OK)

        else:
            return Response({"error": "Invalid action"}, status=status.HTTP_400_BAD_REQUEST)


# --- 个人信息接口 ---
class AdminProfileView(AdminAuthMixin, APIView):
    """
    处理管理员个人信息的获取和修改
    GET /api/management/profile/
    PUT/PATCH /api/management/profile/
    """
    service_class = AdminService
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.admin_user = None # 初始化实例属性
        
    def dispatch(self, request, *args, **kwargs):
        # 在处理请求前，先检查登录状态并加载 Admin 实例
        self.admin_user = self.get_admin_user(request)
        if not self.admin_user:
            return Response({"error": "Authentication credentials were not provided."},
                            status=status.HTTP_401_UNAUTHORIZED)
        return super().dispatch(request, *args, **kwargs)

    def get(self, request):
        """获取当前登录管理员的个人信息"""
        # self.admin_user 已在 dispatch 中加载并验证
        return Response(AdminProfileSerializer(self.admin_user).data)

    def put(self, request):
        """修改当前登录管理员的个人信息 (PUT/PATCH 通用)"""
        serializer = AdminUpdateSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        service = self.service_class()

        updated_admin = service.update_profile(
            admin_instance=self.admin_user,
            name=serializer.validated_data.get('name'),
            new_password=serializer.validated_data.get('new_password')
        )

        return Response(AdminProfileSerializer(updated_admin).data, status=status.HTTP_200_OK)


================================================================================
文件路径: python-backend\management\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\management\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\map\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\map\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig



class MapConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'map'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\map\context.py
--------------------------------------------------------------------------------

from core.models import Map, Storearea, Facility, Otherarea, Eventarea
from django.db.models import Q
from core.context import BaseContext


class MapContext(BaseContext):
    def __init__(self):
        super().__init__(Map)

    def get_map_with_building(self, map_id):
        """获取地图并预加载建筑信息"""
        try:
            return self.model.objects.select_related('building').get(pk=map_id)
        except self.model.DoesNotExist:
            return None

    @staticmethod
    def get_map_elements(map_obj):
        """一次性获取地图关联的所有元素 ID"""
        # 注意：这里只负责取数据，不负责格式化
        store_ids = map_obj.storeareamap_set.values_list('storearea_id', flat=True)
        facility_ids = map_obj.facilitymap_set.values_list('facility_id', flat=True)
        other_ids = map_obj.otherareamap_set.values_list('otherarea_id', flat=True)
        event_ids = map_obj.eventareamap_set.values_list('eventarea_id', flat=True)
        return store_ids, facility_ids, other_ids, event_ids

    def list_all_with_building(self):
        """获取所有地图列表，并预加载建筑信息"""
        return self.model.objects.select_related('building').all()

    def check_exists(self, building_id, floor_number):
        """检查特定楼层是否存在"""
        return self.model.objects.filter(building_id=building_id, floor_number=floor_number).exists()

    def create_map_record(self, building_id, floor_number, geometry):
        """创建地图记录"""
        return self.create(
            building_id=building_id,
            floor_number=floor_number,
            detail=geometry
        )

class ElementContext:
    """负责处理具体的商铺、设施等元素"""

    @staticmethod
    def get_stores_by_ids(ids):
        return Storearea.objects.filter(id__in=ids)

    @staticmethod
    def get_facilities_by_ids(ids):
        return Facility.objects.filter(id__in=ids)

    @staticmethod
    def get_others_by_ids(ids):
        return Otherarea.objects.filter(id__in=ids)

    @staticmethod
    def get_events_by_ids(ids):
        return Eventarea.objects.filter(id__in=ids)

    @staticmethod
    def search_globally(keyword):
        stores = Storearea.objects.filter(store_name__icontains=keyword)
        others = Otherarea.objects.filter(description__icontains=keyword, is_public=True)
        return stores, others


================================================================================
文件路径: python-backend\map\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from core.models import Map, Storearea, Facility, Otherarea, Eventarea
import json


# ==========================================
# 1. 子元素序列化器 (先定义，供 MapSerializer 调用)
# ==========================================

class OtherareaSerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Otherarea
        # 将 is_public 暴露出来，前端可以用不同颜色渲染
        fields = ['id', 'type', 'description', 'is_public',  'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.shape: return None
        return json.loads(obj.shape.geojson)


class StoreareaSerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Storearea
        fields = ['id', 'store_name', 'type', 'logo_url', 'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.shape: return None
        return json.loads(obj.shape.geojson)


class FacilitySerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Facility
        fields = ['id', 'type', 'description', 'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.location: return None
        return json.loads(obj.location.geojson)


class EventareaSerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Eventarea
        fields = ['id', 'description',  'type', 'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.shape: return None
        return json.loads(obj.shape.geojson)


# ==========================================
# 2. 地图聚合序列化器 (核心修改部分)
# ==========================================

class MapSerializer(serializers.ModelSerializer):
    """
    地图详情：包含该楼层的底图几何信息，以及关联的商铺、设施等。
    """
    building_name = serializers.CharField(source='building.name', read_only=True)
    detail_geojson = serializers.SerializerMethodField()

    # --- 关键修改开始 ---
    # 使用 source='temp_xxx' 对应 MapDisplayService 中挂载的属性名
    # read_only=True 表示这些字段只用于输出，不用于写入
    stores = StoreareaSerializer(source='temp_stores', many=True, read_only=True)
    facilities = FacilitySerializer(source='temp_facilities', many=True, read_only=True)
    other_areas = OtherareaSerializer(source='temp_others', many=True, read_only=True)
    events = EventareaSerializer(source='temp_events', many=True, read_only=True)

    # --- 关键修改结束 ---

    class Meta:
        model = Map
        fields = [
            'id',
            'building_id',
            'building_name',
            'floor_number',
            'detail_geojson',
            # 必须把新字段加入 fields 列表
            'stores',
            'facilities',
            'other_areas',
            'events'
        ]

    @staticmethod
    def get_detail_geojson(obj):
        """
        处理底图几何 (外轮廓 + 镂空)
        """
        if not obj.detail:
            return None

        # 保持原始坐标系 (SRID 2385)，方便前端计算米制距离
        # 如果需要经纬度，需在此处 clone().transform(4326)
        geometry = obj.detail.clone()
        return json.loads(geometry.geojson)


================================================================================
文件路径: python-backend\map\services.py
--------------------------------------------------------------------------------

from django.contrib.gis.geos import GEOSGeometry, Polygon
from typing import Tuple, List
from map.context import MapContext, ElementContext
import json
from django.contrib.gis.geos import GEOSGeometry


# ==========================================
# Part 1: 纯几何算法 (保持不变)
# ==========================================
class GeometryAlgorithms:
    @staticmethod
    def validate_shape_syntax(geometry: GEOSGeometry) -> Tuple[bool, str]:
        if geometry is None: return False, "Geometry is None"
        if not geometry.valid: return False, f"Invalid Geometry: {geometry.valid_reason}"
        if isinstance(geometry, Polygon) and geometry.empty: return False, "Polygon is empty"
        return True, "Valid"

    @staticmethod
    def get_distance_between_areas(shape1: GEOSGeometry, shape2: GEOSGeometry) -> float:
        """
        接口 3: 获取输入的两个区域之间的距离
        """
        if not shape1 or not shape2:
            return -1.0
        # distance() 计算的是两个几何体之间最近点的欧几里得距离
        # 单位取决于 SRID (2385 为米)
        return shape1.distance(shape2)

    @staticmethod
    def validate_holes_inside_shell(outer_shell: GEOSGeometry, holes: List[GEOSGeometry]) -> Tuple[bool, str]:
        """
        接口 2: 镂空本身有无超出外轮廓区域
        """
        if not outer_shell:
            return False, "Outer shell is missing"

        if not holes:
            return True, "No holes to validate"

        for i, hole in enumerate(holes, start=1):
            # hole 必须完全在 outer_shell 内部 (contains)
            # 任何一部分超出或仅仅是相交都算非法
            if not outer_shell.contains(hole):
                return False, f"Hole #{i} is outside or intersecting the map boundary."

        return True, "All holes are valid"

    @staticmethod
    def check_placement(new_shape, outer_shell, holes, existing_obstacles):
        if not outer_shell: return False, "Map shell missing"
        if not outer_shell.contains(new_shape): return False, "Area exceeds map outer boundary"
        for i, hole in enumerate(holes):
            if hole.intersects(new_shape): return False, f"Area intersects with map hole #{i + 1}"
        for existing_shape in existing_obstacles:
            if existing_shape and existing_shape.intersects(new_shape):
                return False, "Area overlaps with an existing area"
        return True, "Placement valid"


# ==========================================
# Part 2: 业务服务 (修改部分)
# ==========================================

class MapDisplayService:
    """
    地图显示与校验服务
    """

    def __init__(self):
        self.map_ctx = MapContext()
        self.elem_ctx = ElementContext()

    def get_full_map_details(self, map_id):
        map_obj = self.map_ctx.get_map_with_building(map_id)
        if not map_obj: return None

        s_ids, f_ids, o_ids, e_ids = self.map_ctx.get_map_elements(map_obj)

        map_obj.temp_stores = self.elem_ctx.get_stores_by_ids(s_ids)
        map_obj.temp_facilities = self.elem_ctx.get_facilities_by_ids(f_ids)
        map_obj.temp_others = self.elem_ctx.get_others_by_ids(o_ids)
        map_obj.temp_events = self.elem_ctx.get_events_by_ids(e_ids)

        return map_obj

    def validate_geometry(self, geometry, map_id, exclude_id=None, area_type=None):
        """
        几何校验业务流程
        """
        # 1. 几何语法校验
        is_valid, msg = GeometryAlgorithms.validate_shape_syntax(geometry)
        if not is_valid:
            return False, msg

        # 2. 获取地图数据
        map_obj = self.map_ctx.get_map_with_building(map_id)
        if not map_obj or not map_obj.detail:
            return False, "Map data not found or empty"

        # 解析外轮廓和镂空
        outer_shell = map_obj.detail[0]
        holes = list(map_obj.detail[1:]) if len(map_obj.detail) > 1 else []

        # 3. 获取所有障碍物 (修改点：在 Service 层组装数据)
        obstacles = self._collect_obstacles(map_obj, exclude_id, area_type)

        # 4. 调用算法进行物理放置校验
        return GeometryAlgorithms.check_placement(
            new_shape=geometry,
            outer_shell=outer_shell,
            holes=holes,
            existing_obstacles=obstacles
        )

    def _collect_obstacles(self, map_obj, exclude_id, area_type) -> List[GEOSGeometry]:
        """
        私有辅助方法：利用 MapContext 和 ElementContext 收集该地图上所有实体的形状
        """
        obstacles = []

        # 1. 从 MapContext 获取所有关联 ID
        s_ids, f_ids, o_ids, e_ids = self.map_ctx.get_map_elements(map_obj)

        # 辅助函数：处理排除逻辑
        def should_include(item_id, item_type):
            # 如果类型相同且 ID 相同，则排除（说明是正在编辑的那个对象）
            if area_type == item_type and str(item_id) == str(exclude_id):
                return False
            return True

        # 2. 从 ElementContext 获取对象并提取形状

        # A. 商铺 (Stores)
        stores = self.elem_ctx.get_stores_by_ids(s_ids)
        for s in stores:
            if should_include(s.id, 'store') and s.shape:
                obstacles.append(s.shape)

        # B. 设施 (Facilities) - 需要 Buffer 处理
        facilities = self.elem_ctx.get_facilities_by_ids(f_ids)
        for f in facilities:
            if should_include(f.id, 'facility') and f.location:
                # 设施通常是点，必须膨胀成多边形才能进行碰撞检测
                # 假设半径 0.5 米
                obstacles.append(f.location.buffer(0.5))

        # C. 其他区域 (Otherareas)
        others = self.elem_ctx.get_others_by_ids(o_ids)
        for o in others:
            if should_include(o.id, 'other') and o.shape:
                obstacles.append(o.shape)

        # D. 活动区域 (Events)
        events = self.elem_ctx.get_events_by_ids(e_ids)
        for e in events:
            if should_include(e.id, 'event') and e.shape and e.is_active:
                obstacles.append(e.shape)

        return obstacles

    def get_map_list(self):
        """
        获取地图列表概要
        """
        # 1. 从 Context 获取所有地图
        maps = self.map_ctx.list_all_with_building()

        # 2. 初始化空属性，防止 MapSerializer 报错
        # (因为列表页通常不需要加载 heavy 的商铺/设施数据，只看底图或基础信息)
        for map_obj in maps:
            map_obj.temp_stores = []
            map_obj.temp_facilities = []
            map_obj.temp_others = []
            map_obj.temp_events = []

        return maps

    def validate_batch(self, map_id, updates_list):
        """
        批量校验
        :param map_id: 地图ID
        :param updates_list: 预处理过的列表，每项包含 'geos_obj' (GEOSGeometry)
        :return: (is_valid, errors_list)
        """
        # 1. 获取地图底图 (外框和镂空)
        map_obj = self.map_ctx.get_map_with_building(map_id)
        if not map_obj or not map_obj.detail:
            return False, ["地图数据缺失"]

        outer_shell = map_obj.detail[0]
        holes = list(map_obj.detail[1:]) if len(map_obj.detail) > 1 else []

        # 2. 整理新数据 (不再需要解析 JSON，直接取对象)
        new_geometries = []
        updated_keys = set()

        for item in updates_list:
            # 直接获取 View 层解析好的几何对象
            shape = item['geos_obj']

            # 统一为多边形用于碰撞检测 (点 -> 圆)
            collision_shape = shape.buffer(0.3) if shape.geom_type == 'Point' else shape

            item_type = str(item.get('type')).lower()
            item_id = str(item.get('id'))

            new_geometries.append({
                'id': item_id,
                'type': item_type,
                'shape': collision_shape,
                'name': item.get('name', 'Unknown')
            })

            key = f"{item_type}-{item_id}"
            updated_keys.add(key)

        # 3. 从数据库获取“背景障碍物” (排除掉在 updated_keys 里的项)
        s_ids, f_ids, o_ids, e_ids = self.map_ctx.get_map_elements(map_obj)
        static_obstacles = []

        def add_static(objects, type_name):
            for obj in objects:
                key = f"{type_name}-{str(obj.id)}"
                if key not in updated_keys:
                    shape = getattr(obj, 'shape', None)
                    if type_name == 'facility':
                        loc = getattr(obj, 'location', None)
                        if loc: shape = loc.buffer(0.3)

                    if shape:
                        static_obstacles.append(shape)

        add_static(self.elem_ctx.get_stores_by_ids(s_ids), 'store')
        add_static(self.elem_ctx.get_facilities_by_ids(f_ids), 'facility')
        add_static(self.elem_ctx.get_others_by_ids(o_ids), 'other')
        active_events = [e for e in self.elem_ctx.get_events_by_ids(e_ids) if e.is_active]
        add_static(active_events, 'event')

        # 4. 执行校验
        errors = []

        for curr in new_geometries:
            curr_shape = curr['shape']

            # 4.1 边界检查
            if not outer_shell.contains(curr_shape):
                errors.append(f"[{curr['name']}] 超出地图边界")
                continue

            for hole in holes:
                if hole.intersects(curr_shape) and not hole.touches(curr_shape):
                    errors.append(f"[{curr['name']}] 进入了地图镂空/中庭区域")
                    break

            # 4.2 静态障碍物碰撞
            for obs in static_obstacles:
                if obs.intersects(curr_shape) and not obs.touches(curr_shape):
                    errors.append(f"[{curr['name']}] 与未修改的固定区域重叠")
                    break

            # 4.3 动态物体互撞 (A 撞 B)
            for other in new_geometries:
                if curr['id'] == other['id'] and curr['type'] == other['type']:
                    continue

                if curr['type'] == 'facility' and other['type'] == 'facility':
                    continue

                if other['shape'].intersects(curr_shape) and not other['shape'].touches(curr_shape):
                    if curr['id'] < other['id']:
                        errors.append(f"[{curr['name']}] 与 [{other['name']}] 重叠")
                    break

        if len(errors) > 0:
            return False, errors

        return True, []


================================================================================
文件路径: python-backend\map\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.
from rest_framework.test import APITestCase
from rest_framework import status
from django.urls import reverse
from django.contrib.gis.geos import Polygon, GeometryCollection
from core.models import Building, Map, Storearea, StoreareaMap


class MapViewSetTestCase(APITestCase):
    """
    测试 MapViewSet 的 list 和 retrieve 接口
    验证从数据库到 Service 再到 View 的数据流是否正常
    """

    def setUp(self):
        """
        测试数据准备：
        1. 创建 Building
        2. 创建 Map (带 GeometryCollection)
        3. 创建 Storearea (带 Polygon)
        4. 建立 Map 和 Storearea 的关联
        """
        # 1. 创建建筑
        self.building = Building.objects.create(
            name="测试万达广场",
            address="上海市杨浦区"
        )

        # 2. 创建地图底图几何 (SRID 2385)
        # 假设是一个 100x100 的正方形外轮廓
        outer_shell = Polygon(((0, 0), (0, 100), (100, 100), (100, 0), (0, 0)), srid=2385)
        # detail 字段是 GeometryCollection
        map_detail = GeometryCollection(outer_shell, srid=2385)

        self.map_obj = Map.objects.create(
            building=self.building,
            floor_number=1,
            detail=map_detail
        )

        # 3. 创建商铺
        # 在地图内部创建一个 10x10 的小方块商铺
        store_shape = Polygon(((10, 10), (10, 20), (20, 20), (20, 10), (10, 10)), srid=2385)
        self.store = Storearea.objects.create(
            store_name="测试海底捞",
            type=1,
            shape=store_shape,
            owner_name="张三",
            owner_phone="123456",
            is_active = True
        )

        # 4. 关联商铺到地图 (重要：否则 retrieve 接口不会返回该商铺)
        StoreareaMap.objects.create(
            map=self.map_obj,
            storearea=self.store
        )

        # 路由名称定义 (对应 urls.py 中的 router.register(..., basename='maps'))
        self.list_url = reverse('map-list')
        self.detail_url = reverse('map-detail', args=[self.map_obj.id])

    def test_list_maps(self):
        """
        测试获取地图列表 (GET /api/maps/)
        """
        response = self.client.get(self.list_url)

        # 1. 验证状态码
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        # 2. 验证返回数据类型是列表
        self.assertIsInstance(response.data, list)
        self.assertEqual(len(response.data), 1)

        # 3. 验证基础字段
        map_data = response.data[0]
        self.assertEqual(map_data['floor_number'], 1)
        self.assertEqual(map_data['building_name'], "测试万达广场")

        # 4. 验证列表接口是否正确处理了 temp_stores (应该为空列表或不报错)
        # 根据我们之前的 Service 逻辑，列表接口为了性能可能没有加载 stores，或者加载了空列表
        if 'stores' in map_data:
            self.assertIsInstance(map_data['stores'], list)

    def test_retrieve_map_success(self):
        """
        测试获取单张地图详情 (GET /api/maps/{id}/)
        核心：验证 Service 是否成功组装了 detail_geojson 和 stores
        """
        response = self.client.get(self.detail_url)

        # 1. 验证状态码
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        data = response.data

        # 2. 验证底图几何 (detail_geojson)
        self.assertIn('detail_geojson', data)
        self.assertEqual(data['detail_geojson']['type'], 'GeometryCollection')

        # 3. 验证关联元素 (stores)
        # 这是验证 MapDisplayService.get_full_map_details 逻辑的关键
        self.assertIn('stores', data)
        self.assertEqual(len(data['stores']), 1)

        store_data = data['stores'][0]
        self.assertEqual(store_data['store_name'], "测试海底捞")
        self.assertEqual(store_data['id'], self.store.id)

        # 验证商铺的几何是否被正确序列化为 GeoJSON
        self.assertIn('geometry', store_data)
        self.assertEqual(store_data['geometry']['type'], 'Polygon')

        # 4. 验证其他空列表字段是否存在 (facilities, events, etc.)
        self.assertIn('facilities', data)
        self.assertEqual(data['facilities'], [])  # setUp中没创建设施，应为空列表

    def test_retrieve_map_not_found(self):
        """
        测试获取不存在的地图 ID
        """
        non_existent_url = reverse('map-detail', args=[99999])
        response = self.client.get(non_existent_url)

        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)


================================================================================
文件路径: python-backend\map\views.py
--------------------------------------------------------------------------------

from rest_framework import viewsets, status
from rest_framework.views import APIView
from rest_framework.response import Response
from django.contrib.gis.geos import GEOSGeometry
import json

from .serializers import MapSerializer  # 序列化器依然需要，用于格式化输出
from map.services import MapDisplayService


class MapViewSet(viewsets.ViewSet):
    """
    只读 ViewSet，不继承 ModelViewSet
    """
    service_class = MapDisplayService

    def list(self, request):
        """GET /api/maps/"""
        service = self.service_class()

        # 1. 调用 Service 获取列表
        maps = service.get_map_list()

        # 2. 序列化返回
        # 注意：这里会返回所有地图的 GeoJSON，数据量可能较大
        # 实际生产中建议单独定义一个 SimpleMapSerializer (不含 detail_geojson) 用于列表
        serializer = MapSerializer(maps, many=True)

        return Response(serializer.data)

    def retrieve(self, request, pk=None):
        """GET /api/maps/{id}/"""
        service = self.service_class()

        # 1. 调用 Service 获取组装好的对象
        map_data = service.get_full_map_details(pk)

        if not map_data:
            return Response({"error": "Map not found"}, status=status.HTTP_404_NOT_FOUND)

        # 2. 使用 Serializer 格式化 Service 返回的数据
        # 注意：Serializer 内部字段 source='temp_stores' 需要对应 Service 挂载的属性
        serializer = MapSerializer(map_data)
        return Response(serializer.data)


class MapValidationView(APIView):
    """POST /api/maps/validate/"""
    service_class = MapDisplayService

    def post(self, request):
        service = self.service_class()

        # 1. 参数提取
        geometry_data = request.data.get('geometry')
        map_id = request.data.get('map_id')
        area_type = request.data.get('type')
        exclude_id = request.data.get('exclude_id')

        # 2. 数据预处理
        try:
            shape_str = json.dumps(geometry_data) if isinstance(geometry_data, dict) else geometry_data
            shape = GEOSGeometry(shape_str)
            if shape.srid != 2385: shape.srid = 2385
        except Exception:
            return Response({"error": "Invalid Geometry"}, status=400)

        # 3. 调用 Service 业务逻辑
        is_valid, reason = service.validate_geometry(shape, map_id, exclude_id, area_type)

        return Response({"valid": is_valid, "reason": reason})


class MapBatchValidationView(APIView):
    """POST /api/maps/validate_batch/ (批量校验)"""
    service_class = MapDisplayService

    def post(self, request):
        service = self.service_class()

        map_id = request.data.get('map_id')
        updates = request.data.get('updates', [])

        if not map_id:
            return Response({"error": "map_id is required"}, status=status.HTTP_400_BAD_REQUEST)

        # --- 数据预处理：在 View 层统一解析几何并修正 SRID ---
        processed_updates = []
        for i, item in enumerate(updates):
            try:
                # 1. 提取原始数据
                raw_geo = item.get('geometry') or item.get('location')
                if not raw_geo: continue

                # 2. 转字符串
                shape_str = json.dumps(raw_geo) if isinstance(raw_geo, dict) else raw_geo

                # 3. 解析几何
                shape = GEOSGeometry(shape_str)

                # 4. 强制修正 SRID (与 MapValidationView 保持一致)
                if shape.srid != 2385:
                    shape.srid = 2385

                # 5. 将处理好的 GEOSGeometry 对象注入 item
                # 使用一个新的 key 'geos_obj' 传递给 Service
                item['geos_obj'] = shape
                processed_updates.append(item)

            except Exception as e:
                # 如果解析失败，直接返回 400，中断处理
                return Response(
                    {"error": f"Invalid geometry at index {i} (ID: {item.get('id')}): {str(e)}"},
                    status=status.HTTP_400_BAD_REQUEST
                )

        # 调用 Service，传入包含 GEOSGeometry 对象的列表
        is_valid, errors = service.validate_batch(map_id, processed_updates)

        return Response({
            "valid": is_valid,
            "errors": errors
        })


================================================================================
文件路径: python-backend\map\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\map\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\python_backend\settings.py
--------------------------------------------------------------------------------

"""
Django settings for python_backend project.

Based on by 'django-admin startproject' using Django 2.1.2.

For more information on this file, see
https://docs.djangoproject.com/en/2.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/2.1/ref/settings/
"""

import os
import posixpath

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/2.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = '7306ec88-3719-40e9-88d4-2d6fdee59734'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ['*']

# Application references
# https://docs.djangoproject.com/en/2.1/ref/settings/#std:setting-INSTALLED_APPS
INSTALLED_APPS = [
    # Add your apps here to enable them
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.gis',
    'rest_framework',
    'django_filters',
    # 支持跨域请求
    'corsheaders',
    'core.apps.CoreConfig',
    'map.apps.MapConfig',
    'client.apps.ClientConfig',
    'management.apps.ManagementConfig',
    'search.apps.SearchConfig',
    'guide.apps.GuideConfig',
    'editor.apps.EditorConfig'
]

# Middleware framework
# https://docs.djangoproject.com/en/2.1/topics/http/middleware/
MIDDLEWARE = [
    # CORS middleware should be placed as high as possible
    'corsheaders.middleware.CorsMiddleware',
    # 注意：确保 CommonMiddleware 仍然在 CorsMiddleware 之后
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'python_backend.urls'

# Template configuration
# https://docs.djangoproject.com/en/2.1/topics/templates/
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'python_backend.wsgi.application'

# Database
# https://docs.djangoproject.com/en/2.1/ref/settings/#databases
DATABASES = {
    'default': {
        'ENGINE': 'django.contrib.gis.db.backends.postgis',
        'NAME': os.environ.get('POSTGRES_DB'),
        'USER': os.environ.get('POSTGRES_USER'),
        'PASSWORD': os.environ.get('POSTGRES_PASSWORD'),
        'HOST': 'postgres-db',
        'PORT': '5432',
    }
}

# Password validation
# https://docs.djangoproject.com/en/2.1/ref/settings/#auth-password-validators
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Internationalization
# https://docs.djangoproject.com/en/2.1/topics/i18n/
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_L10N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/2.1/howto/static-files/
STATIC_URL = '/static/'
STATIC_ROOT = posixpath.join(*(BASE_DIR.split(os.path.sep) + ['static']))

REST_FRAMEWORK = {
    # 默认权限设置：这里设置为默认需要登录才能访问，方便后续开发
    'DEFAULT_PERMISSION_CLASSES': [
        # 'rest_framework.permissions.IsAuthenticated',
        # 如果是开发初期想全部公开，可以改为:
        'rest_framework.permissions.AllowAny',
    ],

    # 默认认证方式
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
    ],

    # 默认分页设置 (推荐配置，防止大数据量查死数据库)
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,

    # 统一日期格式 (可选)
    'DATETIME_FORMAT': '%Y-%m-%d %H:%M:%S',
}

# CORS 设置（开发环境方便测试，生产请按需限制）
CORS_ALLOWED_ORIGINS = [
  "http://localhost:8080"
]
CORS_ALLOW_CREDENTIALS = True
# 可根据需要自定义允许的头、方法
# CORS_ALLOW_HEADERS = list(default_headers) + [
#     'your-custom-header',
# ]



================================================================================
文件路径: python-backend\python_backend\urls.py
--------------------------------------------------------------------------------

"""
python_backend URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/2.1/topics/http/urls/

Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""

# Uncomment next two lines to enable admin:
from django.contrib import admin
from django.urls import path,include
from rest_framework.routers import DefaultRouter
from map.views import MapViewSet, MapValidationView, MapBatchValidationView

from guide.views import RoutePlanView

from management.views import AdminAuthView, AdminProfileView


router = DefaultRouter()
router.register(r'maps', MapViewSet, basename='map')
urlpatterns = [
    path('search/', include('search.urls')),
    path('api/editor/', include('editor.urls')),
    path('api/management/', include('management.urls')),
    # Uncomment the next line to enable the admin:
    #path('admin/', admin.site.urls)
    path('api/maps/validate/', MapValidationView.as_view(), name='map-validate'),
    path('api/maps/validate_batch/', MapBatchValidationView.as_view(), name='map-validate-batch'),
    path('api/guide/route/',RoutePlanView.as_view(), name='route-plan'),
    path('api/', include(router.urls)),
    path('api/management/auth/<str:action>/', AdminAuthView.as_view(), name='admin-auth'),
    path('api/management/profile/', AdminProfileView.as_view(), name='admin-profile'),
    path('admin/', admin.site.urls),
    path('api/search/', include('search.urls')),
    # 其他URL配置...
]



================================================================================
文件路径: python-backend\python_backend\wsgi.py
--------------------------------------------------------------------------------

"""
WSGI config for python_backend project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

For more information, visit
https://docs.djangoproject.com/en/2.1/howto/deployment/wsgi/
"""

import os

import django
from django.core.wsgi import get_wsgi_application

os.environ.setdefault(
    'DJANGO_SETTINGS_MODULE',
    'python_backend.settings')
django.setup()

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
application = get_wsgi_application()



================================================================================
文件路径: python-backend\python_backend\__init__.py
--------------------------------------------------------------------------------

"""
Package for python_backend.
"""



================================================================================
文件路径: python-backend\search\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\search\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class SearchConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'search'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\search\context.py
--------------------------------------------------------------------------------

from django.apps import apps
from django.db.models import Q


class BaseSearchContext:
    """基础搜索上下文类"""

    def __init__(self, model_name):
        self.model_name = model_name
        self.model = apps.get_model('core', model_name)


class StoreareaContext(BaseSearchContext):
    """店铺区域上下文"""

    def __init__(self):
        super().__init__('Storearea')

    def get_by_id(self, storearea_id):
        """根据ID获取店铺区域"""
        try:
            return self.model.objects.get(id=storearea_id)
        except self.model.DoesNotExist:
            return None

    def search_by_name(self, name):
        """根据名称搜索店铺区域"""
        return self.model.objects.filter(
            store_name__icontains=name,
            is_active=True
        )

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选店铺区域"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_storearea_map_relations(self, storearea_id):
        """获取店铺区域的地图关联"""
        StoreareaMap = apps.get_model('core', 'StoreareaMap')
        return StoreareaMap.objects.filter(storearea_id=storearea_id)


class EventContext(BaseSearchContext):
    """活动上下文"""

    def __init__(self):
        super().__init__('Event')

    def get_by_id(self, event_id):
        """根据ID获取活动"""
        try:
            return self.model.objects.get(id=event_id)
        except self.model.DoesNotExist:
            return None

    def search_by_name(self, name):
        """根据名称搜索活动"""
        return self.model.objects.filter(
            event_name__icontains=name,
            is_active=True
        )

    def filter_active_events(self):
        """获取所有活跃活动"""
        return self.model.objects.filter(is_active=True)

    def get_event_storearea_relations(self, event_id):
        """获取活动的店铺区域关联"""
        EventStorearea = apps.get_model('core', 'EventStorearea')
        return EventStorearea.objects.filter(event_id=event_id)

    def get_event_eventarea_relations(self, event_id):
        """获取活动的活动区域关联"""
        EventEventarea = apps.get_model('core', 'EventEventarea')
        return EventEventarea.objects.filter(event_id=event_id)


class EventareaContext(BaseSearchContext):
    """活动区域上下文"""

    def __init__(self):
        super().__init__('Eventarea')

    def get_by_id(self, eventarea_id):
        """根据ID获取活动区域"""
        try:
            return self.model.objects.get(id=eventarea_id)
        except self.model.DoesNotExist:
            return None

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选活动区域"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_eventarea_map_relations(self, eventarea_id):
        """获取活动区域的地图关联"""
        EventareaMap = apps.get_model('core', 'EventareaMap')
        return EventareaMap.objects.filter(eventarea_id=eventarea_id)

    def get_eventarea_map_relations_by_map(self, map_id):
        """根据地图ID获取活动区域关联"""
        EventareaMap = apps.get_model('core', 'EventareaMap')
        return EventareaMap.objects.filter(map_id=map_id)


class FacilityContext(BaseSearchContext):
    """设施上下文"""

    def __init__(self):
        super().__init__('Facility')

    def get_by_id(self, facility_id):
        """根据ID获取设施"""
        try:
            return self.model.objects.get(id=facility_id)
        except self.model.DoesNotExist:
            return None

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选设施"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_facility_map_relations(self, facility_id):
        """获取设施的地图关联"""
        FacilityMap = apps.get_model('core', 'FacilityMap')
        return FacilityMap.objects.filter(facility_id=facility_id)

    def get_facility_map_relations_by_map(self, map_id):
        """根据地图ID获取设施关联"""
        FacilityMap = apps.get_model('core', 'FacilityMap')
        return FacilityMap.objects.filter(map_id=map_id)


class OtherareaContext(BaseSearchContext):
    """其他区域上下文"""

    def __init__(self):
        super().__init__('Otherarea')

    def get_by_id(self, otherarea_id):
        """根据ID获取其他区域"""
        try:
            return self.model.objects.get(id=otherarea_id)
        except self.model.DoesNotExist:
            return None

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选其他区域"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_otherarea_map_relations(self, otherarea_id):
        """获取其他区域的地图关联"""
        OtherareaMap = apps.get_model('core', 'OtherareaMap')
        return OtherareaMap.objects.filter(otherarea_id=otherarea_id)

    def get_otherarea_map_relations_by_map(self, map_id):
        """根据地图ID获取其他区域关联"""
        OtherareaMap = apps.get_model('core', 'OtherareaMap')
        return OtherareaMap.objects.filter(map_id=map_id)


class SearchElementContext:
    """搜索元素上下文，用于处理关联关系"""

    @staticmethod
    def get_storearea_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取店铺区域ID"""
        StoreareaMap = apps.get_model('core', 'StoreareaMap')
        Storearea = apps.get_model('core', 'Storearea')

        # 获取该地图的所有storearea关联
        storearea_maps = StoreareaMap.objects.filter(map_id=map_id)
        storearea_ids = [sm.storearea_id for sm in storearea_maps]

        # 如果提供了类型参数，则进一步过滤
        if type_id is not None:
            storeareas = Storearea.objects.filter(
                id__in=storearea_ids,
                type=type_id,
                is_active=True
            )
            storearea_ids = [storearea.id for storearea in storeareas]

        return storearea_ids

    @staticmethod
    def get_eventarea_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取活动区域ID"""
        EventareaMap = apps.get_model('core', 'EventareaMap')
        Eventarea = apps.get_model('core', 'Eventarea')

        eventarea_maps = EventareaMap.objects.filter(map_id=map_id)
        eventarea_ids = [em.eventarea_id for em in eventarea_maps]

        if type_id is not None:
            eventareas = Eventarea.objects.filter(
                id__in=eventarea_ids,
                type=type_id,
                is_active=True
            )
            eventarea_ids = [eventarea.id for eventarea in eventareas]

        return eventarea_ids

    @staticmethod
    def get_facility_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取设施ID"""
        FacilityMap = apps.get_model('core', 'FacilityMap')
        Facility = apps.get_model('core', 'Facility')

        facility_maps = FacilityMap.objects.filter(map_id=map_id)
        facility_ids = [fm.facility_id for fm in facility_maps]

        if type_id is not None:
            facilities = Facility.objects.filter(
                id__in=facility_ids,
                type=type_id,
                is_active=True
            )
            facility_ids = [facility.id for facility in facilities]

        return facility_ids

    @staticmethod
    def get_otherarea_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取其他区域ID"""
        OtherareaMap = apps.get_model('core', 'OtherareaMap')
        Otherarea = apps.get_model('core', 'Otherarea')

        otherarea_maps = OtherareaMap.objects.filter(map_id=map_id)
        otherarea_ids = [om.otherarea_id for om in otherarea_maps]

        if type_id is not None:
            otherareas = Otherarea.objects.filter(
                id__in=otherarea_ids,
                type=type_id,
                is_active=True
            )
            otherarea_ids = [otherarea.id for otherarea in otherareas]

        return otherarea_ids


================================================================================
文件路径: python-backend\search\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from django.apps import apps


# 使用延迟加载的方式定义序列化器
def get_storearea_serializer():
    Storearea = apps.get_model('core', 'Storearea')

    class StoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            fields = '__all__'

    return StoreareaSerializer


def get_event_serializer():
    Event = apps.get_model('core', 'Event')

    class EventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = '__all__'

    return EventSerializer


def get_eventarea_serializer():
    Eventarea = apps.get_model('core', 'Eventarea')

    class EventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            fields = '__all__'

    return EventareaSerializer


def get_facility_serializer():
    Facility = apps.get_model('core', 'Facility')

    class FacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            fields = '__all__'

    return FacilitySerializer


def get_otherarea_serializer():
    Otherarea = apps.get_model('core', 'Otherarea')

    class OtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            fields = '__all__'

    return OtherareaSerializer


def get_simple_storearea_serializer():
    Storearea = apps.get_model('core', 'Storearea')

    class SimpleStoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            fields = ['id', 'store_name', 'type']

    return SimpleStoreareaSerializer


def get_simple_event_serializer():
    Event = apps.get_model('core', 'Event')

    class SimpleEventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = ['id', 'event_name', 'start_date', 'end_date']

    return SimpleEventSerializer


def get_simple_eventarea_serializer():
    Eventarea = apps.get_model('core', 'Eventarea')

    class SimpleEventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            fields = ['id', 'organizer_name', 'type']

    return SimpleEventareaSerializer


def get_simple_facility_serializer():
    Facility = apps.get_model('core', 'Facility')

    class SimpleFacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            fields = ['id', 'type']

    return SimpleFacilitySerializer


def get_simple_otherarea_serializer():
    Otherarea = apps.get_model('core', 'Otherarea')

    class SimpleOtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            fields = ['id', 'type', 'is_public']

    return SimpleOtherareaSerializer



================================================================================
文件路径: python-backend\search\services.py
--------------------------------------------------------------------------------

from rest_framework import status
from django.apps import apps
from .context import (
    StoreareaContext, EventContext, EventareaContext,
    FacilityContext, OtherareaContext, SearchElementContext
)


class SearchService:
    """搜索服务"""

    def __init__(self):
        self.storearea_ctx = StoreareaContext()
        self.event_ctx = EventContext()
        self.eventarea_ctx = EventareaContext()
        self.facility_ctx = FacilityContext()
        self.otherarea_ctx = OtherareaContext()
        self.element_ctx = SearchElementContext()

    # ========== 店铺搜索功能 ==========

    def get_storearea_by_id(self, storearea_id):
        """获取ID为<>的商铺区域的所有信息"""
        storearea = self.storearea_ctx.get_by_id(storearea_id)
        if not storearea:
            return None, {'error': 'Storearea not found'}, status.HTTP_404_NOT_FOUND
        return storearea, None, None

    def search_storearea_by_name(self, name):
        """按名称寻找店铺区域"""
        if not name:
            return None, {'error': 'Name parameter is required'}, status.HTTP_400_BAD_REQUEST
        storeareas = self.storearea_ctx.search_by_name(name)
        return storeareas, None, None

    def list_storearea_by_type(self, type_param):
        """返回指定类型店铺区域列表"""
        if type_param:
            try:
                type_id = int(type_param)
                storeareas = self.storearea_ctx.filter_by_type(type_id=type_id)
                return storeareas, {'type': type_id}, None
            except ValueError:
                return None, {'error': 'Invalid type parameter'}, status.HTTP_400_BAD_REQUEST
        else:
            storeareas = self.storearea_ctx.filter_by_type()
            return storeareas, None, None

    def get_storearea_events(self, storearea_id):
        """返回指定店铺区域的所有活动ID列表"""
        storearea = self.storearea_ctx.get_by_id(storearea_id)
        if not storearea or not storearea.is_active:
            return None, {'error': 'Storearea not found'}, status.HTTP_404_NOT_FOUND

        EventStorearea = apps.get_model('core', 'EventStorearea')
        event_relations = EventStorearea.objects.filter(storearea_id=storearea_id)
        event_ids = [relation.event_id for relation in event_relations]

        return {'storearea_id': storearea_id, 'event_ids': event_ids}, None, None

    def get_storearea_map_ids(self, storearea_id):
        """获取storearea_id为<>的活动区域所属的map_id"""
        storearea_maps = self.storearea_ctx.get_storearea_map_relations(storearea_id)
        map_ids = [storearea_map.map_id for storearea_map in storearea_maps]
        return {'storearea_id': storearea_id, 'map_ids': map_ids}, None, None

    def get_storearea_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且type为<>的所有storearea的id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            storearea_ids = self.element_ctx.get_storearea_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'storearea_ids': storearea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_all_storearea_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有storearea_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            storearea_ids = self.element_ctx.get_storearea_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'storearea_ids': storearea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST

    # ========== 活动搜索功能 ==========

    def get_event_by_id(self, event_id):
        """按ID寻找活动"""
        event = self.event_ctx.get_by_id(event_id)
        if not event:
            return None, {'error': 'Event not found'}, status.HTTP_404_NOT_FOUND
        return event, None, None

    def search_event_by_name(self, name):
        """按名称寻找活动"""
        if not name:
            return None, {'error': 'Name parameter is required'}, status.HTTP_400_BAD_REQUEST
        events = self.event_ctx.search_by_name(name)
        return events, None, None

    def list_event_by_type(self, type_param):
        """返回指定类型活动列表"""
        events = self.event_ctx.filter_active_events()

        if type_param:
            try:
                type_id = int(type_param)
                EventEventarea = apps.get_model('core', 'EventEventarea')
                event_ids = EventEventarea.objects.filter(
                    eventarea__type=type_id
                ).values_list('event_id', flat=True).distinct()

                events = events.filter(id__in=event_ids)
                return events, {'type': type_id}, None
            except ValueError:
                return None, {'error': 'Invalid type parameter'}, status.HTTP_400_BAD_REQUEST
        else:
            return events, None, None

    def get_event_areas(self, event_id):
        """返回参加该活动的区域ID列表"""
        event = self.event_ctx.get_by_id(event_id)
        if not event:
            return None, {'error': 'Event not found'}, status.HTTP_404_NOT_FOUND

        storearea_relations = self.event_ctx.get_event_storearea_relations(event_id)
        storearea_ids = [relation.storearea_id for relation in storearea_relations]

        eventarea_relations = self.event_ctx.get_event_eventarea_relations(event_id)
        eventarea_ids = [relation.eventarea_id for relation in eventarea_relations]

        result = {
            'event_id': event_id,
            'storearea_ids': storearea_ids,
            'eventarea_ids': eventarea_ids,
            'all_area_ids': storearea_ids + eventarea_ids
        }
        return result, None, None

    # ========== 活动区域功能 ==========

    def get_eventarea_by_id(self, eventarea_id):
        """获取id为<>的活动区域的所有信息"""
        eventarea = self.eventarea_ctx.get_by_id(eventarea_id)
        if not eventarea:
            return None, {'error': 'Eventarea not found'}, status.HTTP_404_NOT_FOUND
        return eventarea, None, None

    def get_eventarea_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且 type为<>的所有eventarea的id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            eventarea_ids = self.element_ctx.get_eventarea_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'eventarea_ids': eventarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_eventarea_map_ids(self, eventarea_id):
        """获取eventarea_id为<>的活动区域所属的map_id"""
        eventarea_maps = self.eventarea_ctx.get_eventarea_map_relations(eventarea_id)
        map_ids = [eventarea_map.map_id for eventarea_map in eventarea_maps]
        return {'eventarea_id': eventarea_id, 'map_ids': map_ids}, None, None

    def get_all_eventarea_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有eventarea_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            eventarea_ids = self.element_ctx.get_eventarea_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'eventarea_ids': eventarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST

    # ========== 设施功能 ==========

    def get_facility_by_id(self, facility_id):
        """获取id为<>的设施的所有信息"""
        facility = self.facility_ctx.get_by_id(facility_id)
        if not facility:
            return None, {'error': 'Facility not found'}, status.HTTP_404_NOT_FOUND
        return facility, None, None

    def get_facility_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且type为<>的所有设施id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            facility_ids = self.element_ctx.get_facility_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'facility_ids': facility_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_facility_map_ids(self, facility_id):
        """获取facility_id为<>的活动区域所属的map_id"""
        facility_maps = self.facility_ctx.get_facility_map_relations(facility_id)
        map_ids = [facility_map.map_id for facility_map in facility_maps]
        return {'facility_id': facility_id, 'map_ids': map_ids}, None, None

    def get_all_facility_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有facility_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            facility_ids = self.element_ctx.get_facility_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'facility_ids': facility_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST

    # ========== 其他区域功能 ==========

    def get_otherarea_by_id(self, otherarea_id):
        """获取id为<>的其他区域的所有信息"""
        otherarea = self.otherarea_ctx.get_by_id(otherarea_id)
        if not otherarea:
            return None, {'error': 'Otherarea not found'}, status.HTTP_404_NOT_FOUND
        return otherarea, None, None

    def get_otherarea_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且type为<>的所有otherarea的id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            otherarea_ids = self.element_ctx.get_otherarea_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'otherarea_ids': otherarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_otherarea_map_ids(self, otherarea_id):
        """获取otherarea_id为<>的活动区域所属的map_id"""
        otherarea_maps = self.otherarea_ctx.get_otherarea_map_relations(otherarea_id)
        map_ids = [otherarea_map.map_id for otherarea_map in otherarea_maps]
        return {'otherarea_id': otherarea_id, 'map_ids': map_ids}, None, None

    def get_all_otherarea_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有otherarea_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            otherarea_ids = self.element_ctx.get_otherarea_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'otherarea_ids': otherarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST


================================================================================
文件路径: python-backend\search\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\search\urls.py
--------------------------------------------------------------------------------

from django.urls import path
from . import views

urlpatterns = [
    # Search店铺功能
    path('storearea/<int:storearea_id>/', views.storearea_by_id, name='storearea-by-id'),
    path('storearea/search/', views.storearea_search, name='storearea-search'),
    path('storearea/list/', views.storearea_list_by_type, name='storearea-list-by-type'),
    path('storearea/<int:storearea_id>/events/', views.storearea_events, name='storearea-events'),

    # 新增的店铺区域功能
    path('storearea/<int:storearea_id>/map/', views.storearea_map_ids, name='storearea-map-ids'),
    path('storearea/list/map/', views.storearea_ids_by_map_and_type, name='storearea-ids-by-map-type'),
    path('storearea/list/all_by_map/', views.all_storearea_ids_by_map, name='all-storearea-ids-by-map'),

    # Search活动功能
    path('event/<int:event_id>/', views.event_by_id, name='event-by-id'),
    path('event/search/', views.event_search, name='event-search'),
    path('event/list/', views.event_list_by_type, name='event-list-by-type'),
    path('event/<int:event_id>/areas/', views.event_areas, name='event-areas'),

    # 新增的活动区域功能
    path('eventarea/<int:eventarea_id>/', views.eventarea_by_id, name='eventarea-by-id'),
    path('eventarea/list/ids_by_map_type/', views.eventarea_ids_by_map_and_type, name='eventarea-ids-by-map-type'),
    path('eventarea/<int:eventarea_id>/map/', views.eventarea_map_ids, name='eventarea-map-ids'),
    path('eventarea/list/all_by_map/', views.all_eventarea_ids_by_map, name='all-eventarea-ids-by-map'),

    # 新增的设施功能
    path('facility/<int:facility_id>/', views.facility_by_id, name='facility-by-id'),
    path('facility/list/ids_by_map_type/', views.facility_ids_by_map_and_type, name='facility-ids-by-map-type'),
    path('facility/<int:facility_id>/map/', views.facility_map_ids, name='facility-map-ids'),
    path('facility/list/all_by_map/', views.all_facility_ids_by_map, name='all-facility-ids-by-map'),

    # 新增的其他区域功能
    path('otherarea/<int:otherarea_id>/', views.otherarea_by_id, name='otherarea-by-id'),
    path('otherarea/list/ids_by_map_type/', views.otherarea_ids_by_map_and_type, name='otherarea-ids-by-map-type'),
    path('otherarea/<int:otherarea_id>/map/', views.otherarea_map_ids, name='otherarea-map-ids'),
    path('otherarea/list/all_by_map/', views.all_otherarea_ids_by_map, name='all-otherarea-ids-by-map'),
]


================================================================================
文件路径: python-backend\search\views.py
--------------------------------------------------------------------------------

from rest_framework.decorators import api_view
from rest_framework.response import Response
from .services import SearchService
from .serializers import (
    get_storearea_serializer, get_simple_storearea_serializer,
    get_event_serializer, get_simple_event_serializer,
    get_eventarea_serializer, get_simple_eventarea_serializer,
    get_facility_serializer, get_simple_facility_serializer,
    get_otherarea_serializer, get_simple_otherarea_serializer
)

search_service = SearchService()


# ========== 店铺搜索功能 ==========

@api_view(['GET'])
def storearea_by_id(request, storearea_id):
    """获取id为<>的商铺区域的所有信息"""
    result, error, status_code = search_service.get_storearea_by_id(storearea_id)
    if error:
        return Response(error, status=status_code)

    StoreareaSerializer = get_storearea_serializer()
    serializer = StoreareaSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def storearea_search(request):
    """按名称寻找店铺区域"""
    name = request.GET.get('name', '').strip()
    result, error, status_code = search_service.search_storearea_by_name(name)
    if error:
        return Response(error, status=status_code)

    StoreareaSerializer = get_storearea_serializer()
    serializer = StoreareaSerializer(result, many=True)
    return Response(serializer.data)


@api_view(['GET'])
def storearea_list_by_type(request):
    """返回指定类型店铺区域列表"""
    type_param = request.GET.get('type', '').strip()
    result, extra, error = search_service.list_storearea_by_type(type_param)
    if error:
        return Response(error, status=extra)

    if type_param:
        StoreareaSerializer = get_storearea_serializer()
        serializer = StoreareaSerializer(result, many=True)
        response_data = {'type': extra['type'], 'storeareas': serializer.data}
    else:
        categorized = {}
        SimpleStoreareaSerializer = get_simple_storearea_serializer()
        for storearea in result:
            type_key = storearea.type or 0
            if type_key not in categorized:
                categorized[type_key] = []
            serializer = SimpleStoreareaSerializer(storearea)
            categorized[type_key].append(serializer.data)
        response_data = categorized

    return Response(response_data)


@api_view(['GET'])
def storearea_events(request, storearea_id):
    """返回指定店铺区域的所有活动ID列表"""
    result, error, status_code = search_service.get_storearea_events(storearea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def storearea_map_ids(request, storearea_id):
    """获取storearea_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_storearea_map_ids(storearea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def storearea_ids_by_map_and_type(request):
    """获取map_id为<> 且type为<>的所有storearea的id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_storearea_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_storearea_ids_by_map(request):
    """获取map_id为<>的地图对应的所有storearea_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_storearea_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 活动搜索功能 ==========

@api_view(['GET'])
def event_by_id(request, event_id):
    """按ID寻找活动"""
    result, error, status_code = search_service.get_event_by_id(event_id)
    if error:
        return Response(error, status=status_code)

    EventSerializer = get_event_serializer()
    serializer = EventSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def event_search(request):
    """按名称寻找活动"""
    name = request.GET.get('name', '').strip()
    result, error, status_code = search_service.search_event_by_name(name)
    if error:
        return Response(error, status=status_code)

    EventSerializer = get_event_serializer()
    serializer = EventSerializer(result, many=True)
    return Response(serializer.data)


@api_view(['GET'])
def event_list_by_type(request):
    """返回指定类型活动列表"""
    type_param = request.GET.get('type', '').strip()
    result, extra, error = search_service.list_event_by_type(type_param)
    if error:
        return Response(error, status=extra)

    if type_param:
        EventSerializer = get_event_serializer()
        serializer = EventSerializer(result, many=True)
        response_data = {'type': extra['type'], 'events': serializer.data}
    else:
        categorized = {}
        SimpleEventSerializer = get_simple_event_serializer()

        for event in result:
            # 获取该活动关联的所有Eventarea类型
            from django.apps import apps
            EventEventarea = apps.get_model('core', 'EventEventarea')
            eventarea_types = EventEventarea.objects.filter(
                event_id=event.id
            ).values_list('eventarea__type', flat=True).distinct()

            if not eventarea_types:
                type_key = 0
                if type_key not in categorized:
                    categorized[type_key] = []
                serializer = SimpleEventSerializer(event)
                categorized[type_key].append(serializer.data)
            else:
                for eventarea_type in eventarea_types:
                    type_key = eventarea_type or 0
                    if type_key not in categorized:
                        categorized[type_key] = []

                    serializer = SimpleEventSerializer(event)
                    categorized[type_key].append(serializer.data)

        response_data = categorized

    return Response(response_data)


@api_view(['GET'])
def event_areas(request, event_id):
    """返回参加该活动的区域ID列表"""
    result, error, status_code = search_service.get_event_areas(event_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 活动区域功能 ==========

@api_view(['GET'])
def eventarea_by_id(request, eventarea_id):
    """获取id为<>的活动区域的所有信息"""
    result, error, status_code = search_service.get_eventarea_by_id(eventarea_id)
    if error:
        return Response(error, status=status_code)

    EventareaSerializer = get_eventarea_serializer()
    serializer = EventareaSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def eventarea_ids_by_map_and_type(request):
    """获取map_id为<> 且 type为<>的所有eventarea的id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_eventarea_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def eventarea_map_ids(request, eventarea_id):
    """获取eventarea_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_eventarea_map_ids(eventarea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_eventarea_ids_by_map(request):
    """获取map_id为<>的地图对应的所有eventarea_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_eventarea_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 设施功能 ==========

@api_view(['GET'])
def facility_by_id(request, facility_id):
    """获取id为<>的设施的所有信息"""
    result, error, status_code = search_service.get_facility_by_id(facility_id)
    if error:
        return Response(error, status=status_code)

    FacilitySerializer = get_facility_serializer()
    serializer = FacilitySerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def facility_ids_by_map_and_type(request):
    """获取map_id为<> 且type为<>的所有设施id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_facility_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def facility_map_ids(request, facility_id):
    """获取facility_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_facility_map_ids(facility_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_facility_ids_by_map(request):
    """获取map_id为<>的地图对应的所有facility_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_facility_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 其他区域功能 ==========

@api_view(['GET'])
def otherarea_by_id(request, otherarea_id):
    """获取id为<>的其他区域的所有信息"""
    result, error, status_code = search_service.get_otherarea_by_id(otherarea_id)
    if error:
        return Response(error, status=status_code)

    OtherareaSerializer = get_otherarea_serializer()
    serializer = OtherareaSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def otherarea_ids_by_map_and_type(request):
    """获取map_id为<> 且type为<>的所有otherarea的id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_otherarea_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def otherarea_map_ids(request, otherarea_id):
    """获取otherarea_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_otherarea_map_ids(otherarea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_otherarea_ids_by_map(request):
    """获取map_id为<>的地图对应的所有otherarea_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_otherarea_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)



================================================================================
文件路径: python-backend\search\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\search\migrations\__init__.py
--------------------------------------------------------------------------------






================================================================================
文件路径: python-backend\manage.py
--------------------------------------------------------------------------------

#!/usr/bin/env python
"""
Command-line utility for administrative tasks.

# For more information about this file, visit
# https://docs.djangoproject.com/en/2.1/ref/django-admin/
"""

import os
import sys

import django

if __name__ == '__main__':
    os.environ.setdefault(
        'DJANGO_SETTINGS_MODULE',
        'python_backend.settings')
    django.setup()

    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)



================================================================================
文件路径: python-backend\requirements.txt
--------------------------------------------------------------------------------

Django==5.2.8
asgiref==3.10.0
pip==25.0.1
psycopg2-binary==2.9.11
sqlparse==0.5.3
tzdata==2025.2
virtualenv==12.1.1
djangorestframework==3.15.2
markdown==3.7
django-filter==24.3
django-cors-headers==4.0.0
ezdxf==1.1.0


================================================================================
文件路径: python-backend\client\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\client\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class ClientConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'client'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\client\models.py
--------------------------------------------------------------------------------

from django.db import models

# Create your models here.



================================================================================
文件路径: python-backend\client\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\client\views.py
--------------------------------------------------------------------------------

from django.shortcuts import render

# Create your views here.
from rest_framework import viewsets, status

from rest_framework.decorators import action

from rest_framework.response import Response


================================================================================
文件路径: python-backend\client\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\client\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\core\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\core\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig

class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core'


================================================================================
文件路径: python-backend\core\context.py
--------------------------------------------------------------------------------

from core.models import *
from django.db.models import Q

class BaseContext:
    """基础 CRUD Context"""
    def __init__(self, model):
        self.model = model

    def get_by_id(self, pk):
        try:
            return self.model.objects.get(pk=pk)
        except self.model.DoesNotExist:
            return None

    def list_all(self):
        return self.model.objects.all()

    def create(self, **kwargs):
        return self.model.objects.create(**kwargs)

    def update(self, instance, **kwargs):
        for key, value in kwargs.items():
            setattr(instance, key, value)
        instance.save()
        return instance

    def delete(self, instance):
        instance.delete()


================================================================================
文件路径: python-backend\core\models.py
--------------------------------------------------------------------------------

from django.contrib.gis.db import models

# Create your models here.
class Admin(models.Model):
    account = models.CharField(unique=True, max_length=64)
    password = models.CharField(max_length=256)
    name = models.CharField(max_length=64, blank=True, null=True)

    class Meta:
        db_table = 'admin'
        # managed = False


class Building(models.Model):
    name = models.CharField(unique=True, max_length=64)
    address = models.CharField(max_length=256)
    description = models.CharField(max_length=256, blank=True, null=True)

    class Meta:
        db_table = 'building'
        # managed = False


class Event(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    description = models.CharField(max_length=256, blank=True, null=True)
    event_name = models.CharField(max_length=64)
    start_date = models.DateTimeField()
    end_date = models.DateTimeField()
    image_url = models.CharField(max_length=256, blank=True, null=True)

    class Meta:
        db_table = 'event'
        # managed = False


class EventEventarea(models.Model):
    pk = models.CompositePrimaryKey('event_id', 'eventarea_id')
    event = models.ForeignKey(Event, on_delete=models.CASCADE)
    eventarea = models.ForeignKey('Eventarea', on_delete=models.CASCADE)

    class Meta:
        db_table = 'event_eventarea'
        # managed = False
        # unique_together = (('event', 'eventarea'),)


class EventStorearea(models.Model):
    pk = models.CompositePrimaryKey('event_id', 'storearea_id')
    event = models.ForeignKey(Event, on_delete=models.CASCADE)
    storearea = models.ForeignKey('Storearea', on_delete=models.CASCADE)

    class Meta:
        db_table = 'event_storearea'
        # unique_together = (('event', 'storearea'),)
        # managed = False


class Eventarea(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    shape = models.PolygonField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    organizer_name = models.CharField(max_length=64)
    organizer_phone = models.CharField(max_length=16)
    type = models.IntegerField(blank=True, null=True)

    class Meta:
        db_table = 'eventarea'
        # managed = False


class EventareaMap(models.Model):
    pk = models.CompositePrimaryKey('eventarea_id', 'map_id')
    eventarea = models.ForeignKey(Eventarea, on_delete=models.CASCADE)
    map = models.ForeignKey('Map', on_delete=models.CASCADE)

    class Meta:
        db_table = 'eventarea_map'
        # unique_together = (('eventarea', 'map'),)
        # managed = False


class Facility(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    location = models.PointField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    type = models.IntegerField()

    class Meta:
        db_table = 'facility'
        # managed = False


class FacilityMap(models.Model):
    pk = models.CompositePrimaryKey('facility_id', 'map_id')
    facility = models.ForeignKey(Facility, on_delete=models.CASCADE)
    map = models.ForeignKey('Map', on_delete=models.CASCADE)

    class Meta:
        db_table = 'facility_map'
        # unique_together = (('facility', 'map'),)
        # managed = False


class Map(models.Model):
    building = models.ForeignKey(Building, models.CASCADE)
    floor_number = models.IntegerField()
    detail = models.GeometryCollectionField(srid=2385)

    class Meta:
        db_table = 'map'
        unique_together = (('building', 'floor_number'),)
        # managed = False


class Otherarea(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    shape = models.PolygonField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    type = models.IntegerField()
    is_public = models.BooleanField(blank=True, null=True)

    class Meta:
        db_table = 'otherarea'
        # managed = False


class OtherareaMap(models.Model):
    pk = models.CompositePrimaryKey('otherarea_id', 'map_id')
    otherarea = models.ForeignKey(Otherarea, on_delete=models.CASCADE)
    map = models.ForeignKey(Map, on_delete=models.CASCADE)

    class Meta:
        db_table = 'otherarea_map'
        # managed = False
        # unique_together = (('otherarea', 'map'),)


class Storearea(models.Model):
    is_active = models.BooleanField(blank=True, null=True)
    shape = models.PolygonField(srid=2385)
    description = models.CharField(max_length=256, blank=True, null=True)
    store_name = models.CharField(max_length=64)
    owner_name = models.CharField(max_length=64)
    owner_phone = models.CharField(max_length=16)
    logo_url = models.CharField(max_length=256, blank=True, null=True)
    open_time = models.TimeField(blank=True, null=True)
    close_time = models.TimeField(blank=True, null=True)
    type = models.IntegerField(blank=True, null=True)
    api_url = models.CharField(max_length=256, blank=True, null=True)

    class Meta:
        db_table = 'storearea'
        # managed = False


class StoreareaMap(models.Model):
    pk = models.CompositePrimaryKey('storearea_id', 'map_id')
    storearea = models.ForeignKey(Storearea, on_delete=models.CASCADE)
    map = models.ForeignKey(Map, on_delete=models.CASCADE)

    class Meta:
        db_table = 'storearea_map'
        # unique_together = (('storearea', 'map'),)
        # managed = False


================================================================================
文件路径: python-backend\core\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\core\views.py
--------------------------------------------------------------------------------

from django.shortcuts import render

# Create your views here.



================================================================================
文件路径: python-backend\core\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\core\migrations\0001_initial.py
--------------------------------------------------------------------------------

# Generated by Django 5.2.8 on 2025-12-10 02:55

import django.contrib.gis.db.models.fields
import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Admin',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('account', models.CharField(max_length=64, unique=True)),
                ('password', models.CharField(max_length=256)),
                ('name', models.CharField(blank=True, max_length=64, null=True)),
            ],
            options={
                'db_table': 'admin',
            },
        ),
        migrations.CreateModel(
            name='Building',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=64, unique=True)),
                ('address', models.CharField(max_length=256)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
            ],
            options={
                'db_table': 'building',
            },
        ),
        migrations.CreateModel(
            name='Event',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('event_name', models.CharField(max_length=64)),
                ('start_date', models.DateTimeField()),
                ('end_date', models.DateTimeField()),
                ('image_url', models.CharField(blank=True, max_length=256, null=True)),
            ],
            options={
                'db_table': 'event',
            },
        ),
        migrations.CreateModel(
            name='Eventarea',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('shape', django.contrib.gis.db.models.fields.PolygonField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('organizer_name', models.CharField(max_length=64)),
                ('organizer_phone', models.CharField(max_length=16)),
                ('type', models.IntegerField(blank=True, null=True)),
            ],
            options={
                'db_table': 'eventarea',
            },
        ),
        migrations.CreateModel(
            name='Facility',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('location', django.contrib.gis.db.models.fields.PointField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('type', models.IntegerField()),
            ],
            options={
                'db_table': 'facility',
            },
        ),
        migrations.CreateModel(
            name='Otherarea',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('shape', django.contrib.gis.db.models.fields.PolygonField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('type', models.IntegerField()),
                ('is_public', models.BooleanField(blank=True, null=True)),
            ],
            options={
                'db_table': 'otherarea',
            },
        ),
        migrations.CreateModel(
            name='Storearea',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('is_active', models.BooleanField(blank=True, null=True)),
                ('shape', django.contrib.gis.db.models.fields.PolygonField(srid=2385)),
                ('description', models.CharField(blank=True, max_length=256, null=True)),
                ('store_name', models.CharField(max_length=64)),
                ('owner_name', models.CharField(max_length=64)),
                ('owner_phone', models.CharField(max_length=16)),
                ('logo_url', models.CharField(blank=True, max_length=256, null=True)),
                ('open_time', models.TimeField(blank=True, null=True)),
                ('close_time', models.TimeField(blank=True, null=True)),
                ('type', models.IntegerField(blank=True, null=True)),
                ('api_url', models.CharField(blank=True, max_length=256, null=True)),
            ],
            options={
                'db_table': 'storearea',
            },
        ),
        migrations.CreateModel(
            name='EventEventarea',
            fields=[
                ('pk', models.CompositePrimaryKey('event_id', 'eventarea_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('event', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.event')),
                ('eventarea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.eventarea')),
            ],
            options={
                'db_table': 'event_eventarea',
            },
        ),
        migrations.CreateModel(
            name='Map',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('floor_number', models.IntegerField()),
                ('detail', django.contrib.gis.db.models.fields.GeometryCollectionField(srid=2385)),
                ('building', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.building')),
            ],
            options={
                'db_table': 'map',
                'unique_together': {('building', 'floor_number')},
            },
        ),
        migrations.CreateModel(
            name='FacilityMap',
            fields=[
                ('pk', models.CompositePrimaryKey('facility_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('facility', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.facility')),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
            ],
            options={
                'db_table': 'facility_map',
            },
        ),
        migrations.CreateModel(
            name='EventareaMap',
            fields=[
                ('pk', models.CompositePrimaryKey('eventarea_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('eventarea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.eventarea')),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
            ],
            options={
                'db_table': 'eventarea_map',
            },
        ),
        migrations.CreateModel(
            name='OtherareaMap',
            fields=[
                ('pk', models.CompositePrimaryKey('otherarea_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
                ('otherarea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.otherarea')),
            ],
            options={
                'db_table': 'otherarea_map',
            },
        ),
        migrations.CreateModel(
            name='EventStorearea',
            fields=[
                ('pk', models.CompositePrimaryKey('event_id', 'storearea_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('event', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.event')),
                ('storearea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.storearea')),
            ],
            options={
                'db_table': 'event_storearea',
            },
        ),
        migrations.CreateModel(
            name='StoreareaMap',
            fields=[
                ('pk', models.CompositePrimaryKey('storearea_id', 'map_id', blank=True, editable=False, primary_key=True, serialize=False)),
                ('map', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.map')),
                ('storearea', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.storearea')),
            ],
            options={
                'db_table': 'storearea_map',
            },
        ),
    ]



================================================================================
文件路径: python-backend\core\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\editor\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\editor\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class EditorConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'editor'



================================================================================
文件路径: python-backend\editor\context.py
--------------------------------------------------------------------------------

from django.contrib.gis.geos import GEOSGeometry
from core.models import (
    Event,
    Storearea,
    StoreareaMap,
    EventStorearea,
    EventEventarea,
    Eventarea,
    EventareaMap,
    Otherarea,
    OtherareaMap,
    Facility,
    FacilityMap
)


class StoreareaContext:
    """
    店铺区域（Storearea）的数据访问层
    负责与数据库交互，仅提供shape属性相关的操作
    """

    @staticmethod
    def get_all():
        """获取所有店铺区域"""
        return Storearea.objects.all()

    @staticmethod
    def get_by_id(storearea_id):
        """根据ID获取店铺区域"""
        return Storearea.objects.filter(id=storearea_id).first()

    @staticmethod
    def create(shape, map_id=None):
        """创建新的店铺区域，并可选绑定到指定地图"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            # 这样无论是WKT还是GeoJSON格式，都会使用正确的SRID
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        storearea = Storearea.objects.create(shape=shape_geom)
        # 绑定到地图
        if map_id is not None:
            StoreareaMap.objects.create(storearea=storearea, map_id=map_id)
        return storearea

    @staticmethod
    def update_shape(storearea_id, shape):
        """更新店铺区域的形状"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        Storearea.objects.filter(id=storearea_id).update(shape=shape_geom)
        return StoreareaContext.get_by_id(storearea_id)

    @staticmethod
    def delete(storearea_id):
        """删除店铺区域"""
        Storearea.objects.filter(id=storearea_id).delete()

    @staticmethod
    def delete_many(storearea_ids):
        """批量删除店铺区域"""
        if storearea_ids:
            Storearea.objects.filter(id__in=storearea_ids).delete()

    @staticmethod
    def get_events_by_storearea(storearea_id):
        """获取店铺关联的所有活动ID"""
        event_relations = EventStorearea.objects.filter(storearea_id=storearea_id)
        return [relation.event_id for relation in event_relations]


class EventContext:
    """
    活动（Event）的数据访问层
    负责与数据库交互，仅提供shape属性相关的操作
    """

    @staticmethod
    def get_all():
        """获取所有活动"""
        return Event.objects.all()

    @staticmethod
    def get_by_id(event_id):
        """根据ID获取活动"""
        return Event.objects.filter(id=event_id).first()



    @staticmethod
    def get_storeareas_by_event(event_id):
        """获取活动关联的所有店铺区域ID"""
        storearea_relations = EventStorearea.objects.filter(event_id=event_id)
        return [relation.storearea_id for relation in storearea_relations]

    @staticmethod
    def get_eventareas_by_event(event_id):
        """获取活动关联的所有活动区域ID"""
        eventarea_relations = EventEventarea.objects.filter(event_id=event_id)
        return [relation.eventarea_id for relation in eventarea_relations]

    @staticmethod
    def add_storearea_relation(event_id, storearea_id):
        """添加活动与店铺区域的关联关系"""
        return EventStorearea.objects.get_or_create(event_id=event_id, storearea_id=storearea_id)

    @staticmethod
    def remove_storearea_relation(event_id, storearea_id):
        """移除活动与店铺区域的关联关系"""
        return EventStorearea.objects.filter(event_id=event_id, storearea_id=storearea_id).delete()

    @staticmethod
    def add_eventarea_relation(event_id, eventarea_id):
        """添加活动与活动区域的关联关系"""
        return EventEventarea.objects.get_or_create(event_id=event_id, eventarea_id=eventarea_id)

    @staticmethod
    def remove_eventarea_relation(event_id, eventarea_id):
        """移除活动与活动区域的关联关系"""
        return EventEventarea.objects.filter(event_id=event_id, eventarea_id=eventarea_id).delete()


class EventareaContext:
    """
    活动区域（Eventarea）的数据访问层
    负责与数据库交互，提供基本的CRUD操作
    """

    @staticmethod
    def get_all():
        """获取所有活动区域"""
        return Eventarea.objects.all()

    @staticmethod
    def get_by_id(eventarea_id):
        """根据ID获取活动区域"""
        return Eventarea.objects.filter(id=eventarea_id).first()

    @staticmethod
    def create(shape, map_id=None):
        """创建新的活动区域，并可选绑定到指定地图"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        eventarea = Eventarea.objects.create(shape=shape_geom)
        if map_id is not None:
            EventareaMap.objects.create(eventarea=eventarea, map_id=map_id)
        return eventarea

    @staticmethod
    def update_shape(eventarea_id, shape):
        """更新活动区域的形状"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        Eventarea.objects.filter(id=eventarea_id).update(shape=shape_geom)
        return EventareaContext.get_by_id(eventarea_id)

    @staticmethod
    def delete(eventarea_id):
        """删除活动区域"""
        Eventarea.objects.filter(id=eventarea_id).delete()

    @staticmethod
    def delete_many(eventarea_ids):
        """批量删除活动区域"""
        if eventarea_ids:
            Eventarea.objects.filter(id__in=eventarea_ids).delete()


class OtherareaContext:
    """
    其他区域（Otherarea）的数据访问层
    负责与数据库交互，提供基本的CRUD操作
    """

    @staticmethod
    def get_all():
        """获取所有其他区域"""
        return Otherarea.objects.all()

    @staticmethod
    def get_by_id(otherarea_id):
        """根据ID获取其他区域"""
        return Otherarea.objects.filter(id=otherarea_id).first()

    @staticmethod
    def create(shape, map_id=None, type_val=None):
        """创建新的其他区域，并可选绑定到指定地图"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        otherarea = Otherarea.objects.create(
            shape=shape_geom,
            type=type_val if type_val is not None else 0  # 默认 0，避免 NOT NULL 约束报错
        )
        if map_id is not None:
            OtherareaMap.objects.create(otherarea=otherarea, map_id=map_id)
        return otherarea

    @staticmethod
    def update_shape(otherarea_id, shape):
        """更新其他区域的形状"""
        # 将shape字符串转换为GEOSGeometry对象，支持WKT和GeoJSON格式
        try:
            # 直接解析，并明确指定SRID=2385
            shape_geom = GEOSGeometry(shape, srid=2385)
        except Exception as e:
            raise ValueError(f"Invalid spatial data. Failed to parse geometry: {str(e)}")
        
        # 确保SRID为2385（双重保险）
        if shape_geom.srid != 2385:
            shape_geom.srid = 2385
        
        Otherarea.objects.filter(id=otherarea_id).update(shape=shape_geom)
        return OtherareaContext.get_by_id(otherarea_id)

    @staticmethod
    def delete(otherarea_id):
        """删除其他区域"""
        Otherarea.objects.filter(id=otherarea_id).delete()

    @staticmethod
    def delete_many(otherarea_ids):
        """批量删除其他区域"""
        if otherarea_ids:
            Otherarea.objects.filter(id__in=otherarea_ids).delete()


class FacilityContext:
    """
    设施（Facility）的数据访问层
    """

    @staticmethod
    def get_all():
        return Facility.objects.all()

    @staticmethod
    def get_by_id(facility_id):
        return Facility.objects.filter(id=facility_id).first()

    @staticmethod
    def create(location, map_id=None, type_val=None):
        try:
            loc_geom = GEOSGeometry(location)
            if loc_geom.srid != 2385:
                loc_geom.srid = 2385
        except Exception as e:
            raise ValueError(f"Invalid spatial data: {str(e)}")

        facility = Facility.objects.create(
            location=loc_geom,
            type=type_val if type_val is not None else 0
        )
        if map_id is not None:
            FacilityMap.objects.create(facility=facility, map_id=map_id)
        return facility

    @staticmethod
    def update_location(facility_id, location):
        """更新设施位置"""
        try:
            loc_geom = GEOSGeometry(location)
            if loc_geom.srid != 2385:
                loc_geom.srid = 2385
        except Exception as e:
            raise ValueError(f"Invalid spatial data: {str(e)}")

        Facility.objects.filter(id=facility_id).update(location=loc_geom)
        return FacilityContext.get_by_id(facility_id)

    @staticmethod
    def delete(facility_id):
        Facility.objects.filter(id=facility_id).delete()

    @staticmethod
    def delete_many(facility_ids):
        """批量删除设施"""
        if facility_ids:
            Facility.objects.filter(id__in=facility_ids).delete()


================================================================================
文件路径: python-backend\editor\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from django.apps import apps


def get_storearea_serializer():
    """获取 Storearea 序列化器"""
    Storearea = apps.get_model('core', 'Storearea')

    class StoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            fields = '__all__'

    return StoreareaSerializer


def get_event_serializer():
    """获取 Event 序列化器"""
    Event = apps.get_model('core', 'Event')

    class EventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = '__all__'

    return EventSerializer


def get_eventarea_serializer():
    """获取活动区域序列化器"""
    Eventarea = apps.get_model('core', 'Eventarea')
    
    class EventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            fields = '__all__'
    
    return EventareaSerializer


def get_otherarea_serializer():
    """获取其他区域序列化器"""
    Otherarea = apps.get_model('core', 'Otherarea')
    
    class OtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            fields = '__all__'
    
    return OtherareaSerializer


def get_facility_serializer():
    """获取设施序列化器"""
    Facility = apps.get_model('core', 'Facility')

    class FacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            fields = '__all__'

    return FacilitySerializer

def get_map_serializer():
    Map = apps.get_model('core', 'Map')
    class MapSerializer(serializers.ModelSerializer):
        class Meta:
            model = Map
            fields = '__all__'
    return MapSerializer


================================================================================
文件路径: python-backend\editor\services.py
--------------------------------------------------------------------------------

from .context import StoreareaContext, EventContext, EventareaContext, OtherareaContext,FacilityContext
from map.context import MapContext
from django.contrib.gis.geos import GeometryCollection, Polygon, Point
from django.db import transaction
import ezdxf
import io


class StoreareaService:
    """
    店铺区域（Storearea）的业务层
    负责处理业务逻辑，调用数据访问层方法，仅处理shape属性相关操作
    """

    @staticmethod
    def get_all_storeareas():
        """获取所有店铺区域"""
        return StoreareaContext.get_all()

    @staticmethod
    def get_storearea_by_id(storearea_id):
        """根据ID获取店铺区域"""
        return StoreareaContext.get_by_id(storearea_id)

    @staticmethod
    def create_storearea(shape, map_id=None):
        """创建新的店铺区域，并可选绑定到指定地图"""
        return StoreareaContext.create(shape, map_id)

    @staticmethod
    def update_shape(storearea_id, shape):
        """更新店铺区域的形状"""
        # 可以在这里添加业务逻辑验证
        return StoreareaContext.update_shape(storearea_id, shape)

    @staticmethod
    def delete_storearea(storearea_id):
        """删除店铺区域"""
        # 可以在这里添加业务逻辑验证
        return StoreareaContext.delete(storearea_id)

    @staticmethod
    def get_events_for_storearea(storearea_id):
        """获取店铺关联的所有活动ID"""
        return StoreareaContext.get_events_by_storearea(storearea_id)


class EventService:
    """
    活动（Event）的业务层
    负责处理业务逻辑，调用数据访问层方法，仅处理shape属性相关操作
    """

    @staticmethod
    def get_all_events():
        """获取所有活动"""
        return EventContext.get_all()

    @staticmethod
    def get_event_by_id(event_id):
        """根据ID获取活动"""
        return EventContext.get_by_id(event_id)



    @staticmethod
    def get_areas_for_event(event_id):
        """获取活动关联的所有区域ID（包括店铺区域和活动区域）"""
        storearea_ids = EventContext.get_storeareas_by_event(event_id)
        eventarea_ids = EventContext.get_eventareas_by_event(event_id)
        return {
            'storearea_ids': storearea_ids,
            'eventarea_ids': eventarea_ids,
            'all_area_ids': storearea_ids + eventarea_ids
        }

    @staticmethod
    def add_storearea_to_event(event_id, storearea_id):
        """添加活动与店铺区域的关联关系"""
        return EventContext.add_storearea_relation(event_id, storearea_id)

    @staticmethod
    def remove_storearea_from_event(event_id, storearea_id):
        """移除活动与店铺区域的关联关系"""
        return EventContext.remove_storearea_relation(event_id, storearea_id)

    @staticmethod
    def add_eventarea_to_event(event_id, eventarea_id):
        """添加活动与活动区域的关联关系"""
        return EventContext.add_eventarea_relation(event_id, eventarea_id)

    @staticmethod
    def remove_eventarea_from_event(event_id, eventarea_id):
        """移除活动与活动区域的关联关系"""
        return EventContext.remove_eventarea_relation(event_id, eventarea_id)


class EventareaService:
    """
    活动区域（Eventarea）的业务层
    负责处理业务逻辑，调用数据访问层方法
    注意：在editor模块中只处理shape属性的更新
    """

    @staticmethod
    def get_all_eventareas():
        """获取所有活动区域"""
        return EventareaContext.get_all()

    @staticmethod
    def get_eventarea_by_id(eventarea_id):
        """根据ID获取活动区域"""
        return EventareaContext.get_by_id(eventarea_id)

    @staticmethod
    def create_eventarea(shape, map_id=None):
        """创建新的活动区域，并可选绑定到指定地图"""
        return EventareaContext.create(shape, map_id)

    @staticmethod
    def update_eventarea_shape(eventarea_id, shape):
        """更新活动区域的形状"""
        return EventareaContext.update_shape(eventarea_id, shape)

    @staticmethod
    def delete_eventarea(eventarea_id):
        """删除活动区域"""
        return EventareaContext.delete(eventarea_id)


class OtherareaService:
    """
    其他区域（Otherarea）的业务层
    负责处理业务逻辑，调用数据访问层方法
    注意：在editor模块中只处理shape属性的更新
    """

    @staticmethod
    def get_all_otherareas():
        """获取所有其他区域"""
        return OtherareaContext.get_all()

    @staticmethod
    def get_otherarea_by_id(otherarea_id):
        """根据ID获取其他区域"""
        return OtherareaContext.get_by_id(otherarea_id)

    @staticmethod
    def create_otherarea(shape, map_id=None, type_val=None):
        """创建新的其他区域，并可选绑定到指定地图"""
        return OtherareaContext.create(shape, map_id, type_val)

    @staticmethod
    def update_otherarea_shape(otherarea_id, shape):
        """更新其他区域的形状"""
        return OtherareaContext.update_shape(otherarea_id, shape)

    @staticmethod
    def delete_otherarea(otherarea_id):
        """删除其他区域"""
        return OtherareaContext.delete(otherarea_id)

class FacilityService:
    """
    设施（Facility）的业务层
    """
    @staticmethod
    def get_all_facilities():
        return FacilityContext.get_all()

    @staticmethod
    def get_facility_by_id(facility_id):
        return FacilityContext.get_by_id(facility_id)

    @staticmethod
    def create_facility(location, map_id=None, type_val=None):
        return FacilityContext.create(location, map_id, type_val)

    @staticmethod
    def update_facility_location(facility_id, location):
        return FacilityContext.update_location(facility_id, location)

    @staticmethod
    def delete_facility(facility_id):
        return FacilityContext.delete(facility_id)


class MapEditorService:
    """
    地图编辑服务：处理地图及关联要素的创建、导入
    """

    # 定义 CAD 图层名称到业务类型的映射
    LAYER_MAPPING = {
        'FLOOR_OUTLINE': 'floor',  # 底图外框
        'VOIDS': 'hole',  # 底图镂空
        'AREA_STORE': 'storearea',  # 店铺区域
        'AREA_EVENT': 'eventarea',  # 活动区域
        'AREA_OTHER': 'otherarea',  # 其他区域
        'FACILITIES': 'facility'  # 设施
    }

    @staticmethod
    def create_map(building_id, floor_number, file=None):
        map_ctx = MapContext()

        # 1. 业务校验
        if map_ctx.check_exists(building_id, floor_number):
            raise ValueError("该建筑的此楼层已存在地图")

        try:
            with transaction.atomic():
                # 2. 解析 DXF 数据
                if file:
                    dxf_data = MapEditorService._parse_dxf_layers(file)
                else:
                    # 手动模式默认数据
                    dxf_data = {
                        'floor': Polygon(((0, 0), (0, 100), (100, 100), (100, 0), (0, 0)), srid=2385),
                        'holes': [],
                        'storearea': [],
                        'eventarea': [],
                        'otherarea': [],
                        'facility': []
                    }

                # 3. 组装并创建 Map (底图)
                # 将外框和镂空组合成 GeometryCollection
                if not dxf_data['floor']:
                    raise ValueError("DXF 中未找到 FLOOR_OUTLINE 图层或有效的闭合外轮廓")

                # 组合 list: [外框, 洞1, 洞2...]
                map_geometry_list = [dxf_data['floor']] + dxf_data['holes']
                map_geometry = GeometryCollection(map_geometry_list, srid=2385)

                # 调用 Context 创建地图
                new_map = map_ctx.create_map_record(building_id, floor_number, map_geometry)

                # 4. 创建关联实体 (调用 editor.context 中的各 Context)

                # A. 创建店铺
                for shape in dxf_data['storearea']:
                    # 这里可以根据需求生成默认名称，例如 "导入的店铺"
                    StoreareaContext.create(shape=shape, map_id=new_map.id)

                # B. 创建活动区
                for shape in dxf_data['eventarea']:
                    EventareaContext.create(shape=shape, map_id=new_map.id)

                # C. 创建其他区域
                for shape in dxf_data['otherarea']:
                    # type_val 默认为 0
                    OtherareaContext.create(shape=shape, map_id=new_map.id, type_val=0)

                # D. 创建设施 (点)
                for location in dxf_data['facility']:
                    # FacilityContext.create 接收 Point 对象
                    FacilityContext.create(location=location, map_id=new_map.id, type_val=0)

                return new_map

        except Exception as e:
            # 捕获异常并回滚事务（由 transaction.atomic 自动处理回滚，这里重新抛出以便 View 层捕获）
            raise ValueError(f"创建地图失败: {str(e)}")

    @staticmethod
    def _parse_dxf_layers(uploaded_file):
        """
        解析 DXF 文件，按图层分类提取几何数据
        """
        try:
            # 1. 统一转换为二进制流 (Binary Stream)
            binary_stream = None
            if isinstance(uploaded_file, bytes):
                binary_stream = io.BytesIO(uploaded_file)
            elif hasattr(uploaded_file, 'read'):
                binary_stream = uploaded_file
            else:
                raise ValueError("不支持的文件输入类型")

            # 2. 确保指针在开头
            if hasattr(binary_stream, 'seek'):
                binary_stream.seek(0)

            # 3. 将二进制流包装为文本流 (Text Stream)
            # 使用 errors='ignore' 防止因为编码问题导致解析完全失败
            text_stream = io.TextIOWrapper(binary_stream, encoding='utf-8', errors='ignore')

            # 4. 读取 DXF
            doc = ezdxf.read(text_stream)
            # === 修复逻辑结束 ===

            msp = doc.modelspace()

            result = {
                'floor': None,
                'holes': [],
                'storearea': [],
                'eventarea': [],
                'otherarea': [],
                'facility': []
            }

            # 遍历所有实体
            for entity in msp:
                # 增加容错：有些实体可能没有 layer 属性
                if not hasattr(entity.dxf, 'layer'):
                    continue

                layer_name = entity.dxf.layer.upper()

                if layer_name not in MapEditorService.LAYER_MAPPING:
                    continue

                target_type = MapEditorService.LAYER_MAPPING[layer_name]

                # --- 处理多边形 (区域/楼层) ---
                if entity.dxftype() == 'LWPOLYLINE':
                    if not entity.closed:
                        continue  # 忽略未闭合的线

                    points = []
                    # 坐标转换：毫米 -> 米
                    for p in entity.get_points():
                        points.append((p[0] / 1000.0, p[1] / 1000.0))

                    # 确保首尾闭合
                    if points[0] != points[-1]:
                        points.append(points[0])

                    if len(points) >= 4:
                        poly = Polygon(points, srid=2385)

                        if target_type == 'floor':
                            # 假设图纸里只有一个最大的框是地板，如果有多个，暂取第一个或覆盖
                            if result['floor'] is None:
                                result['floor'] = poly
                            else:
                                # 如果有多个 FLOOR_OUTLINE，简单的逻辑是看谁面积大
                                if poly.area > result['floor'].area:
                                    result['floor'] = poly
                        elif target_type == 'hole':
                            result['holes'].append(poly)
                        elif target_type in ['storearea', 'eventarea', 'otherarea']:
                            result[target_type].append(poly)

                # --- 处理点/圆 (设施) ---
                elif entity.dxftype() in ['CIRCLE', 'POINT']:
                    if target_type == 'facility':
                        x, y = 0, 0
                        if entity.dxftype() == 'CIRCLE':
                            # 圆取圆心
                            center = entity.dxf.center
                            x, y = center.x / 1000.0, center.y / 1000.0
                        else:
                            # 点取坐标
                            loc = entity.dxf.location
                            x, y = loc.x / 1000.0, loc.y / 1000.0

                        point = Point(x, y, srid=2385)
                        result['facility'].append(point)

            return result

        except Exception as e:
            # 增加一些调试信息
            import traceback
            traceback.print_exc()
            raise ValueError(f"DXF 解析内部错误: {str(e)}")

    @staticmethod
    def delete_map(map_id):
        """
        删除地图及其所有关联的实体（商铺、设施等）
        严格遵守 Service -> Context -> Model 分层，不直接访问 Model
        """
        map_ctx = MapContext()

        # 1. 检查地图是否存在
        map_obj = map_ctx.get_by_id(map_id)
        if not map_obj:
            raise ValueError("地图不存在")

        try:
            with transaction.atomic():
                # 2. 获取关联的元素 ID (通过 Context)
                # get_map_elements 返回 (store_ids, facility_ids, other_ids, event_ids)
                s_ids, f_ids, o_ids, e_ids = map_ctx.get_map_elements(map_obj)

                # 3. 通过各领域的 Context 批量删除实体
                # 注意：StoreareaMap 等中间表会因级联删除自动清理，
                # 但 Storearea 实体本身需要显式删除。

                if s_ids:
                    StoreareaContext.delete_many(s_ids)

                if f_ids:
                    FacilityContext.delete_many(f_ids)

                if o_ids:
                    OtherareaContext.delete_many(o_ids)

                if e_ids:
                    EventareaContext.delete_many(e_ids)

                # 4. 通过 Context 删除地图本身
                map_ctx.delete_map(map_id)

        except Exception as e:
            # 记录日志等
            raise ValueError(f"删除地图失败: {str(e)}")


================================================================================
文件路径: python-backend\editor\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\editor\urls.py
--------------------------------------------------------------------------------

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

# 创建路由器并注册视图集
router = DefaultRouter()
router.register(r'storearea', views.StoreareaViewSet, basename='editor_storearea')
router.register(r'event', views.EventViewSet, basename='editor_event')
router.register(r'eventarea', views.EventareaViewSet, basename='editor_eventarea')
router.register(r'otherarea', views.OtherareaViewSet, basename='editor_otherarea')
router.register(r'facility', views.FacilityViewSet, basename='editor_facility')
router.register(r'map', views.MapEditorViewSet, basename='editor_map')

urlpatterns = [
    # 包含路由器生成的所有URL
    path('', include(router.urls)),
]




================================================================================
文件路径: python-backend\editor\views.py
--------------------------------------------------------------------------------

import base64
import io
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from django.shortcuts import get_object_or_404
from rest_framework.parsers import JSONParser
from .serializers import get_storearea_serializer, get_event_serializer, get_eventarea_serializer, get_otherarea_serializer, get_facility_serializer, get_map_serializer
from .services import StoreareaService, EventService, EventareaService, OtherareaService, FacilityService, MapEditorService


class StoreareaViewSet(viewsets.ModelViewSet):
    """
    店铺区域（Storearea）的视图集
    
    注意：在editor模块中只处理shape属性的更新，其他属性在management中实现
    
    支持的操作：
    - GET /api/editor/storearea/ - 获取所有店铺区域列表
    - GET /api/editor/storearea/{id}/ - 获取指定店铺区域详情
    - POST /api/editor/storearea/ - 创建店铺区域（仅支持shape属性）
    - PATCH /api/editor/storearea/{id}/ - 部分更新店铺区域（仅支持shape属性）
    - DELETE /api/editor/storearea/{id}/ - 删除店铺区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_storearea_serializer()
    
    def get_queryset(self):
        """获取所有店铺区域"""
        return StoreareaService.get_all_storeareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有店铺区域列表"""
        storeareas = StoreareaService.get_all_storeareas()
        serializer = self.get_serializer(storeareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定店铺区域详情"""
        storearea = get_object_or_404(StoreareaService.get_all_storeareas(), pk=pk)
        serializer = self.get_serializer(storearea)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新店铺区域"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """部分更新店铺区域（仅支持shape属性）"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be updated in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        storearea = get_object_or_404(StoreareaService.get_all_storeareas(), pk=pk)
        shape = request.data.get('shape')
        
        updated_storearea = StoreareaService.update_shape(pk, shape)
        serializer = self.get_serializer(updated_storearea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建店铺区域（仅支持shape属性），并绑定到指定地图"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be provided when creating storearea in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        shape = request.data.get('shape')
        map_id = request.data.get('map_id')
        new_storearea = StoreareaService.create_storearea(shape, map_id)
        serializer = self.get_serializer(new_storearea)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    def destroy(self, request, pk=None):
        """删除店铺区域"""
        StoreareaService.delete_storearea(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)
    
    @action(detail=True, methods=['get'])
    def events(self, request, pk=None):
        """获取店铺关联的所有活动ID"""
        event_ids = StoreareaService.get_events_for_storearea(pk)
        return Response({
            'storearea_id': pk,
            'event_ids': event_ids
        })


class EventViewSet(viewsets.ModelViewSet):
    """
    活动（Event）的视图集
    
    注意：Event模型没有shape字段，因此不支持shape属性更新

    支持的操作：
    - GET /api/editor/event/ - 获取所有活动列表
    - GET /api/editor/event/{id}/ - 获取指定活动详情
    - GET /api/editor/event/{id}/areas/ - 获取活动关联的所有区域ID
    - POST/DELETE /api/editor/event/{id}/storeareas/ - 管理活动与店铺区域的关联关系
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_event_serializer()
    
    def get_queryset(self):
        """获取所有活动"""
        return EventService.get_all_events()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动列表"""
        events = EventService.get_all_events()
        serializer = self.get_serializer(events, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动详情"""
        event = get_object_or_404(EventService.get_all_events(), pk=pk)
        serializer = self.get_serializer(event)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新活动"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """不允许在editor模块中更新活动"""
        return Response(
            {'error': 'Update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def create(self, request, *args, **kwargs):
        """不允许在editor模块中创建活动"""
        return Response(
            {'error': 'Create not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def destroy(self, request, pk=None):
        """不允许在editor模块中删除活动"""
        return Response(
            {'error': 'Delete not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    @action(detail=True, methods=['get'])
    def areas(self, request, pk=None):
        """获取活动关联的所有区域ID（包括店铺区域和活动区域）"""
        areas = EventService.get_areas_for_event(pk)
        return Response({
            'event_id': pk,
            'storearea_ids': areas['storearea_ids'],
            'eventarea_ids': areas['eventarea_ids'],
            'all_area_ids': areas['all_area_ids']
        })
    
    @action(detail=True, methods=['post', 'delete'])
    def storeareas(self, request, pk=None):
        """管理活动与店铺区域的关联关系"""
        if request.method == 'POST':
            # 添加关联
            storearea_id = request.data.get('storearea_id')
            if not storearea_id:
                return Response(
                    {'error': 'storearea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            relation, created = EventService.add_storearea_to_event(pk, storearea_id)
            
            if created:
                return Response(
                    {'message': 'Relation created successfully'},
                    status=status.HTTP_201_CREATED
                )
            else:
                return Response(
                    {'message': 'Relation already exists'},
                    status=status.HTTP_200_OK
                )
        
        elif request.method == 'DELETE':
            # 删除关联
            storearea_id = request.data.get('storearea_id')
            if not storearea_id:
                return Response(
                    {'error': 'storearea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            deleted_count, _ = EventService.remove_storearea_from_event(pk, storearea_id)
            
            if deleted_count > 0:
                return Response(
                    {'message': 'Relation deleted successfully'},
                    status=status.HTTP_204_NO_CONTENT
                )
            else:
                return Response(
                    {'error': 'Relation not found'},
                    status=status.HTTP_404_NOT_FOUND
                )


class EventareaViewSet(viewsets.ModelViewSet):
    """
    活动区域（Eventarea）的视图集
    
    注意：在editor模块中只处理shape属性的更新，其他属性在management中实现
    
    支持的操作：
    - GET /api/editor/eventarea/ - 获取所有活动区域列表
    - GET /api/editor/eventarea/{id}/ - 获取指定活动区域详情
    - POST /api/editor/eventarea/ - 创建活动区域（仅支持shape属性）
    - PATCH /api/editor/eventarea/{id}/ - 部分更新活动区域（仅支持shape属性）
    - DELETE /api/editor/eventarea/{id}/ - 删除活动区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_eventarea_serializer()
    
    def get_queryset(self):
        """获取所有活动区域"""
        return EventareaService.get_all_eventareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动区域列表"""
        eventareas = EventareaService.get_all_eventareas()
        serializer = self.get_serializer(eventareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动区域详情"""
        eventarea = get_object_or_404(EventareaService.get_all_eventareas(), pk=pk)
        serializer = self.get_serializer(eventarea)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新活动区域"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """部分更新活动区域（仅支持shape属性）"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be updated in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        eventarea = get_object_or_404(EventareaService.get_all_eventareas(), pk=pk)
        shape = request.data.get('shape')
        
        updated_eventarea = EventareaService.update_eventarea_shape(pk, shape)
        serializer = self.get_serializer(updated_eventarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建活动区域（仅支持shape属性），并绑定到指定地图"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be provided when creating eventarea in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        shape = request.data.get('shape')
        map_id = request.data.get('map_id')
        new_eventarea = EventareaService.create_eventarea(shape, map_id)
        serializer = self.get_serializer(new_eventarea)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    def destroy(self, request, pk=None):
        """删除活动区域"""
        EventareaService.delete_eventarea(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)


class OtherareaViewSet(viewsets.ModelViewSet):
    """
    其他区域（Otherarea）的视图集
    
    注意：在editor模块中只处理shape属性的更新，其他属性在management中实现
    
    支持的操作：
    - GET /api/editor/otherarea/ - 获取所有其他区域列表
    - GET /api/editor/otherarea/{id}/ - 获取指定其他区域详情
    - POST /api/editor/otherarea/ - 创建其他区域（仅支持shape属性）
    - PATCH /api/editor/otherarea/{id}/ - 部分更新其他区域（仅支持shape属性）
    - DELETE /api/editor/otherarea/{id}/ - 删除其他区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_otherarea_serializer()
    
    def get_queryset(self):
        """获取所有其他区域"""
        return OtherareaService.get_all_otherareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有其他区域列表"""
        otherareas = OtherareaService.get_all_otherareas()
        serializer = self.get_serializer(otherareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定其他区域详情"""
        otherarea = get_object_or_404(OtherareaService.get_all_otherareas(), pk=pk)
        serializer = self.get_serializer(otherarea)
        return Response(serializer.data)
    
    def update(self, request, pk=None):
        """不允许完整更新其他区域"""
        return Response(
            {'error': 'Full update not allowed in editor module'}, 
            status=status.HTTP_405_METHOD_NOT_ALLOWED
        )
    
    def partial_update(self, request, pk=None):
        """部分更新其他区域（仅支持shape属性）"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be updated in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        otherarea = get_object_or_404(OtherareaService.get_all_otherareas(), pk=pk)
        shape = request.data.get('shape')
        
        updated_otherarea = OtherareaService.update_otherarea_shape(pk, shape)
        serializer = self.get_serializer(updated_otherarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建其他区域（仅支持shape属性），并绑定到指定地图"""
        if 'shape' not in request.data:
            return Response(
                {'error': 'Only shape attribute can be provided when creating otherarea in editor module'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        shape = request.data.get('shape')
        map_id = request.data.get('map_id')
        type_val = request.data.get('type')
        new_otherarea = OtherareaService.create_otherarea(shape, map_id, type_val)
        serializer = self.get_serializer(new_otherarea)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    def destroy(self, request, pk=None):
        """删除其他区域"""
        OtherareaService.delete_otherarea(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)
    
    @action(detail=True, methods=['post', 'delete'])
    def eventareas(self, request, pk=None):
        """管理活动与活动区域的关联关系"""
        if request.method == 'POST':
            # 添加关联
            eventarea_id = request.data.get('eventarea_id')
            if not eventarea_id:
                return Response(
                    {'error': 'eventarea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            relation, created = EventService.add_eventarea_to_event(pk, eventarea_id)
            
            if created:
                return Response(
                    {'message': 'Relation created successfully'},
                    status=status.HTTP_201_CREATED
                )
            else:
                return Response(
                    {'message': 'Relation already exists'},
                    status=status.HTTP_200_OK
                )
        
        elif request.method == 'DELETE':
            # 删除关联
            eventarea_id = request.data.get('eventarea_id')
            if not eventarea_id:
                return Response(
                    {'error': 'eventarea_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            deleted_count, _ = EventService.remove_eventarea_from_event(pk, eventarea_id)
            
            if deleted_count > 0:
                return Response(
                    {'message': 'Relation deleted successfully'},
                    status=status.HTTP_204_NO_CONTENT
                )
            else:
                return Response(
                    {'error': 'Relation not found'},
                    status=status.HTTP_404_NOT_FOUND
                )


class FacilityViewSet(viewsets.ModelViewSet):
    """
    设施（Facility）的视图集
    支持操作：更新位置 (PATCH)
    """

    def get_serializer_class(self):
        return get_facility_serializer()

    def get_queryset(self):
        return FacilityService.get_all_facilities()

    def list(self, request, *args, **kwargs):
        facilities = FacilityService.get_all_facilities()
        serializer = self.get_serializer(facilities, many=True)
        return Response(serializer.data)

    def retrieve(self, request, pk=None):
        facility = get_object_or_404(FacilityService.get_all_facilities(), pk=pk)
        serializer = self.get_serializer(facility)
        return Response(serializer.data)

    def partial_update(self, request, pk=None):
        """部分更新设施（仅支持 location 属性）"""
        if 'location' not in request.data:
            return Response(
                {'error': 'Only location attribute can be updated in editor module'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # 检查 ID 是否存在
        get_object_or_404(FacilityService.get_all_facilities(), pk=pk)

        location = request.data.get('location')
        updated_facility = FacilityService.update_facility_location(pk, location)
        serializer = self.get_serializer(updated_facility)
        return Response(serializer.data)

    def create(self, request, *args, **kwargs):
        if 'location' not in request.data:
            return Response(
                {'error': 'Location is required'}, status=status.HTTP_400_BAD_REQUEST
            )

        location = request.data.get('location')
        map_id = request.data.get('map_id')
        type_val = request.data.get('type')

        new_facility = FacilityService.create_facility(location, map_id, type_val)
        serializer = self.get_serializer(new_facility)
        return Response(serializer.data, status=status.HTTP_201_CREATED)

    def destroy(self, request, pk=None):
        FacilityService.delete_facility(pk)
        return Response(status=status.HTTP_204_NO_CONTENT)


class MapEditorViewSet(viewsets.ViewSet):
    """
    地图创建、销毁与编辑视图
    POST /api/editor/map/
    DELETE /api/editor/map/{id}/
    """
    parser_classes = (JSONParser,)

    def create(self, request):
        building_id = request.data.get('building_id')
        floor_number = request.data.get('floor_number')

        # 获取 Base64 字符串
        file_data_url = request.data.get('file_data')

        if not building_id or not floor_number:
            return Response({"error": "缺少建筑ID或楼层号"}, status=status.HTTP_400_BAD_REQUEST)

        dxf_file_stream = None
        if file_data_url:
            try:
                # 1. 分离头部(如果有)和内容
                if ',' in file_data_url:
                    header, data_str = file_data_url.split(',', 1)
                else:
                    data_str = file_data_url

                # 2. Base64 解码
                file_bytes = base64.b64decode(data_str)

                # 3. 转为二进制流
                dxf_file_stream = io.BytesIO(file_bytes)

            except Exception as e:
                return Response({"error": f"文件解析失败: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            # 调用 Service
            new_map = MapEditorService.create_map(building_id, floor_number, dxf_file_stream)

            Serializer = get_map_serializer()
            return Response(Serializer(new_map).data, status=status.HTTP_201_CREATED)

        except ValueError as e:
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)

    def destroy(self, request, pk=None):
        """删除指定地图及其关联数据"""
        if not pk:
            return Response({"error": "Map ID is required"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            MapEditorService.delete_map(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            # 捕获 Service 层抛出的业务错误
            if "不存在" in str(e):
                return Response({"error": str(e)}, status=status.HTTP_404_NOT_FOUND)
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({"error": f"服务器内部错误: {str(e)}"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


================================================================================
文件路径: python-backend\editor\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\editor\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\guide\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\guide\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class GuideConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'guide'



================================================================================
文件路径: python-backend\guide\context.py
--------------------------------------------------------------------------------

from django.contrib.gis.geos import Polygon, Point
from typing import Tuple, List, Optional

# 导入所有涉及的模型
from core.models import Map, Storearea, Eventarea, Otherarea, Facility, StoreareaMap, EventareaMap, OtherareaMap, \
    FacilityMap


class GuideContext:
    """
    导航模块数据上下文
    职责：只负责从数据库提取几何数据，不负责路径计算逻辑
    """

    @staticmethod
    def get_map_geometry_data(map_id: int) -> Tuple[Optional[Polygon], List[Polygon], List[Polygon]]:
        """
        一次性获取地图的边界、原始镂空以及所有障碍物

        :param map_id: 地图 ID
        :return: (outer_shell, holes, obstacles)
        """
        # 1. 获取地图底图对象
        try:
            map_obj = Map.objects.get(pk=map_id)
        except Map.DoesNotExist:
            return None, [], []

        # 2. 解析地图底图 (GeometryCollection)
        # detail[0] 通常是地板外轮廓 (Polygon)
        # detail[1:] 是地板内部的镂空 (Polygon list)
        if not map_obj.detail or len(map_obj.detail) == 0:
            return None, [], []

        outer_shell = map_obj.detail[0]
        # 确保它是 Polygon，防止脏数据
        if not isinstance(outer_shell, Polygon):
            return None, [], []

        holes = []
        # 可能有镂空，也可能没有镂空
        if len(map_obj.detail) > 1:
            holes = list(map_obj.detail[1:])

        # 3. 获取所有业务层面的障碍物
        # 将所有障碍物统一合并到一个列表中返回
        obstacles = []

        # --- A. 获取商铺区域 (Polygon) ---
        stores = Storearea.objects.filter(
            storeareamap__map_id=map_id,
            shape__isnull=False
        ).values_list('shape', flat=True)
        obstacles.extend(stores)

        # --- B. 获取活动区域 (Polygon) ---
        events = Eventarea.objects.filter(
            eventareamap__map_id=map_id,
            shape__isnull=False
        ).values_list('shape', flat=True)
        obstacles.extend(events)

        # --- C. 获取其他区域 (Polygon) ---
        others = Otherarea.objects.filter(
            otherareamap__map_id=map_id,
            shape__isnull=False
        ).values_list('shape', flat=True)
        obstacles.extend(others)

        # --- D. 获取设施 (Point -> Polygon) ---
        facilities = Facility.objects.filter(
            facilitymap__map_id=map_id,
            location__isnull=False
        ).values_list('location', flat=True)
        # 将设施点膨胀后放入障碍物列表
        for point in facilities:
            # buffer(0.5) 表示以点为中心，半径 0.5 米的圆
            if isinstance(point, Point):
                obstacles.append(point.buffer(0.5))

        return outer_shell, holes, obstacles



================================================================================
文件路径: python-backend\guide\services.py
--------------------------------------------------------------------------------

from django.contrib.gis.geos import Point, LineString, Polygon
from typing import Tuple, List, Optional
import math
import heapq

# Context 导入
from guide.context import GuideContext


class GridSystem:
    """
    辅助类：网格系统类
    负责将世界坐标(Geo)转换为离散的网格坐标(Grid)
    并管理障碍物矩阵
    """

    def __init__(self, boundary_polygon: Polygon, resolution: float = 0.5):
        """
        :param boundary_polygon: 地图的外轮廓
        :param resolution: 网格精度，例如 0.5 表示每个网格格子 0.5x0.5 米
        """
        self.resolution = resolution
        self.boundary = boundary_polygon
        # 获取多边形 boundary_polygon 的最小最大坐标
        self.min_x, self.min_y, self.max_x, self.max_y = boundary_polygon.extent
        # 计算网格系统的 x方向、 y方向各自的格子总数
        self.width = int(math.ceil((self.max_x - self.min_x) / resolution))  # 这个方法 ceil 是向上取整
        self.height = int(math.ceil((self.max_y - self.min_y) / resolution))
        # 障碍物集合，存储不可行走的网格坐标元组 (gx, gy)
        self.obstacles = set()

    def world_to_grid(self, x: float, y: float) -> Tuple[int, int]:
        """将世界坐标转为网格坐标"""
        gx = int((x - self.min_x) / self.resolution)  # int() 是向下取整
        gy = int((y - self.min_y) / self.resolution)
        return gx, gy

    def grid_to_world(self, gx: int, gy: int) -> Tuple[float, float]:
        """将网格坐标中心转为世界坐标"""
        wx = self.min_x + (gx + 0.5) * self.resolution  # 这里是加上半格的意思，不是加上 0.5 米
        wy = self.min_y + (gy + 0.5) * self.resolution
        return wx, wy

    def mark_obstacles(self, geometry_list: List[Polygon]):
        """
        向 self.obstacles 集合中存储障碍物占据的格子坐标
        某个障碍物占据了哪些格子
        逆向思维：判断这个格子是否在这个障碍物多边形内
        """
        for poly in geometry_list:
            # 1. 性能优化：不要扫描全图，只扫描障碍物所在的那个矩形区域（Bounding Box）
            # poly.extent 返回 (min_x, min_y, max_x, max_y)
            min_x, min_y, max_x, max_y = poly.extent

            # 2. 把这个矩形区域的四个角，转换成网格坐标
            # min_gx, min_gy 是左下角格子的索引
            # max_gx, max_gy 是右上角格子的索引
            min_gx, min_gy = self.world_to_grid(min_x, min_y)
            max_gx, max_gy = self.world_to_grid(max_x, max_y)

            # 3. 修正边界，防止算出负数或者超出地图宽度的索引
            min_gx = max(0, min_gx)
            min_gy = max(0, min_gy)
            max_gx = min(self.width, max_gx + 1)  # +1 是为了保证循环能覆盖到边缘
            max_gy = min(self.height, max_gy + 1)

            # 4. 循环遍历这个小区域内的每一个格子
            for gx in range(min_gx, max_gx):
                for gy in range(min_gy, max_gy):
                    # 算出这个格子中心点在地图上的真实坐标 (wx, wy)
                    wx, wy = self.grid_to_world(gx, gy)

                    # 创建一个临时的点对象
                    cell_center = Point(wx, wy, srid=2385)

                    # 5. 关键判断：如果这个格子的中心点碰到了障碍物，这个格子就是不可走的
                    if poly.intersects(cell_center):
                        self.obstacles.add((gx, gy))

    def is_walkable(self, gx: int, gy: int) -> bool:
        """检查网格点是否在地图内且不是障碍物"""
        # 1. 数组边界检查，严格小于 self.width
        if not (0 <= gx < self.width and 0 <= gy < self.height):
            return False
        # 2. 障碍物检查
        if (gx, gy) in self.obstacles:
            return False
        # 3. 地图边界检查
        # 算出这个格子中心的真实世界坐标
        wx, wy = self.grid_to_world(gx, gy)
        # 构造一个临时的点对象
        point = Point(wx, wy, srid=2385)
        # contains() 表示如果点在多边形内部返回 True，在外部返回 False
        if not self.boundary.contains(point):
            return False

        return True


class RoutePlanService:
    """
    路径规划业务服务层
    """

    def __init__(self):
        # 创建上下文对象
        self.ctx = GuideContext()

    def validate_request_params(self, map_id, start_data, end_data) -> Tuple[bool, str]:
        """
        在View中使用的，对Request请求参数的校验逻辑
        """
        # 1. 必填项校验
        if map_id is None:
            return False, "Missing parameter: map_id"
        if not start_data or not end_data:
            return False, "Missing parameter: start or end coordinates"

        # 2. 字典结构校验
        if not isinstance(start_data, dict) or not isinstance(end_data, dict):
            return False, "Coordinates must be JSON objects with x and y"

        # 3. 坐标数值校验
        try:
            float(start_data.get('x'))
            float(start_data.get('y'))
            float(end_data.get('x'))
            float(end_data.get('y'))
        except (ValueError, TypeError):
            return False, "Coordinates x and y must be valid numbers"

        return True, "Request params are valid"

    def calculate_route(self, map_id: int, start_pt: Point, end_pt: Point) -> Optional[LineString]:
        """
        主入口：计算路径
        """
        # 1. 获取地图几何数据 (调用 Context)
        # 期望返回:
        # outer_shell: Polygon (地图地板轮廓)
        # holes: List[Polygon] (地图本身镂空)
        # obstacles: List[Geometry] (商铺、活动区、其他区域、膨胀后的设施)
        outer_shell, holes, obstacles = self.ctx.get_map_geometry_data(map_id)

        if not outer_shell:
            raise ValueError(f"Map #{map_id} outer_shell missing")

        # 2. 初始化网格系统 (Grid System)
        # 设定分辨率为 0.5 米 (可根据性能需求调整)
        grid_sys = GridSystem(outer_shell, resolution=0.5)

        # 3. 网格化障碍物
        # 将 holes 和 obstacles 合并处理
        all_obstacles = holes + obstacles
        grid_sys.mark_obstacles(all_obstacles)

        # 4. 起点、终点坐标转换
        start_node = grid_sys.world_to_grid(start_pt.x, start_pt.y)
        end_node = grid_sys.world_to_grid(end_pt.x, end_pt.y)

        # 5. 校验起终点有效性
        if not grid_sys.is_walkable(*start_node):
            raise ValueError("Start node is not walkable")
        if not grid_sys.is_walkable(*end_node):
            raise ValueError("End node is not walkable")

        # 6. 执行 A* 算法，返回网格坐标的列表
        path_nodes = self._run_astar(start_node, end_node, grid_sys)

        if not path_nodes:
            return None

        # 7. 结果转换 (Grid Nodes -> Geo LineString)
        # 将网格路径转回世界坐标的折线
        return self._construct_linestring(path_nodes, grid_sys)

    def _run_astar(self, start_node: Tuple[int, int], end_node: Tuple[int, int], grid: GridSystem) \
            -> List[Tuple[int, int]]:
        """
        A* 算法核心逻辑
        :param start_node: (gx, gy) 起点
        :param end_node: (gx, gy) 终点
        :param grid: 网格系统对象，用于判断可行走性
        :return: [(x1, y1), (x2, y2), ...] 路径列表，如果找不到路径返回 None
        """
        # 1. 初始化 open_set (优先队列)，存放 (f_score, node)，可能的扩展节点
        # f_score = g_score + h_score
        open_set = []
        heapq.heappush(open_set, (0, start_node))

        # 2. 初始化记录字典
        # came_from: 记录路径回溯，key=当前节点, value=父节点
        came_from = {}

        # g_score: 从起点到当前节点的实际代价。默认无穷大。
        g_score = {start_node: 0.0}

        # f_score: 预估总代价。默认无穷大。
        # f_score[start_node] = h(start_node, end)
        f_score = {start_node: self._heuristic(start_node, end_node)}

        # 定义移动方向和对应的代价
        # (dx, dy, cost)
        sqrt2 = math.sqrt(2)
        movements = [
            (0, 1, 1.0), (0, -1, 1.0), (1, 0, 1.0), (-1, 0, 1.0),  # 上下右左
            (1, 1, sqrt2), (1, -1, sqrt2), (-1, 1, sqrt2), (-1, -1, sqrt2)  # 对角线
        ]

        # 3. 主循环，当 open_set 非空
        while open_set:
            # 取出 f_score 最小的节点
            current_f, current = heapq.heappop(open_set)

            # --- 成功到达终点 ---
            if current == end_node:
                return self._reconstruct_path(came_from, current)

            # 遍历 8 个邻居
            for dx, dy, move_cost in movements:
                neighbor = (current[0] + dx, current[1] + dy)

                # --- 核心判断：如果邻居不可走则跳过 ---
                if not grid.is_walkable(*neighbor):
                    continue

                # 计算经过当前节点到达邻居的 tentative_g (临时G值)
                tentative_g = g_score[current] + move_cost

                # 如果临时G值小于该邻居之前的G值，或者之前没访问过该邻居 (字典里找不到 neighbor 这个 key，就返回 inf)
                if tentative_g < g_score.get(neighbor, float('inf')):
                    # 更新记录
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g

                    # 计算 f 值 = g + h
                    new_f = tentative_g + self._heuristic(neighbor, end_node)
                    f_score[neighbor] = new_f

                    # 加入优先队列等待处理
                    heapq.heappush(open_set, (new_f, neighbor))

        # 循环结束仍未找到终点
        return None

    def _reconstruct_path(self, came_from: dict, current: Tuple[int, int]) -> List[Tuple[int, int]]:
        """
        私有辅助方法：从终点回溯到起点，重建路径
        """
        total_path = [current]
        while current in came_from:
            current = came_from[current]
            total_path.append(current)

        # 因为是从终点往回找的，所以要反转列表
        return total_path[::-1]

    def _heuristic(self, node_a: Tuple[int, int], node_b: Tuple[int, int]) -> float:
        """
        启发函数 (对角距离)
        """
        delta_x = abs(node_a[0] - node_b[0])
        delta_y = abs(node_a[1] - node_b[1])
        h_value = delta_x + delta_y + (math.sqrt(2) - 2) * min(delta_x, delta_y)
        return h_value

    def _construct_linestring(self, path_nodes: List[Tuple[int, int]], grid: GridSystem) -> LineString:
        """
        将网格节点序列转换为 PostGIS LineString 对象
        """
        points = []
        for gx, gy in path_nodes:
            wx, wy = grid.grid_to_world(gx, gy)
            points.append((wx, wy))

        return LineString(points, srid=2385)



================================================================================
文件路径: python-backend\guide\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase
from unittest.mock import MagicMock, patch
from django.contrib.gis.geos import Polygon, Point, LineString
from guide.services import RoutePlanService, GridSystem
from rest_framework.test import APITestCase
from rest_framework import status
from django.contrib.gis.geos import Polygon, GeometryCollection, Point
from core.models import Map, Building, Storearea, StoreareaMap


class GridSystemTestCase(TestCase):
    """
    测试 GridSystem 类的底层逻辑 (坐标转换、障碍物标记、边界检查)
    """

    def setUp(self):
        # 创建一个 10x10 的正方形地图 (SRID=2385)
        # 坐标范围: (0,0) -> (10,10)
        self.boundary = Polygon(((0, 0), (0, 10), (10, 10), (10, 0), (0, 0)), srid=2385)
        # 分辨率设为 1.0 米，方便计算 (网格大小 10x10)
        self.grid = GridSystem(self.boundary, resolution=1.0)

    def test_coordinate_conversion(self):
        """测试世界坐标与网格坐标的相互转换"""
        # 测试 world_to_grid (向下取整)
        # 坐标 (1.5, 1.5) 应该落在 (1, 1) 格子
        gx, gy = self.grid.world_to_grid(1.5, 1.5)
        self.assertEqual((gx, gy), (1, 1))

        # 测试 grid_to_world (取中心点)
        # 格子 (1, 1) 的中心应该是 (1.5, 1.5)
        wx, wy = self.grid.grid_to_world(1, 1)
        self.assertEqual((wx, wy), (1.5, 1.5))

    def test_mark_obstacles(self):
        """测试障碍物栅格化逻辑"""
        # 创建一个位于地图中心的障碍物 (4,4) 到 (6,6)
        obstacle = Polygon(((4, 4), (4, 6), (6, 6), (6, 4), (4, 4)), srid=2385)

        self.grid.mark_obstacles([obstacle])

        # 检查障碍物内部的点 (5, 5) -> 不可走
        self.assertFalse(self.grid.is_walkable(5, 5))

        # 检查障碍物边缘的点 (网格化后可能会占据边缘)
        # (4, 4) 根据 intersects 判定通常会被占据
        self.assertFalse(self.grid.is_walkable(4, 4))

        # 检查开阔区域的点 (1, 1) -> 可走
        self.assertTrue(self.grid.is_walkable(1, 1))

    def test_boundary_check_complex_shape(self):
        """
        测试不规则形状地图的边界检查 (L型地图)
        验证 is_walkable 中的 boundary.contains 逻辑
        """
        # 创建一个 L 型多边形 (缺口在右上角)
        # (0,0) -> (0,10) -> (5,10) -> (5,5) -> (10,5) -> (10,0) -> (0,0)
        l_shape_wkt = "POLYGON((0 0, 0 10, 5 10, 5 5, 10 5, 10 0, 0 0))"
        l_shape = Polygon.from_ewkt(l_shape_wkt)
        l_shape.srid = 2385

        grid = GridSystem(l_shape, resolution=1.0)

        # 1. 测试在地图内的点 (2, 2)
        self.assertTrue(grid.is_walkable(2, 2))

        # 2. 测试在 L 型缺口处的点 (8, 8)
        # 虽然 (8, 8) 在 GridSystem 的数组索引范围内 (width=10, height=10)
        # 但它在物理上位于大楼外部
        self.assertFalse(grid.is_walkable(8, 8))


class RoutePlanServiceTestCase(TestCase):
    """
    测试 A* 算法服务层逻辑
    使用 Mock 屏蔽 Context/数据库 操作
    """

    def setUp(self):
        self.service = RoutePlanService()
        # 基础地图: 20x20 米的正方形
        self.map_boundary = Polygon(((0, 0), (0, 20), (20, 20), (20, 0), (0, 0)), srid=2385)

    @patch('guide.services.GuideContext')
    def test_simple_straight_path(self, MockContext):
        """测试无障碍物的直线路径"""
        # --- Mock 设置 ---
        mock_ctx_instance = MockContext.return_value
        # 返回: (外框, 镂空[], 障碍物[])
        mock_ctx_instance.get_map_geometry_data.return_value = (self.map_boundary, [], [])

        # 替换 service 中的 ctx
        self.service.ctx = mock_ctx_instance

        # --- 执行测试 ---
        start = Point(2, 2, srid=2385)
        end = Point(18, 18, srid=2385)

        # 运行算法
        route = self.service.calculate_route(map_id=1, start_pt=start, end_pt=end)

        # --- 断言 ---
        self.assertIsInstance(route, LineString)
        # 直线距离约为 22.62 米
        # A* 也是走的对角线，长度应该非常接近直线距离
        self.assertAlmostEqual(route.length, start.distance(end), delta=1.0)

    @patch('guide.services.GuideContext')
    def test_obstacle_avoidance(self, MockContext):
        """测试绕行逻辑：起点和终点中间有一堵墙，必须从缺口绕过去"""
        # --- Mock 设置 ---
        mock_ctx_instance = MockContext.return_value

        # 定义障碍物：一堵带缺口的墙
        # 墙的范围：y轴 9到11，x轴 5到20。
        # 这意味着 x轴 0到5 的区域是空的（缺口），路径只能从这里通过。
        wall_with_gap = Polygon(((5, 9), (5, 11), (20, 11), (20, 9), (5, 9)), srid=2385)

        # 模拟 Context 返回：地图边界、无镂空、以及上面定义的障碍物
        mock_ctx_instance.get_map_geometry_data.return_value = (
            self.map_boundary,
            [],
            [wall_with_gap]
        )
        self.service.ctx = mock_ctx_instance

        # --- 执行测试 ---
        # 起点(10, 2) -> 终点(10, 18)
        # 直线连线会被墙挡住 (墙在 y=9~11, x=5~20)
        start = Point(10, 2, srid=2385)
        end = Point(10, 18, srid=2385)

        route = self.service.calculate_route(1, start, end)

        # --- 断言 ---
        self.assertIsNotNone(route)

        # 1. 验证路径长度：肯定大于直线距离 (16米)
        # 直线距离 = 18 - 2 = 16
        self.assertTrue(route.length > 16.0)

        # 2. 验证路径走向：必须经过左侧缺口
        # 获取路径上所有点的 x 坐标
        coords = route.coords
        min_x_in_path = min(p[0] for p in coords)

        # 因为墙是从 x=5 开始的，所以要想过去，路径中至少有一个点的 x 必须小于 5 (或者接近 5)
        # 我们这里断言 < 6.0 是为了留一点网格化精度的余量
        self.assertLess(min_x_in_path, 6.0)

    @patch('guide.services.GuideContext')
    def test_unreachable_target(self, MockContext):
        """测试终点被完全包围无法到达的情况"""
        mock_ctx_instance = MockContext.return_value

        # 障碍物完全包围终点 (10, 10)
        box = Polygon(((8, 8), (8, 12), (12, 12), (12, 8), (8, 8)), srid=2385)

        mock_ctx_instance.get_map_geometry_data.return_value = (self.map_boundary, [], [box])
        self.service.ctx = mock_ctx_instance

        start = Point(2, 2, srid=2385)
        end = Point(10, 10, srid=2385)  # 在盒子里面

        # 预期抛出 ValueError (因为 End node is not walkable)
        # 或者如果 End node 勉强算 walkable 但无法到达，则返回 None
        # 根据 services.py 逻辑，先检查 is_walkable

        # 由于障碍物占位，End point 所在的网格会被标记为 obstacle
        with self.assertRaises(ValueError) as cm:
            self.service.calculate_route(1, start, end)

        self.assertIn("End node is not walkable", str(cm.exception))


class GuideIntegrationTestCase(APITestCase):
    """
    第二步：集成测试
    测试 Views -> Services -> Context -> DB 的完整链路
    """

    def setUp(self):
        # 1. 创建基础建筑 (外键依赖)
        self.building = Building.objects.create(
            name="Test Mall",
            address="123 Test St"
        )

        # 2. 创建地图 (Map)
        # 地图是一个 20x20 的正方形
        # 注意：Map 的 detail 字段是 GeometryCollection
        boundary = Polygon(((0, 0), (0, 20), (20, 20), (20, 0), (0, 0)), srid=2385)
        gc = GeometryCollection(boundary, srid=2385)

        self.map_obj = Map.objects.create(
            building=self.building,
            floor_number=1,
            detail=gc
        )

        # 3. 创建一个商铺 (障碍物)
        # 商铺挡在地图中间 (8,8) 到 (12,12)
        store_shape = Polygon(((8, 8), (8, 12), (12, 12), (12, 8), (8, 8)), srid=2385)
        self.store = Storearea.objects.create(
            store_name="Blocker Store",
            owner_name="Test Owner",
            owner_phone="123",
            shape=store_shape,
            is_active=True  # 确保是激活状态
        )

        # 4. 关联商铺和地图 (建立中间表关系)
        # 注意：根据你的 models.py，StoreareaMap 有两个外键
        StoreareaMap.objects.create(
            storearea=self.store,
            map=self.map_obj
        )

        # API URL (需要你在 urls.py 中配置好，这里假设路径是 /api/guide/route/)
        self.url = '/api/guide/route/'

    def test_route_api_success(self):
        """测试完整的 API 调用流程"""
        # 起点 (2,2)，终点 (18,18)
        # 中间有商铺挡路，应该能规划出路径
        payload = {
            "map_id": self.map_obj.id,
            "start": {"x": 2.0, "y": 2.0},
            "end": {"x": 18.0, "y": 18.0}
        }

        response = self.client.post(self.url, payload, format='json')

        # 1. 验证状态码 200
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        # 2. 验证返回数据结构
        data = response.data
        self.assertIn("route", data)
        self.assertIn("distance", data)
        self.assertIsInstance(data["route"], dict)  # GeoJSON 对象
        self.assertIsInstance(data["route"]["coordinates"], list)

        # 3. 验证距离是否合理 (直线约22米，绕路肯定大于22米)
        self.assertTrue(data["distance"] > 22.0)

        # 打印一下结果看看
        print(f"\n[Integration Test] Route Distance: {data['distance']} meters")

    def test_api_missing_params(self):
        """测试参数缺失情况"""
        payload = {"map_id": self.map_obj.id}  # 缺少 start/end
        response = self.client.post(self.url, payload, format='json')
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

    def test_api_invalid_coordinates(self):
        """测试无效坐标 (起点在墙里)"""
        # 起点 (10, 10) 正好在刚才创建的 Storearea 内部
        payload = {
            "map_id": self.map_obj.id,
            "start": {"x": 10.0, "y": 10.0},
            "end": {"x": 18.0, "y": 18.0}
        }
        response = self.client.post(self.url, payload, format='json')

        # 预期报错：Start node is not walkable
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn("error", response.data)


================================================================================
文件路径: python-backend\guide\views.py
--------------------------------------------------------------------------------

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.contrib.gis.geos import Point
import json

# 导入服务类
from .services import RoutePlanService


class RoutePlanView(APIView):
    """
    POST /api/guide/route/
    接收起点终点坐标，返回路径规划结果
    """
    service_class = RoutePlanService

    def post(self, request):
        service = self.service_class()

        # 读取前端传参
        # 前端传参示例: {"map_id": 1, "start": {"x": 10.0, "y": 20.0}, "end": {"x": 50.0, "y": 60.0}}
        map_id = request.data.get('map_id')
        start_data = request.data.get('start')
        end_data = request.data.get('end')

        # 这一步负责检查参数是否存在、格式是否正确、坐标是否可转换为浮点数
        is_valid, error_msg = service.validate_request_params(map_id, start_data, end_data)

        if not is_valid:
            return Response({"error": error_msg}, status=status.HTTP_400_BAD_REQUEST)

        try:
            start_point = Point(float(start_data['x']), float(start_data['y']), srid=2385)
            end_point = Point(float(end_data['x']), float(end_data['y']), srid=2385)

        except Exception as e:
            # 极端异常情况
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)

        try:
            # 预期 service 返回一个 LineString 对象
            route_geometry = service.calculate_route(map_id, start_point, end_point)

            if not route_geometry:
                return Response({"error": "Route not found or unreachable"}, status=status.HTTP_404_NOT_FOUND)

            # 构造返回
            response_data = {
                # json.loads(route_geometry.geojson) 将 GeoJSON 字符串转为 Python 字典/列表
                "route": json.loads(route_geometry.geojson),
                # route_geometry.length 自动计算米制长度，然后保留 2 位小数
                "distance": round(route_geometry.length, 2)
            }

            return Response(response_data)

        except Exception as e:
            # 捕获如算法内部抛出的业务异常
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)


================================================================================
文件路径: python-backend\guide\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\guide\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\management\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\management\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class ManagementConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'management'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\management\context.py
--------------------------------------------------------------------------------

from core.models import Eventarea, Otherarea, Event, Storearea, Facility, Admin, EventareaMap, StoreareaMap, OtherareaMap, FacilityMap
from core.context import BaseContext

class EventareaContext:
    """
    活动区域（Eventarea）的数据访问层
    
    提供与Eventarea模型相关的数据操作方法
    """
    
    @staticmethod
    def get_all_eventareas():
        """
        获取所有活动区域
        
        Returns:
            QuerySet: 活动区域的查询集
        """
        return Eventarea.objects.all()
    
    @staticmethod
    def get_eventarea_by_id(eventarea_id):
        """
        根据ID获取活动区域
        
        Args:
            eventarea_id: 活动区域ID
        
        Returns:
            Eventarea: 活动区域对象
        """
        return Eventarea.objects.get(id=eventarea_id)
    
    @staticmethod
    def create_eventarea(data):
        """
        创建新的活动区域
        
        Args:
            data: 活动区域数据
        
        Returns:
            Eventarea: 创建的活动区域对象
        """
        return Eventarea.objects.create(**data)
    
    @staticmethod
    def update_eventarea(eventarea_id, data):
        """
        更新活动区域
        
        Args:
            eventarea_id: 活动区域ID
            data: 更新数据
        
        Returns:
            Eventarea: 更新后的活动区域对象
        """
        eventarea = Eventarea.objects.get(id=eventarea_id)
        for key, value in data.items():
            setattr(eventarea, key, value)
        eventarea.save()
        return eventarea
    
    @staticmethod
    def delete_eventarea(eventarea_id):
        """
        删除活动区域
        
        Args:
            eventarea_id: 活动区域ID
        """
        Eventarea.objects.filter(id=eventarea_id).delete()
    
    @staticmethod
    def update_floor(eventarea_id, new_map_id):
        """
        更新活动区域的楼层信息
        
        Args:
            eventarea_id: 活动区域ID
            new_map_id: 新的地图ID，用于更新楼层信息
        """
        # 删除现有的关联记录
        EventareaMap.objects.filter(eventarea_id=eventarea_id).delete()
        # 创建新的关联记录
        EventareaMap.objects.create(eventarea_id=eventarea_id, map_id=new_map_id)


class EventContext:
    """
    活动（Event）的数据访问层
    
    提供与Event模型相关的数据操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """
    
    @staticmethod
    def get_all_events():
        """
        获取所有活动
        
        Returns:
            QuerySet: 活动的查询集
        """
        return Event.objects.all()
    
    @staticmethod
    def get_event_by_id(event_id):
        """
        根据ID获取活动
        
        Args:
            event_id: 活动ID
        
        Returns:
            Event: 活动对象
        """
        return Event.objects.get(id=event_id)
    
    @staticmethod
    def create_event(data):
        """
        创建新的活动
        
        Args:
            data: 活动数据
        
        Returns:
            Event: 创建的活动对象
        """
        return Event.objects.create(**data)
    
    @staticmethod
    def update_event(event_id, data):
        """
        更新活动
        
        Args:
            event_id: 活动ID
            data: 更新数据
        
        Returns:
            Event: 更新后的活动对象
        """
        event = Event.objects.get(id=event_id)
        for key, value in data.items():
            setattr(event, key, value)
        event.save()
        return event
    
    @staticmethod
    def delete_event(event_id):
        """
        删除活动
        
        Args:
            event_id: 活动ID
        """
        Event.objects.filter(id=event_id).delete()


class StoreareaContext:
    """
    店铺区域（Storearea）的数据访问层
    
    提供与Storearea模型相关的数据操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """
    
    @staticmethod
    def get_all_storeareas():
        """
        获取所有店铺区域
        
        Returns:
            QuerySet: 店铺区域的查询集
        """
        return Storearea.objects.all()
    
    @staticmethod
    def get_storearea_by_id(storearea_id):
        """
        根据ID获取店铺区域
        
        Args:
            storearea_id: 店铺区域ID
        
        Returns:
            Storearea: 店铺区域对象
        """
        return Storearea.objects.get(id=storearea_id)
    
    @staticmethod
    def create_storearea(data):
        """
        创建新的店铺区域
        
        Args:
            data: 店铺区域数据
        
        Returns:
            Storearea: 创建的店铺区域对象
        """
        return Storearea.objects.create(**data)
    
    @staticmethod
    def update_storearea(storearea_id, data):
        """
        更新店铺区域
        
        Args:
            storearea_id: 店铺区域ID
            data: 更新数据
        
        Returns:
            Storearea: 更新后的店铺区域对象
        """
        storearea = Storearea.objects.get(id=storearea_id)
        for key, value in data.items():
            setattr(storearea, key, value)
        storearea.save()
        return storearea
    
    @staticmethod
    def delete_storearea(storearea_id):
        """
        删除店铺区域
        
        Args:
            storearea_id: 店铺区域ID
        """
        Storearea.objects.filter(id=storearea_id).delete()
    
    @staticmethod
    def update_floor(storearea_id, new_map_id):
        """
        更新店铺区域的楼层信息
        
        Args:
            storearea_id: 店铺区域ID
            new_map_id: 新的地图ID，用于更新楼层信息
        """
        # 删除现有的关联记录
        StoreareaMap.objects.filter(storearea_id=storearea_id).delete()
        # 创建新的关联记录
        StoreareaMap.objects.create(storearea_id=storearea_id, map_id=new_map_id)


class OtherareaContext:
    """
    其他区域（Otherarea）的数据访问层
    
    提供与Otherarea模型相关的数据操作方法
    """
    
    @staticmethod
    def get_all_otherareas():
        """
        获取所有其他区域
        
        Returns:
            QuerySet: 其他区域的查询集
        """
        return Otherarea.objects.all()
    
    @staticmethod
    def get_otherarea_by_id(otherarea_id):
        """
        根据ID获取其他区域
        
        Args:
            otherarea_id: 其他区域ID
        
        Returns:
            Otherarea: 其他区域对象
        """
        return Otherarea.objects.get(id=otherarea_id)
    
    @staticmethod
    def create_otherarea(data):
        """
        创建新的其他区域
        
        Args:
            data: 其他区域数据
        
        Returns:
            Otherarea: 创建的其他区域对象
        """
        return Otherarea.objects.create(**data)
    
    @staticmethod
    def update_otherarea(otherarea_id, data):
        """
        更新其他区域
        
        Args:
            otherarea_id: 其他区域ID
            data: 更新数据
        
        Returns:
            Otherarea: 更新后的其他区域对象
        """
        otherarea = Otherarea.objects.get(id=otherarea_id)
        for key, value in data.items():
            setattr(otherarea, key, value)
        otherarea.save()
        return otherarea
    
    @staticmethod
    def delete_otherarea(otherarea_id):
        """
        删除其他区域
        
        Args:
            otherarea_id: 其他区域ID
        """
        Otherarea.objects.filter(id=otherarea_id).delete()
    
    @staticmethod
    def update_floor(otherarea_id, new_map_id):
        """
        更新其他区域的楼层信息
        
        Args:
            otherarea_id: 其他区域ID
            new_map_id: 新的地图ID，用于更新楼层信息
        """
        # 删除现有的关联记录
        OtherareaMap.objects.filter(otherarea_id=otherarea_id).delete()
        # 创建新的关联记录
        OtherareaMap.objects.create(otherarea_id=otherarea_id, map_id=new_map_id)


class FacilityContext:
    """
    设施（Facility）的数据访问层
    
    提供与Facility模型相关的数据操作方法
    注意：location属性由editor模块处理
    """
    
    @staticmethod
    def get_all_facilities():
        """
        获取所有设施
        
        Returns:
            QuerySet: 设施的查询集
        """
        return Facility.objects.all()
    
    @staticmethod
    def get_facility_by_id(facility_id):
        """
        根据ID获取设施
        
        Args:
            facility_id: 设施ID
        
        Returns:
            Facility: 设施对象
        """
        return Facility.objects.get(id=facility_id)
    
    @staticmethod
    def create_facility(data):
        """
        创建新的设施
        
        Args:
            data: 设施数据
        
        Returns:
            Facility: 创建的设施对象
        """
        return Facility.objects.create(**data)
    
    @staticmethod
    def update_facility(facility_id, data):
        """
        更新设施
        
        Args:
            facility_id: 设施ID
            data: 更新数据
        
        Returns:
            Facility: 更新后的设施对象
        """
        facility = Facility.objects.get(id=facility_id)
        for key, value in data.items():
            setattr(facility, key, value)
        facility.save()
        return facility
    
    @staticmethod
    def delete_facility(facility_id):
        """
        删除设施
        
        Args:
            facility_id: 设施ID
        """
        Facility.objects.filter(id=facility_id).delete()
    
    @staticmethod
    def update_floor(facility_id, new_map_id):
        """
        更新设施的楼层信息
        
        Args:
            facility_id: 设施ID
            new_map_id: 新的地图ID，用于更新楼层信息
        """
        # 删除现有的关联记录
        FacilityMap.objects.filter(facility_id=facility_id).delete()
        # 创建新的关联记录
        FacilityMap.objects.create(facility_id=facility_id, map_id=new_map_id)

class AdminContext(BaseContext):
    """针对 Admin 模型的基础 CRUD 和查询操作"""
    def __init__(self):
        super().__init__(Admin)

    def get_by_account(self, account: str) -> Admin | None:
        """根据账号名获取 Admin 实例"""
        try:
            return self.model.objects.get(account=account)
        except self.model.DoesNotExist:
            return None


================================================================================
文件路径: python-backend\management\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from django.apps import apps
from core.models import Admin

def get_eventarea_serializer():
    """获取活动区域序列化器"""
    Eventarea = apps.get_model('core', 'Eventarea')
    
    class EventareaSerializer(serializers.ModelSerializer):
        map_id = serializers.IntegerField(source='eventareamap_set.first.map_id', read_only=True)
        
        class Meta:
            model = Eventarea
            exclude = ['shape']
    
    return EventareaSerializer


def get_otherarea_serializer():
    """获取其他区域序列化器"""
    Otherarea = apps.get_model('core', 'Otherarea')
    
    class OtherareaSerializer(serializers.ModelSerializer):
        map_id = serializers.IntegerField(source='otherareamap_set.first.map_id', read_only=True)
        
        class Meta:
            model = Otherarea
            exclude = ['shape']
    
    return OtherareaSerializer


def get_event_serializer():
    """获取Event模型的序列化器"""
    Event = apps.get_model('core', 'Event')
    
    class EventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = '__all__'
    
    return EventSerializer


def get_storearea_serializer():
    """获取Storearea模型的序列化器"""
    Storearea = apps.get_model('core', 'Storearea')
    
    class StoreareaSerializer(serializers.ModelSerializer):
        map_id = serializers.IntegerField(source='storeareamap_set.first.map_id', read_only=True)
        
        class Meta:
            model = Storearea
            exclude = ['shape']
    
    return StoreareaSerializer


def get_facility_serializer():
    """获取Facility模型的序列化器"""
    Facility = apps.get_model('core', 'Facility')
    
    class FacilitySerializer(serializers.ModelSerializer):
        map_id = serializers.IntegerField(source='facilitymap_set.first.map_id', read_only=True)
        
        class Meta:
            model = Facility
            exclude = ['location']
    
    return FacilitySerializer

# Input Serializers (用于接收前端数据)
class AdminRegisterSerializer(serializers.Serializer):
    """管理员注册输入"""
    account = serializers.CharField(max_length=64)
    password = serializers.CharField(max_length=128, write_only=True)
    name = serializers.CharField(max_length=64, required=False, allow_blank=True)

class AdminLoginSerializer(serializers.Serializer):
    """管理员登录输入"""
    account = serializers.CharField(max_length=64)
    password = serializers.CharField(max_length=128, write_only=True) # write_only: 密码只用于输入，不用于输出

class AdminUpdateSerializer(serializers.Serializer):
    """管理员修改信息输入 (用于 PUT / PATCH)"""
    name = serializers.CharField(max_length=64, required=False, allow_blank=True)
    # 允许修改密码，但必须使用新的字段名 new_password
    new_password = serializers.CharField(max_length=128, required=False, write_only=True)

# Output Serializer (用于返回 Admin 实例信息)
class AdminProfileSerializer(serializers.ModelSerializer):
    """管理员信息的输出格式 (不暴露密码)"""
    class Meta:
        model = Admin
        fields = ['id', 'account', 'name']
        read_only_fields = ['id', 'account'] # 账号和ID不能通过这个接口修改


================================================================================
文件路径: python-backend\management\services.py
--------------------------------------------------------------------------------

from .context import EventareaContext, OtherareaContext, EventContext, StoreareaContext, FacilityContext, AdminContext
from core.models import Admin, Map
from django.contrib.auth.hashers import make_password, check_password
from django.core.exceptions import ValidationError


class AdminService:
    """负责管理员的注册、登录和个人信息修改的业务逻辑"""

    def __init__(self):
        self.ctx = AdminContext()

    def register_admin(self, account: str, password: str, name: str | None = None) -> Admin:
        """注册新管理员"""
        if self.ctx.get_by_account(account):
            raise ValidationError("Admin account already exists.")

        # 1. 密码哈希 (SECURITY CRITICAL)
        hashed_password = make_password(password)

        # 2. 创建实例
        admin_instance = self.ctx.create(
            account=account,
            password=hashed_password,
            name=name
        )
        return admin_instance

    def login_admin(self, account: str, password: str) -> Admin | None:
        """验证管理员登录凭证"""
        admin_instance = self.ctx.get_by_account(account)

        # 1. 检查实例是否存在
        if not admin_instance:
            return None  # 账号不存在

        # 2. 检查密码是否匹配 (使用 check_password 验证哈希值)
        if check_password(password, admin_instance.password):
            return admin_instance  # 登录成功

        return None  # 密码错误

    def update_profile(self, admin_instance: Admin, name: str | None, new_password: str | None) -> Admin:
        """更新管理员信息 (姓名和/或密码)"""
        update_data = {}

        if name is not None:
            update_data['name'] = name

        if new_password:
            # 3. 如果有新密码，哈希后再更新
            update_data['password'] = make_password(new_password)

        return self.ctx.update(admin_instance, **update_data)


class EventareaService:
    """
    活动区域（Eventarea）的业务逻辑层

    提供与Eventarea模型相关的业务逻辑处理方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_eventareas():
        """
        获取所有活动区域

        Returns:
            QuerySet: 活动区域的查询集
        """
        return EventareaContext.get_all_eventareas()

    @staticmethod
    def get_eventarea_by_id(eventarea_id):
        """
        根据ID获取活动区域

        Args:
            eventarea_id: 活动区域ID

        Returns:
            Eventarea: 活动区域对象
        """
        return EventareaContext.get_eventarea_by_id(eventarea_id)

    @staticmethod
    def create_eventarea(data):
        """
        创建新的活动区域

        Args:
            data: 活动区域数据

        Returns:
            Eventarea: 创建的活动区域对象
        """
        # 业务逻辑验证
        # 1. 验证数据完整性
        required_fields = ['is_active', 'description', 'organizer_name', 'organizer_phone', 'type']
        for field in required_fields:
            if field not in data:
                raise ValueError(f"Field '{field}' is required")

        # 2. 验证电话号码格式
        if len(data['organizer_phone']) < 10:
            raise ValueError("Phone number must be at least 10 characters long")

        # 3. 验证类型是否合法
        valid_types = [0, 1, 2, 3]  # 根据实际需求调整
        if data['type'] not in valid_types:
            raise ValueError(f"Invalid type. Valid types are: {', '.join(valid_types)}")

        # 4. 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        # 布尔值转换：将字符串"true"/"false"转换为Python布尔值
        boolean_fields = ['is_active']
        for field in boolean_fields:
            if field in data:
                value = data[field]
                if isinstance(value, str):
                    if value.lower() == 'true':
                        data[field] = True
                    elif value.lower() == 'false':
                        data[field] = False

        return EventareaContext.create_eventarea(data)

    @staticmethod
    def update_eventarea(eventarea_id, data):
        """
        更新活动区域

        Args:
            eventarea_id: 活动区域ID
            data: 更新数据

        Returns:
            Eventarea: 更新后的活动区域对象
        """
        # 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        # 布尔值转换：将字符串"true"/"false"转换为Python布尔值
        boolean_fields = ['is_active']
        for field in boolean_fields:
            if field in data:
                value = data[field]
                if isinstance(value, str):
                    if value.lower() == 'true':
                        data[field] = True
                    elif value.lower() == 'false':
                        data[field] = False

        # 如果有其他业务逻辑验证，可以在这里添加

        return EventareaContext.update_eventarea(eventarea_id, data)

    @staticmethod
    def delete_eventarea(eventarea_id):
        """
        删除活动区域
        
        Args:
            eventarea_id: 活动区域ID
        """
        # 业务逻辑验证
        # 1. 验证活动区域是否存在
        eventarea = EventareaContext.get_eventarea_by_id(eventarea_id)

        # 2. 验证是否有相关联的活动
        if eventarea.event_set.exists():
            raise ValueError("Cannot delete eventarea with associated events")

        return EventareaContext.delete_eventarea(eventarea_id)

    @staticmethod
    def update_floor(eventarea_id, new_map_id):
        """
        更新活动区域的楼层信息
        
        Args:
            eventarea_id: 活动区域ID
            new_map_id: 新的地图ID，用于更新楼层信息
        
        Returns:
            Eventarea: 更新后的活动区域对象
        """
        # 业务逻辑验证
        # 1. 验证活动区域是否存在
        EventareaContext.get_eventarea_by_id(eventarea_id)
        
        # 2. 验证map_id是否有效
        try:
            Map.objects.get(id=new_map_id)
        except Map.DoesNotExist:
            raise ValueError(f"Invalid map_id: {new_map_id}")
        
        # 3. 调用数据访问层更新楼层信息
        return EventareaContext.update_floor(eventarea_id, new_map_id)


class OtherareaService:
    """
    其他区域（Otherarea）的业务逻辑层

    提供与Otherarea模型相关的业务逻辑处理方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_otherareas():
        """
        获取所有其他区域

        Returns:
            QuerySet: 其他区域的查询集
        """
        return OtherareaContext.get_all_otherareas()

    @staticmethod
    def get_otherarea_by_id(otherarea_id):
        """
        根据ID获取其他区域

        Args:
            otherarea_id: 其他区域ID

        Returns:
            Otherarea: 其他区域对象
        """
        return OtherareaContext.get_otherarea_by_id(otherarea_id)

    @staticmethod
    def create_otherarea(data):
        """
        创建新的其他区域

        Args:
            data: 其他区域数据

        Returns:
            Otherarea: 创建的其他区域对象
        """
        # 业务逻辑验证
        # 1. 验证数据完整性
        required_fields = ['is_active', 'description', 'type', 'is_public']
        for field in required_fields:
            if field not in data:
                raise ValueError(f"Field '{field}' is required")

        # 2. 验证类型是否合法
        valid_types = [0, 1, 2, 3]  # 根据实际需求调整
        if data['type'] not in valid_types:
            raise ValueError(f"Invalid type. Valid types are: {', '.join(valid_types)}")

        # 3. 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        # 布尔值转换：将字符串"true"/"false"转换为Python布尔值
        boolean_fields = ['is_active', 'is_public']
        for field in boolean_fields:
            if field in data:
                value = data[field]
                if isinstance(value, str):
                    if value.lower() == 'true':
                        data[field] = True
                    elif value.lower() == 'false':
                        data[field] = False

        return OtherareaContext.create_otherarea(data)

    @staticmethod
    def update_otherarea(otherarea_id, data):
        """
        更新其他区域

        Args:
            otherarea_id: 其他区域ID
            data: 更新数据

        Returns:
            Otherarea: 更新后的其他区域对象
        """
        # 如果提供了shape属性，将其移除（shape属性由editor模块处理）
        if 'shape' in data:
            data.pop('shape')

        # 布尔值转换：将字符串"true"/"false"转换为Python布尔值
        boolean_fields = ['is_active', 'is_public']
        for field in boolean_fields:
            if field in data:
                value = data[field]
                if isinstance(value, str):
                    if value.lower() == 'true':
                        data[field] = True
                    elif value.lower() == 'false':
                        data[field] = False


        return OtherareaContext.update_otherarea(otherarea_id, data)

    @staticmethod
    def delete_otherarea(otherarea_id):
        """
        删除其他区域
        
        Args:
            otherarea_id: 其他区域ID
        """
        # 业务逻辑验证
        # 1. 验证其他区域是否存在
        otherarea = OtherareaContext.get_otherarea_by_id(otherarea_id)


        return OtherareaContext.delete_otherarea(otherarea_id)

    @staticmethod
    def update_floor(otherarea_id, new_map_id):
        """
        更新其他区域的楼层信息
        
        Args:
            otherarea_id: 其他区域ID
            new_map_id: 新的地图ID，用于更新楼层信息
        
        Returns:
            Otherarea: 更新后的其他区域对象
        """
        # 业务逻辑验证
        # 1. 验证其他区域是否存在
        OtherareaContext.get_otherarea_by_id(otherarea_id)
        
        # 2. 验证map_id是否有效
        try:
            Map.objects.get(id=new_map_id)
        except Map.DoesNotExist:
            raise ValueError(f"Invalid map_id: {new_map_id}")
        
        # 3. 调用数据访问层更新楼层信息
        return OtherareaContext.update_floor(otherarea_id, new_map_id)


class EventService:
    """
    活动（Event）的业务逻辑层

    提供与Event模型相关的业务逻辑操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_events():
        """
        获取所有活动

        Returns:
            QuerySet: 活动的查询集
        """
        return EventContext.get_all_events()

    @staticmethod
    def get_event_by_id(event_id):
        """
        根据ID获取活动

        Args:
            event_id: 活动ID

        Returns:
            Event: 活动对象
        """
        return EventContext.get_event_by_id(event_id)

    @staticmethod
    def create_event(data):
        """
        创建新的活动

        Args:
            data: 活动数据

        Returns:
            Event: 创建的活动对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        return EventContext.create_event(data)

    @staticmethod
    def update_event(event_id, data):
        """
        更新活动

        Args:
            event_id: 活动ID
            data: 更新数据

        Returns:
            Event: 更新后的活动对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        return EventContext.update_event(event_id, data)

    @staticmethod
    def delete_event(event_id):
        """
        删除活动

        Args:
            event_id: 活动ID
        """
        EventContext.delete_event(event_id)


class StoreareaService:
    """
    店铺区域（Storearea）的业务逻辑层

    提供与Storearea模型相关的业务逻辑操作方法
    注意：不处理shape属性，该属性由editor模块处理
    """

    @staticmethod
    def get_all_storeareas():
        """
        获取所有店铺区域

        Returns:
            QuerySet: 店铺区域的查询集
        """
        return StoreareaContext.get_all_storeareas()

    @staticmethod
    def get_storearea_by_id(storearea_id):
        """
        根据ID获取店铺区域

        Args:
            storearea_id: 店铺区域ID

        Returns:
            Storearea: 店铺区域对象
        """
        return StoreareaContext.get_storearea_by_id(storearea_id)

    @staticmethod
    def create_storearea(data):
        """
        创建新的店铺区域

        Args:
            data: 店铺区域数据

        Returns:
            Storearea: 创建的店铺区域对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 布尔值转换：将字符串"true"/"false"转换为Python布尔值
        boolean_fields = ['is_active']
        for field in boolean_fields:
            if field in data:
                value = data[field]
                if isinstance(value, str):
                    if value.lower() == 'true':
                        data[field] = True
                    elif value.lower() == 'false':
                        data[field] = False

        return StoreareaContext.create_storearea(data)

    @staticmethod
    def update_storearea(storearea_id, data):
        """
        更新店铺区域

        Args:
            storearea_id: 店铺区域ID
            data: 更新数据

        Returns:
            Storearea: 更新后的店铺区域对象
        """
        # 移除可能存在的shape属性
        if 'shape' in data:
            del data['shape']

        # 布尔值转换：将字符串"true"/"false"转换为Python布尔值
        boolean_fields = ['is_active']
        for field in boolean_fields:
            if field in data:
                value = data[field]
                if isinstance(value, str):
                    if value.lower() == 'true':
                        data[field] = True
                    elif value.lower() == 'false':
                        data[field] = False

        return StoreareaContext.update_storearea(storearea_id, data)

    @staticmethod
    def delete_storearea(storearea_id):
        """
        删除店铺区域
        
        Args:
            storearea_id: 店铺区域ID
        """
        StoreareaContext.delete_storearea(storearea_id)

    @staticmethod
    def update_floor(storearea_id, new_map_id):
        """
        更新店铺区域的楼层信息
        
        Args:
            storearea_id: 店铺区域ID
            new_map_id: 新的地图ID，用于更新楼层信息
        
        Returns:
            Storearea: 更新后的店铺区域对象
        """
        # 业务逻辑验证
        # 1. 验证店铺区域是否存在
        StoreareaContext.get_storearea_by_id(storearea_id)
        
        # 2. 验证map_id是否有效
        try:
            Map.objects.get(id=new_map_id)
        except Map.DoesNotExist:
            raise ValueError(f"Invalid map_id: {new_map_id}")
        
        # 3. 调用数据访问层更新楼层信息
        return StoreareaContext.update_floor(storearea_id, new_map_id)


class FacilityService:
    """
    设施（Facility）的业务逻辑层
    
    提供与Facility模型相关的业务逻辑处理方法
    注意：location属性由editor模块处理
    """

    @staticmethod
    def get_all_facilities():
        """
        获取所有设施
        
        Returns:
            QuerySet: 设施的查询集
        """
        return FacilityContext.get_all_facilities()

    @staticmethod
    def get_facility_by_id(facility_id):
        """
        根据ID获取设施
        
        Args:
            facility_id: 设施ID
        
        Returns:
            Facility: 设施对象
        """
        return FacilityContext.get_facility_by_id(facility_id)

    @staticmethod
    def create_facility(data):
        """
        创建新的设施
        
        Args:
            data: 设施数据
        
        Returns:
            Facility: 创建的设施对象
        """
        # 业务逻辑验证
        # 1. 验证数据完整性
        required_fields = ['is_active', 'description', 'type']
        for field in required_fields:
            if field not in data:
                raise ValueError(f"Field '{field}' is required")

        # 2. 验证类型是否合法（根据实际需求调整）
        # 这里假设type是整数类型，表示不同的设施类型

        # 3. 如果提供了location属性，将其移除（location属性由editor模块处理）
        if 'location' in data:
            data.pop('location')

        # 布尔值转换：将字符串"true"/"false"转换为Python布尔值
        boolean_fields = ['is_active']
        for field in boolean_fields:
            if field in data:
                value = data[field]
                if isinstance(value, str):
                    if value.lower() == 'true':
                        data[field] = True
                    elif value.lower() == 'false':
                        data[field] = False

        return FacilityContext.create_facility(data)

    @staticmethod
    def update_facility(facility_id, data):
        """
        更新设施
        
        Args:
            facility_id: 设施ID
            data: 更新数据
        
        Returns:
            Facility: 更新后的设施对象
        """
        # 如果提供了location属性，将其移除（location属性由editor模块处理）
        if 'location' in data:
            data.pop('location')

        # 布尔值转换：将字符串"true"/"false"转换为Python布尔值
        boolean_fields = ['is_active']
        for field in boolean_fields:
            if field in data:
                value = data[field]
                if isinstance(value, str):
                    if value.lower() == 'true':
                        data[field] = True
                    elif value.lower() == 'false':
                        data[field] = False

        return FacilityContext.update_facility(facility_id, data)

    @staticmethod
    def delete_facility(facility_id):
        """


        删除设施
        
        Args:
            facility_id: 设施ID
        """
        # 业务逻辑验证
        # 1. 验证设施是否存在
        facility = FacilityContext.get_facility_by_id(facility_id)

        return FacilityContext.delete_facility(facility_id)

    @staticmethod
    def update_floor(facility_id, new_map_id):
        """
        更新设施的楼层信息
        
        Args:
            facility_id: 设施ID
            new_map_id: 新的地图ID，用于更新楼层信息
        
        Returns:
            Facility: 更新后的设施对象
        """
        # 业务逻辑验证
        # 1. 验证设施是否存在
        FacilityContext.get_facility_by_id(facility_id)
        
        # 2. 验证map_id是否有效
        try:
            Map.objects.get(id=new_map_id)
        except Map.DoesNotExist:
            raise ValueError(f"Invalid map_id: {new_map_id}")
        
        # 3. 调用数据访问层更新楼层信息
        return FacilityContext.update_floor(facility_id, new_map_id)


================================================================================
文件路径: python-backend\management\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.
from rest_framework.test import APITestCase
from rest_framework import status
from django.urls import reverse
from core.models import Admin
from django.contrib.auth.hashers import check_password, make_password


class AdminAuthAPITestCase(APITestCase):
    """
    测试管理员注册、登录、注销接口 (AdminAuthView)
    """

    def setUp(self):
        # 预先定义好路由名称
        self.register_url = reverse('admin-auth', kwargs={'action': 'register'})
        self.login_url = reverse('admin-auth', kwargs={'action': 'login'})
        self.logout_url = reverse('admin-auth', kwargs={'action': 'logout'})
        self.profile_url = reverse('admin-profile')  # 档案管理路由

        # 注册一个测试管理员供后续登录测试使用
        self.account = "testuser"
        self.password = "password123"
        self.admin = Admin.objects.create(
            account=self.account,
            password=make_password(self.password),  # 注意: 这里是明文，在测试中我们会手动进行哈希检查
            name="Original Name"
        )

    # ------------------ 注册 (Register) 测试 ------------------

    def test_register_success(self):
        """测试成功注册新管理员"""
        data = {"account": "newadmin", "password": "newpassword456", "name": "New Admin"}
        response = self.client.post(self.register_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Admin.objects.count(), 2)
        self.assertEqual(response.data['account'], 'newadmin')

        # 验证密码是否被哈希存储
        new_admin = Admin.objects.get(account='newadmin')
        self.assertTrue(check_password("newpassword456", new_admin.password))

    def test_register_duplicate_account(self):
        """测试注册时账号重复"""
        data = {"account": self.account, "password": "somepassword", "name": "Duplicate User"}
        response = self.client.post(self.register_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('account already exists', response.data['error'].lower())
        self.assertEqual(Admin.objects.count(), 1)  # 确认没有创建新用户

    # ------------------ 登录 (Login) 测试 ------------------

    def test_login_success(self):
        """测试成功登录"""
        data = {"account": self.account, "password": self.password}
        response = self.client.post(self.login_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['account'], self.account)
        # 验证 Session 是否被正确设置 (检查响应中的 session key)
        self.assertIn('sessionid', response.cookies)
        self.assertTrue(self.client.session.get('admin_id'))

    def test_login_failure_wrong_password(self):
        """测试密码错误导致登录失败"""
        data = {"account": self.account, "password": "wrongpassword"}
        response = self.client.post(self.login_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertIn('Invalid account or password', response.data['error'])

    def test_login_failure_non_existent_account(self):
        """测试账号不存在导致登录失败"""
        data = {"account": "nonexistent", "password": "anypassword"}
        response = self.client.post(self.login_url, data, format='json')

        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertIn('Invalid account or password', response.data['error'])

    # ------------------ 注销 (Logout) 测试 ------------------

    def test_logout_success(self):
        """测试成功注销"""
        # 先登录以设置 Session
        self.client.post(self.login_url, {"account": self.account, "password": self.password}, format='json')

        # 执行注销
        response = self.client.post(self.logout_url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        # 验证 Session 是否被清除
        self.assertIsNone(self.client.session.get('admin_id'))


class AdminProfileAPITestCase(APITestCase):
    """
    测试管理员档案管理接口 (AdminProfileView)
    """

    def setUp(self):
        self.login_url = reverse('admin-auth', kwargs={'action': 'login'})
        self.profile_url = reverse('admin-profile')

        self.account = "profileuser"
        self.password = "profilepass"

        # 手动创建 Admin 实例,确保密码哈希
        hashed_password = make_password(self.password)
        self.admin = Admin.objects.create(
            account=self.account,
            password=hashed_password,
            name="Profile Target"
        )

        # 登录并获取 Session Cookie
        self.client.post(self.login_url, {"account": self.account, "password": self.password}, format='json')
        # self.admin = Admin.objects.get(account=self.account)  # 获取实例

    # ------------------ 权限 (Authorization) 测试 ------------------

    def test_profile_requires_authentication(self):
        """测试未登录用户无法访问 Profile 接口"""
        self.client.logout()  # 清除 Session
        response_get = self.client.get(self.profile_url, format='json')
        response_put = self.client.put(self.profile_url, {"name": "fail"}, format='json')

        self.assertEqual(response_get.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertEqual(response_put.status_code, status.HTTP_401_UNAUTHORIZED)

    # ------------------ 获取信息 (GET) 测试 ------------------

    def test_get_profile_success(self):
        """测试成功获取个人信息"""
        response = self.client.get(self.profile_url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['account'], self.account)
        self.assertEqual(response.data['name'], "Profile Target")
        self.assertNotIn('password', response.data)  # 确保密码没有被泄露

    # ------------------ 修改信息 (PUT/PATCH) 测试 ------------------

    def test_update_name_success(self):
        """测试成功修改姓名"""
        new_name = "Updated User Name"
        response = self.client.put(self.profile_url, {"name": new_name}, format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['name'], new_name)

        # 验证数据库中的值已更新
        self.admin.refresh_from_db()
        self.assertEqual(self.admin.name, new_name)

    def test_update_password_success(self):
        """测试成功修改密码"""
        new_password = "verysecurepassword"
        response = self.client.put(self.profile_url, {"new_password": new_password}, format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['account'], self.account)

        # 验证新的密码能否用于登录
        self.admin.refresh_from_db()
        self.assertTrue(check_password(new_password, self.admin.password))

        # 验证旧密码失效
        self.assertFalse(check_password(self.password, self.admin.password))

    def test_update_both_success(self):
        """测试同时修改姓名和密码"""
        new_name = "Final Name"
        new_password = "FinalPassword"

        response = self.client.put(self.profile_url,
                                   {"name": new_name, "new_password": new_password},
                                   format='json')

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['name'], new_name)

        # 验证数据库
        self.admin.refresh_from_db()
        self.assertEqual(self.admin.name, new_name)
        self.assertTrue(check_password(new_password, self.admin.password))


================================================================================
文件路径: python-backend\management\urls.py
--------------------------------------------------------------------------------

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import EventareaViewSet, OtherareaViewSet, EventViewSet, StoreareaViewSet, FacilityViewSet

# 创建路由器并注册视图集
router = DefaultRouter()
router.register(r'eventarea', EventareaViewSet, basename='management_eventarea')
router.register(r'otherarea', OtherareaViewSet, basename='management_otherarea')
router.register(r'event', EventViewSet, basename='management_event')
router.register(r'storearea', StoreareaViewSet, basename='management_storearea')
router.register(r'facility', FacilityViewSet, basename='management_facility')

urlpatterns = [
    # 包含路由器生成的所有URL
    path('', include(router.urls)),
]



================================================================================
文件路径: python-backend\management\views.py
--------------------------------------------------------------------------------

from rest_framework import viewsets, status
from rest_framework.decorators import action
from django.shortcuts import get_object_or_404
from .serializers import get_eventarea_serializer, get_otherarea_serializer, get_event_serializer, get_storearea_serializer, get_facility_serializer, AdminRegisterSerializer, AdminLoginSerializer, AdminUpdateSerializer, AdminProfileSerializer
from .services import EventareaService, OtherareaService, EventService, StoreareaService, FacilityService, AdminService
from rest_framework.views import APIView
from rest_framework.response import Response
from django.core.exceptions import ValidationError
from django.http import HttpRequest
from core.models import Admin
from core.context import BaseContext


class EventareaViewSet(viewsets.ModelViewSet):
    """
    活动区域（Eventarea）的视图集
    
    注意：
    - 在management模块中处理除shape属性外的所有其他属性
    - shape属性的操作由editor模块处理
    - 不允许修改shape属性
    
    支持的操作：
    - GET /api/management/eventarea/ - 获取所有活动区域列表
    - GET /api/management/eventarea/{id}/ - 获取指定活动区域详情
    - POST /api/management/eventarea/ - 创建新的活动区域
    - PUT /api/management/eventarea/{id}/ - 完整更新活动区域（不包括shape）
    - PATCH /api/management/eventarea/{id}/ - 部分更新活动区域（不包括shape）
    - DELETE /api/management/eventarea/{id}/ - 删除指定活动区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_eventarea_serializer()
    
    def get_queryset(self):
        """获取所有活动区域"""
        return EventareaService.get_all_eventareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动区域列表"""
        eventareas = EventareaService.get_all_eventareas()
        serializer = self.get_serializer(eventareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动区域详情"""
        eventarea = get_object_or_404(EventareaService.get_all_eventareas(), pk=pk)
        serializer = self.get_serializer(eventarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的活动区域"""
        try:
            # 检查是否包含shape属性，如果包含则移除
            data = request.data.copy()
            if 'shape' in data:
                data.pop('shape')
            
            eventarea = EventareaService.create_eventarea(data)
            serializer = self.get_serializer(eventarea)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """
        完整更新活动区域（不包括shape）
        """
        try:
            # 创建request.data的可变副本
            data = request.data.copy()
            
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            eventarea = EventareaService.update_eventarea(pk, data)
            serializer = self.get_serializer(eventarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """
        部分更新活动区域（不包括shape）
        """
        try:
            # 创建request.data的可变副本
            data = request.data.copy()
            
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            eventarea = EventareaService.update_eventarea(pk, data)
            serializer = self.get_serializer(eventarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """
        删除指定活动区域
        """
        try:
            EventareaService.delete_eventarea(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=True, methods=['patch'], url_path='update-floor')
    def update_floor(self, request, pk=None):
        """
        更新活动区域的楼层信息
        
        Args:
            request: 请求对象，可以包含map_id参数和其他活动区域属性
            pk: 活动区域ID
        
        Returns:
            Response: 更新后的活动区域信息
        """
        try:
            updated_data = request.data.copy()
            
            # 如果包含map_id，则更新楼层信息
            if 'map_id' in updated_data:
                new_map_id = updated_data.pop('map_id')
                EventareaService.update_floor(pk, new_map_id)
            
            # 如果还有其他属性，则更新这些属性
            if updated_data:
                # 检查是否包含shape属性，如果包含则返回错误
                if 'shape' in updated_data:
                    return Response(
                        {'error': 'Shape attribute cannot be updated in management module'},
                        status=status.HTTP_400_BAD_REQUEST
                    )
                EventareaService.update_eventarea(pk, updated_data)
            
            # 获取更新后的活动区域
            eventarea = get_object_or_404(EventareaService.get_all_eventareas(), pk=pk)
            serializer = self.get_serializer(eventarea)
            
            return Response(serializer.data, status=status.HTTP_200_OK)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class OtherareaViewSet(viewsets.ModelViewSet):
    """
    其他区域（Otherarea）的视图集
    
    注意：
    - 在management模块中处理除shape属性外的所有其他属性
    - shape属性的操作由editor模块处理
    - 不允许修改shape属性
    
    支持的操作：
    - GET /api/management/otherarea/ - 获取所有其他区域列表
    - GET /api/management/otherarea/{id}/ - 获取指定其他区域详情
    - POST /api/management/otherarea/ - 创建新的其他区域
    - PUT /api/management/otherarea/{id}/ - 完整更新其他区域（不包括shape）
    - PATCH /api/management/otherarea/{id}/ - 部分更新其他区域（不包括shape）
    - DELETE /api/management/otherarea/{id}/ - 删除指定其他区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_otherarea_serializer()
    
    def get_queryset(self):
        """获取所有其他区域"""
        return OtherareaService.get_all_otherareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有其他区域列表"""
        otherareas = OtherareaService.get_all_otherareas()
        serializer = self.get_serializer(otherareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定其他区域详情"""
        otherarea = get_object_or_404(OtherareaService.get_all_otherareas(), pk=pk)
        serializer = self.get_serializer(otherarea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的其他区域"""
        try:
            # 检查是否包含shape属性，如果包含则移除
            data = request.data.copy()
            if 'shape' in data:
                data.pop('shape')
            
            otherarea = OtherareaService.create_otherarea(data)
            serializer = self.get_serializer(otherarea)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """
        完整更新其他区域（不包括shape）
        """
        try:
            # 创建request.data的可变副本
            data = request.data.copy()
            
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            otherarea = OtherareaService.update_otherarea(pk, data)
            serializer = self.get_serializer(otherarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """
        部分更新其他区域（不包括shape）
        """
        try:
            # 创建request.data的可变副本
            data = request.data.copy()
            
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            otherarea = OtherareaService.update_otherarea(pk, data)
            serializer = self.get_serializer(otherarea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """
        删除指定其他区域
        """
        try:
            OtherareaService.delete_otherarea(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=True, methods=['patch'], url_path='update-floor')
    def update_floor(self, request, pk=None):
        """
        更新其他区域的楼层信息
        
        Args:
            request: 请求对象，可以包含map_id参数和其他其他区域属性
            pk: 其他区域ID
        
        Returns:
            Response: 更新后的其他区域信息
        """
        try:
            updated_data = request.data.copy()
            
            # 如果包含map_id，则更新楼层信息
            if 'map_id' in updated_data:
                new_map_id = updated_data.pop('map_id')
                OtherareaService.update_floor(pk, new_map_id)
            
            # 如果还有其他属性，则更新这些属性
            if updated_data:
                # 检查是否包含shape属性，如果包含则返回错误
                if 'shape' in updated_data:
                    return Response(
                        {'error': 'Shape attribute cannot be updated in management module'},
                        status=status.HTTP_400_BAD_REQUEST
                    )
                OtherareaService.update_otherarea(pk, updated_data)
            
            # 获取更新后的其他区域
            otherarea = get_object_or_404(OtherareaService.get_all_otherareas(), pk=pk)
            serializer = self.get_serializer(otherarea)
            
            return Response(serializer.data, status=status.HTTP_200_OK)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class EventViewSet(viewsets.ModelViewSet):
    """
    活动（Event）的视图集
    
    支持的操作：
    - GET /api/management/event/ - 获取所有活动列表
    - GET /api/management/event/{id}/ - 获取指定活动详情
    - POST /api/management/event/ - 创建新的活动
    - PUT /api/management/event/{id}/ - 完整更新活动
    - PATCH /api/management/event/{id}/ - 部分更新活动
    - DELETE /api/management/event/{id}/ - 删除指定活动
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_event_serializer()
    
    def get_queryset(self):
        """获取所有活动"""
        return EventService.get_all_events()
    
    def list(self, request, *args, **kwargs):
        """获取所有活动列表"""
        events = EventService.get_all_events()
        serializer = self.get_serializer(events, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定活动详情"""
        event = get_object_or_404(EventService.get_all_events(), pk=pk)
        serializer = self.get_serializer(event)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的活动"""
        try:
            event = EventService.create_event(request.data)
            serializer = self.get_serializer(event)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """完整更新活动"""
        try:
            event = EventService.update_event(pk, request.data)
            serializer = self.get_serializer(event)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """部分更新活动"""
        try:
            event = EventService.update_event(pk, request.data)
            serializer = self.get_serializer(event)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """删除指定活动"""
        try:
            EventService.delete_event(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class StoreareaViewSet(viewsets.ModelViewSet):
    """
    店铺区域（Storearea）的视图集
    
    注意：
    - 不处理shape属性，该属性由editor模块处理
    
    支持的操作：
    - GET /api/management/storearea/ - 获取所有店铺区域列表
    - GET /api/management/storearea/{id}/ - 获取指定店铺区域详情
    - POST /api/management/storearea/ - 创建新的店铺区域
    - PUT /api/management/storearea/{id}/ - 完整更新店铺区域（不包括shape）
    - PATCH /api/management/storearea/{id}/ - 部分更新店铺区域（不包括shape）
    - DELETE /api/management/storearea/{id}/ - 删除指定店铺区域
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_storearea_serializer()
    
    def get_queryset(self):
        """获取所有店铺区域"""
        return StoreareaService.get_all_storeareas()
    
    def list(self, request, *args, **kwargs):
        """获取所有店铺区域列表"""
        storeareas = StoreareaService.get_all_storeareas()
        serializer = self.get_serializer(storeareas, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定店铺区域详情"""
        storearea = get_object_or_404(StoreareaService.get_all_storeareas(), pk=pk)
        serializer = self.get_serializer(storearea)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的店铺区域"""
        try:
            # 检查是否包含shape属性，如果包含则移除
            data = request.data.copy()
            if 'shape' in data:
                data.pop('shape')
            
            storearea = StoreareaService.create_storearea(data)
            serializer = self.get_serializer(storearea)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """
        完整更新店铺区域（不包括shape）
        """
        try:
            # 创建request.data的可变副本
            data = request.data.copy()
            
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            storearea = StoreareaService.update_storearea(pk, data)
            serializer = self.get_serializer(storearea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """
        部分更新店铺区域（不包括shape）
        """
        try:
            # 创建request.data的可变副本
            data = request.data.copy()
            
            # 检查是否包含shape属性，如果包含则返回错误
            if 'shape' in data:
                return Response(
                    {'error': 'Shape attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            storearea = StoreareaService.update_storearea(pk, data)
            serializer = self.get_serializer(storearea)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """
        删除指定店铺区域
        """
        try:
            StoreareaService.delete_storearea(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=True, methods=['patch'], url_path='update-floor')
    def update_floor(self, request, pk=None):
        """
        更新店铺区域的楼层信息
        
        Args:
            request: 请求对象，可以包含map_id参数和其他店铺区域属性
            pk: 店铺区域ID
        
        Returns:
            Response: 更新后的店铺区域信息
        """
        try:
            updated_data = request.data.copy()
            
            # 如果包含map_id，则更新楼层信息
            if 'map_id' in updated_data:
                new_map_id = updated_data.pop('map_id')
                StoreareaService.update_floor(pk, new_map_id)
            
            # 如果还有其他属性，则更新这些属性
            if updated_data:
                # 检查是否包含shape属性，如果包含则返回错误
                if 'shape' in updated_data:
                    return Response(
                        {'error': 'Shape attribute cannot be updated in management module'},
                        status=status.HTTP_400_BAD_REQUEST
                    )
                StoreareaService.update_storearea(pk, updated_data)
            
            # 获取更新后的店铺区域
            storearea = get_object_or_404(StoreareaService.get_all_storeareas(), pk=pk)
            serializer = self.get_serializer(storearea)
            
            return Response(serializer.data, status=status.HTTP_200_OK)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class FacilityViewSet(viewsets.ModelViewSet):
    """
    设施（Facility）的视图集
    
    注意：
    - 在management模块中处理除location属性外的所有其他属性
    - location属性的操作由editor模块处理
    - 不允许修改location属性
    
    支持的操作：
    - GET /api/management/facility/ - 获取所有设施列表
    - GET /api/management/facility/{id}/ - 获取指定设施详情
    - POST /api/management/facility/ - 创建新的设施
    - PUT /api/management/facility/{id}/ - 完整更新设施（不包括location）
    - PATCH /api/management/facility/{id}/ - 部分更新设施（不包括location）
    - DELETE /api/management/facility/{id}/ - 删除指定设施
    """
    
    def get_serializer_class(self):
        """获取序列化器类"""
        return get_facility_serializer()
    
    def get_queryset(self):
        """获取所有设施"""
        return FacilityService.get_all_facilities()
    
    def list(self, request, *args, **kwargs):
        """获取所有设施列表"""
        facilities = FacilityService.get_all_facilities()
        serializer = self.get_serializer(facilities, many=True)
        return Response(serializer.data)
    
    def retrieve(self, request, pk=None):
        """获取指定设施详情"""
        facility = get_object_or_404(FacilityService.get_all_facilities(), pk=pk)
        serializer = self.get_serializer(facility)
        return Response(serializer.data)
    
    def create(self, request, *args, **kwargs):
        """创建新的设施"""
        try:
            # 检查是否包含location属性，如果包含则移除
            data = request.data.copy()
            if 'location' in data:
                data.pop('location')
            
            facility = FacilityService.create_facility(data)
            serializer = self.get_serializer(facility)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def update(self, request, pk=None):
        """
        完整更新设施（不包括location）
        """
        try:
            # 创建request.data的可变副本
            data = request.data.copy()
            
            # 检查是否包含location属性，如果包含则返回错误
            if 'location' in data:
                return Response(
                    {'error': 'Location attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            facility = FacilityService.update_facility(pk, data)
            serializer = self.get_serializer(facility)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def partial_update(self, request, pk=None):
        """
        部分更新设施（不包括location）
        """
        try:
            # 创建request.data的可变副本
            data = request.data.copy()
            
            # 检查是否包含location属性，如果包含则返回错误
            if 'location' in data:
                return Response(
                    {'error': 'Location attribute cannot be updated in management module'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            facility = FacilityService.update_facility(pk, data)
            serializer = self.get_serializer(facility)
            return Response(serializer.data)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def destroy(self, request, pk=None):
        """
        删除指定设施
        """
        try:
            FacilityService.delete_facility(pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=True, methods=['patch'], url_path='update-floor')
    def update_floor(self, request, pk=None):
        """
        更新设施的楼层信息
        
        Args:
            request: 请求对象，可以包含map_id参数和其他设施属性
            pk: 设施ID
        
        Returns:
            Response: 更新后的设施信息
        """
        try:
            updated_data = request.data.copy()
            
            # 如果包含map_id，则更新楼层信息
            if 'map_id' in updated_data:
                new_map_id = updated_data.pop('map_id')
                FacilityService.update_floor(pk, new_map_id)
            
            # 如果还有其他属性，则更新这些属性
            if updated_data:
                # 检查是否包含location属性，如果包含则返回错误
                if 'location' in updated_data:
                    return Response(
                        {'error': 'Location attribute cannot be updated in management module'},
                        status=status.HTTP_400_BAD_REQUEST
                    )
                FacilityService.update_facility(pk, updated_data)
            
            # 获取更新后的设施
            facility = get_object_or_404(FacilityService.get_all_facilities(), pk=pk)
            serializer = self.get_serializer(facility)
            
            return Response(serializer.data, status=status.HTTP_200_OK)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class AdminAuthMixin:
    """一个简单的用于检查管理员登录状态并加载 Admin 实例的 Mixin"""
    @staticmethod
    def get_admin_user(request: HttpRequest) -> Admin | None:
        admin_id = request.session.get('admin_id')
        if admin_id:
            try:
                # 使用 BaseContext 或 AdminContext 获取实例
                return BaseContext(Admin).get_by_id(admin_id)
            except Admin.DoesNotExist:
                del request.session['admin_id']  # 清理过期会话
                return None
        return None


class AdminAuthView(APIView):
    """
    处理管理员的注册、登录、注销
    POST /api/management/auth/register/
    POST /api/management/auth/login/
    POST /api/management/auth/logout/
    """
    service_class = AdminService

    def post(self, request, action):
        service = self.service_class()

        if action == 'register':
            serializer = AdminRegisterSerializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            try:
                admin = service.register_admin(**serializer.validated_data)
                return Response(AdminProfileSerializer(admin).data, status=status.HTTP_201_CREATED)
            except ValidationError as e:
                return Response({"error": e.message}, status=status.HTTP_400_BAD_REQUEST)

        elif action == 'login':
            serializer = AdminLoginSerializer(data=request.data)
            serializer.is_valid(raise_exception=True)

            admin = service.login_admin(**serializer.validated_data)

            if admin:
                # 登录成功：在 session 中设置 ID
                request.session['admin_id'] = admin.id
                return Response(AdminProfileSerializer(admin).data, status=status.HTTP_200_OK)
            else:
                return Response({"error": "Invalid account or password"}, status=status.HTTP_401_UNAUTHORIZED)

        elif action == 'logout':
            if 'admin_id' in request.session:
                del request.session['admin_id']  # 清除 session
            return Response({"message": "Logout successful"}, status=status.HTTP_200_OK)

        else:
            return Response({"error": "Invalid action"}, status=status.HTTP_400_BAD_REQUEST)


# --- 个人信息接口 ---
class AdminProfileView(AdminAuthMixin, APIView):
    """
    处理管理员个人信息的获取和修改
    GET /api/management/profile/
    PUT/PATCH /api/management/profile/
    """
    service_class = AdminService
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.admin_user = None # 初始化实例属性
        
    def dispatch(self, request, *args, **kwargs):
        # 在处理请求前，先检查登录状态并加载 Admin 实例
        self.admin_user = self.get_admin_user(request)
        if not self.admin_user:
            return Response({"error": "Authentication credentials were not provided."},
                            status=status.HTTP_401_UNAUTHORIZED)
        return super().dispatch(request, *args, **kwargs)

    def get(self, request):
        """获取当前登录管理员的个人信息"""
        # self.admin_user 已在 dispatch 中加载并验证
        return Response(AdminProfileSerializer(self.admin_user).data)

    def put(self, request):
        """修改当前登录管理员的个人信息 (PUT/PATCH 通用)"""
        serializer = AdminUpdateSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        service = self.service_class()

        updated_admin = service.update_profile(
            admin_instance=self.admin_user,
            name=serializer.validated_data.get('name'),
            new_password=serializer.validated_data.get('new_password')
        )

        return Response(AdminProfileSerializer(updated_admin).data, status=status.HTTP_200_OK)


================================================================================
文件路径: python-backend\management\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\management\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\map\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\map\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig



class MapConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'map'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\map\context.py
--------------------------------------------------------------------------------

from core.models import Map, Storearea, Facility, Otherarea, Eventarea
from django.db.models import Q
from core.context import BaseContext


class MapContext(BaseContext):
    def __init__(self):
        super().__init__(Map)

    def get_map_with_building(self, map_id):
        """获取地图并预加载建筑信息"""
        try:
            return self.model.objects.select_related('building').get(pk=map_id)
        except self.model.DoesNotExist:
            return None

    @staticmethod
    def get_map_elements(map_obj):
        """一次性获取地图关联的所有元素 ID"""
        store_ids = map_obj.storeareamap_set.values_list('storearea_id', flat=True)
        facility_ids = map_obj.facilitymap_set.values_list('facility_id', flat=True)
        other_ids = map_obj.otherareamap_set.values_list('otherarea_id', flat=True)
        event_ids = map_obj.eventareamap_set.values_list('eventarea_id', flat=True)
        return store_ids, facility_ids, other_ids, event_ids

    def list_all_with_building(self):
        """获取所有地图列表，并预加载建筑信息"""
        return self.model.objects.select_related('building').all()

    def check_exists(self, building_id, floor_number):
        """检查特定楼层是否存在"""
        return self.model.objects.filter(building_id=building_id, floor_number=floor_number).exists()

    def create_map_record(self, building_id, floor_number, geometry):
        """创建地图记录"""
        return self.create(
            building_id=building_id,
            floor_number=floor_number,
            detail=geometry
        )

    def delete_map(self, map_id):
        """删除地图"""
        self.model.objects.filter(pk=map_id).delete()

class ElementContext:
    """负责处理具体的商铺、设施等元素"""

    @staticmethod
    def get_stores_by_ids(ids):
        return Storearea.objects.filter(id__in=ids)

    @staticmethod
    def get_facilities_by_ids(ids):
        return Facility.objects.filter(id__in=ids)

    @staticmethod
    def get_others_by_ids(ids):
        return Otherarea.objects.filter(id__in=ids)

    @staticmethod
    def get_events_by_ids(ids):
        return Eventarea.objects.filter(id__in=ids)

    @staticmethod
    def search_globally(keyword):
        stores = Storearea.objects.filter(store_name__icontains=keyword)
        others = Otherarea.objects.filter(description__icontains=keyword, is_public=True)
        return stores, others


================================================================================
文件路径: python-backend\map\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from core.models import Map, Storearea, Facility, Otherarea, Eventarea
import json

"""
子元素序列化器 (供 MapSerializer 调用)
"""

class OtherareaSerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Otherarea
        # 将 is_public 暴露出来，前端可以用不同颜色渲染
        fields = ['id', 'type', 'description', 'is_public',  'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.shape: return None
        return json.loads(obj.shape.geojson)


class StoreareaSerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Storearea
        fields = ['id', 'store_name', 'type', 'logo_url', 'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.shape: return None
        return json.loads(obj.shape.geojson)


class FacilitySerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Facility
        fields = ['id', 'type', 'description', 'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.location: return None
        return json.loads(obj.location.geojson)


class EventareaSerializer(serializers.ModelSerializer):
    geometry = serializers.SerializerMethodField()

    class Meta:
        model = Eventarea
        fields = ['id', 'description',  'type', 'is_active', 'geometry']

    @staticmethod
    def get_geometry(obj):
        if not obj.shape: return None
        return json.loads(obj.shape.geojson)


"""
地图聚合序列化器 (核心修改部分)
"""

class MapSerializer(serializers.ModelSerializer):
    """
    地图详情：包含该楼层的底图几何信息，以及关联的商铺、设施等。
    """
    building_name = serializers.CharField(source='building.name', read_only=True)
    detail_geojson = serializers.SerializerMethodField()

    # 对应 MapDisplayService 中挂载的属性名
    # 这些字段只用于输出，不用于写入
    stores = StoreareaSerializer(source='temp_stores', many=True, read_only=True)
    facilities = FacilitySerializer(source='temp_facilities', many=True, read_only=True)
    other_areas = OtherareaSerializer(source='temp_others', many=True, read_only=True)
    events = EventareaSerializer(source='temp_events', many=True, read_only=True)


    class Meta:
        model = Map
        fields = [
            'id',
            'building_id',
            'building_name',
            'floor_number',
            'detail_geojson',
            'stores',
            'facilities',
            'other_areas',
            'events'
        ]

    @staticmethod
    def get_detail_geojson(obj):
        """
        处理底图几何 (外轮廓 + 镂空)
        """
        if not obj.detail:
            return None

        # 保持原始坐标系 (SRID 2385)，方便前端计算米制距离
        geometry = obj.detail.clone()
        return json.loads(geometry.geojson)


================================================================================
文件路径: python-backend\map\services.py
--------------------------------------------------------------------------------

from django.contrib.gis.geos import GEOSGeometry, Polygon
from typing import Tuple, List
from map.context import MapContext, ElementContext
import json
from django.contrib.gis.geos import GEOSGeometry


"""
Part 1: 纯几何算法
"""

class GeometryAlgorithms:
    @staticmethod
    def validate_shape_syntax(geometry: GEOSGeometry) -> Tuple[bool, str]:
        if geometry is None: return False, "Geometry is None"
        if not geometry.valid: return False, f"Invalid Geometry: {geometry.valid_reason}"
        if isinstance(geometry, Polygon) and geometry.empty: return False, "Polygon is empty"
        return True, "Valid"

    @staticmethod
    def get_distance_between_areas(shape1: GEOSGeometry, shape2: GEOSGeometry) -> float:
        """
        接口 3: 获取输入的两个区域之间的距离
        """
        if not shape1 or not shape2:
            return -1.0
        # distance() 计算的是两个几何体之间最近点的欧几里得距离
        # 单位取决于 SRID (2385 为米)
        return shape1.distance(shape2)

    @staticmethod
    def validate_holes_inside_shell(outer_shell: GEOSGeometry, holes: List[GEOSGeometry]) -> Tuple[bool, str]:
        """
        接口 2: 镂空本身有无超出外轮廓区域
        """
        if not outer_shell:
            return False, "Outer shell is missing"

        if not holes:
            return True, "No holes to validate"

        for i, hole in enumerate(holes, start=1):
            # hole 必须完全在 outer_shell 内部 (contains)
            # 任何一部分超出或仅仅是相交都算非法
            if not outer_shell.contains(hole):
                return False, f"Hole #{i} is outside or intersecting the map boundary."

        return True, "All holes are valid"

    @staticmethod
    def check_placement(new_shape, outer_shell, holes, existing_obstacles):
        if not outer_shell: return False, "Map shell missing"
        if not outer_shell.contains(new_shape): return False, "Area exceeds map outer boundary"
        for i, hole in enumerate(holes):
            if hole.intersects(new_shape): return False, f"Area intersects with map hole #{i + 1}"
        for existing_shape in existing_obstacles:
            if existing_shape and existing_shape.intersects(new_shape):
                return False, "Area overlaps with an existing area"
        return True, "Placement valid"


"""
Part 2: 业务服务 (修改部分)
"""

class MapDisplayService:
    """
    地图显示与校验服务
    """

    def __init__(self):
        self.map_ctx = MapContext()
        self.elem_ctx = ElementContext()

    def get_full_map_details(self, map_id):
        map_obj = self.map_ctx.get_map_with_building(map_id)
        if not map_obj: return None

        s_ids, f_ids, o_ids, e_ids = self.map_ctx.get_map_elements(map_obj)

        map_obj.temp_stores = self.elem_ctx.get_stores_by_ids(s_ids)
        map_obj.temp_facilities = self.elem_ctx.get_facilities_by_ids(f_ids)
        map_obj.temp_others = self.elem_ctx.get_others_by_ids(o_ids)
        map_obj.temp_events = self.elem_ctx.get_events_by_ids(e_ids)

        return map_obj

    def validate_geometry(self, geometry, map_id, exclude_id=None, area_type=None):
        """
        几何校验业务流程
        """
        # 1. 几何语法校验
        is_valid, msg = GeometryAlgorithms.validate_shape_syntax(geometry)
        if not is_valid:
            return False, msg

        # 2. 获取地图数据
        map_obj = self.map_ctx.get_map_with_building(map_id)
        if not map_obj or not map_obj.detail:
            return False, "Map data not found or empty"

        # 解析外轮廓和镂空
        outer_shell = map_obj.detail[0]
        holes = list(map_obj.detail[1:]) if len(map_obj.detail) > 1 else []

        # 3. 获取所有障碍物
        obstacles = self._collect_obstacles(map_obj, exclude_id, area_type)

        # 4. 调用算法进行物理放置校验
        return GeometryAlgorithms.check_placement(
            new_shape=geometry,
            outer_shell=outer_shell,
            holes=holes,
            existing_obstacles=obstacles
        )

    def _collect_obstacles(self, map_obj, exclude_id, area_type) -> List[GEOSGeometry]:
        """
        私有辅助方法：利用 MapContext 和 ElementContext 收集该地图上所有实体的形状
        """
        obstacles = []

        # 1. 从 MapContext 获取所有关联 ID
        s_ids, f_ids, o_ids, e_ids = self.map_ctx.get_map_elements(map_obj)

        # 辅助函数：处理排除逻辑
        def should_include(item_id, item_type):
            # 如果类型相同且 ID 相同，则排除
            if area_type == item_type and str(item_id) == str(exclude_id):
                return False
            return True

        # 2. 从 ElementContext 获取对象并提取形状

        # A. 商铺 (Stores)
        stores = self.elem_ctx.get_stores_by_ids(s_ids)
        for s in stores:
            if should_include(s.id, 'store') and s.shape:
                obstacles.append(s.shape)

        # B. 设施 (Facilities) - 需要 Buffer 处理
        facilities = self.elem_ctx.get_facilities_by_ids(f_ids)
        for f in facilities:
            if should_include(f.id, 'facility') and f.location:
                # 设施通常是点，必须膨胀成多边形才能进行碰撞检测
                # 假设半径 0.5 米
                obstacles.append(f.location.buffer(0.5))

        # C. 其他区域 (Otherareas)
        others = self.elem_ctx.get_others_by_ids(o_ids)
        for o in others:
            if should_include(o.id, 'other') and o.shape:
                obstacles.append(o.shape)

        # D. 活动区域 (Events)
        events = self.elem_ctx.get_events_by_ids(e_ids)
        for e in events:
            if should_include(e.id, 'event') and e.shape and e.is_active:
                obstacles.append(e.shape)

        return obstacles

    def get_map_list(self):
        """
        获取地图列表概要
        """
        # 1. 从 Context 获取所有地图
        maps = self.map_ctx.list_all_with_building()

        # 2. 初始化空属性，防止 MapSerializer 报错
        for map_obj in maps:
            map_obj.temp_stores = []
            map_obj.temp_facilities = []
            map_obj.temp_others = []
            map_obj.temp_events = []

        return maps

    def validate_batch(self, map_id, updates_list):
        """
        批量校验
        :param map_id: 地图ID
        :param updates_list: 预处理过的列表，每项包含 'geos_obj' (GEOSGeometry)
        :return: (is_valid, errors_list)
        """
        # 1. 获取地图底图 (外框和镂空)
        map_obj = self.map_ctx.get_map_with_building(map_id)
        if not map_obj or not map_obj.detail:
            return False, ["地图数据缺失"]

        outer_shell = map_obj.detail[0]
        holes = list(map_obj.detail[1:]) if len(map_obj.detail) > 1 else []

        # 2. 整理新数据 (不再需要解析 JSON，直接取对象)
        new_geometries = []
        updated_keys = set()

        for item in updates_list:
            # 直接获取 View 层解析好的几何对象
            shape = item['geos_obj']

            # 统一为多边形用于碰撞检测 (点 -> 圆)
            collision_shape = shape.buffer(0.3) if shape.geom_type == 'Point' else shape

            item_type = str(item.get('type')).lower()
            item_id = str(item.get('id'))

            new_geometries.append({
                'id': item_id,
                'type': item_type,
                'shape': collision_shape,
                'name': item.get('name', 'Unknown')
            })

            key = f"{item_type}-{item_id}"
            updated_keys.add(key)

        # 3. 从数据库获取“背景障碍物” (排除掉在 updated_keys 里的项)
        s_ids, f_ids, o_ids, e_ids = self.map_ctx.get_map_elements(map_obj)
        static_obstacles = []

        def add_static(objects, type_name):
            for obj in objects:
                key = f"{type_name}-{str(obj.id)}"
                if key not in updated_keys:
                    shape = getattr(obj, 'shape', None)
                    if type_name == 'facility':
                        loc = getattr(obj, 'location', None)
                        if loc: shape = loc.buffer(0.3)

                    if shape:
                        static_obstacles.append(shape)

        add_static(self.elem_ctx.get_stores_by_ids(s_ids), 'store')
        add_static(self.elem_ctx.get_facilities_by_ids(f_ids), 'facility')
        add_static(self.elem_ctx.get_others_by_ids(o_ids), 'other')
        active_events = [e for e in self.elem_ctx.get_events_by_ids(e_ids) if e.is_active]
        add_static(active_events, 'event')

        # 4. 执行校验
        errors = []

        for curr in new_geometries:
            curr_shape = curr['shape']

            # 4.1 边界检查
            if not outer_shell.contains(curr_shape):
                errors.append(f"[{curr['name']}] 超出地图边界")
                continue

            for hole in holes:
                if hole.intersects(curr_shape) and not hole.touches(curr_shape):
                    errors.append(f"[{curr['name']}] 进入了地图镂空/中庭区域")
                    break

            # 4.2 静态障碍物碰撞
            for obs in static_obstacles:
                if obs.intersects(curr_shape) and not obs.touches(curr_shape):
                    errors.append(f"[{curr['name']}] 与未修改的固定区域重叠")
                    break

            # 4.3 动态物体互撞 (A 撞 B)
            for other in new_geometries:
                if curr['id'] == other['id'] and curr['type'] == other['type']:
                    continue

                if curr['type'] == 'facility' and other['type'] == 'facility':
                    continue

                if other['shape'].intersects(curr_shape) and not other['shape'].touches(curr_shape):
                    if curr['id'] < other['id']:
                        errors.append(f"[{curr['name']}] 与 [{other['name']}] 重叠")
                    break

        if len(errors) > 0:
            return False, errors

        return True, []


================================================================================
文件路径: python-backend\map\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.
from rest_framework.test import APITestCase
from rest_framework import status
from django.urls import reverse
from django.contrib.gis.geos import Polygon, GeometryCollection
from core.models import Building, Map, Storearea, StoreareaMap


class MapViewSetTestCase(APITestCase):
    """
    测试 MapViewSet 的 list 和 retrieve 接口
    验证从数据库到 Service 再到 View 的数据流是否正常
    """

    def setUp(self):
        """
        测试数据准备：
        1. 创建 Building
        2. 创建 Map (带 GeometryCollection)
        3. 创建 Storearea (带 Polygon)
        4. 建立 Map 和 Storearea 的关联
        """
        # 1. 创建建筑
        self.building = Building.objects.create(
            name="测试万达广场",
            address="上海市杨浦区"
        )

        # 2. 创建地图底图几何 (SRID 2385)
        # 假设是一个 100x100 的正方形外轮廓
        outer_shell = Polygon(((0, 0), (0, 100), (100, 100), (100, 0), (0, 0)), srid=2385)
        # detail 字段是 GeometryCollection
        map_detail = GeometryCollection(outer_shell, srid=2385)

        self.map_obj = Map.objects.create(
            building=self.building,
            floor_number=1,
            detail=map_detail
        )

        # 3. 创建商铺
        # 在地图内部创建一个 10x10 的小方块商铺
        store_shape = Polygon(((10, 10), (10, 20), (20, 20), (20, 10), (10, 10)), srid=2385)
        self.store = Storearea.objects.create(
            store_name="测试海底捞",
            type=1,
            shape=store_shape,
            owner_name="张三",
            owner_phone="123456",
            is_active = True
        )

        # 4. 关联商铺到地图
        StoreareaMap.objects.create(
            map=self.map_obj,
            storearea=self.store
        )

        self.list_url = reverse('map-list')
        self.detail_url = reverse('map-detail', args=[self.map_obj.id])

    def test_list_maps(self):
        """
        测试获取地图列表 (GET /api/maps/)
        """
        response = self.client.get(self.list_url)

        # 1. 验证状态码
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        # 2. 验证返回数据类型是列表
        self.assertIsInstance(response.data, list)
        self.assertEqual(len(response.data), 1)

        # 3. 验证基础字段
        map_data = response.data[0]
        self.assertEqual(map_data['floor_number'], 1)
        self.assertEqual(map_data['building_name'], "测试万达广场")

        # 4. 验证列表接口是否正确处理了 temp_stores
        if 'stores' in map_data:
            self.assertIsInstance(map_data['stores'], list)

    def test_retrieve_map_success(self):
        """
        测试获取单张地图详情 (GET /api/maps/{id}/)
        核心：验证 Service 是否成功组装了 detail_geojson 和 stores
        """
        response = self.client.get(self.detail_url)

        # 1. 验证状态码
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        data = response.data

        # 2. 验证底图几何 (detail_geojson)
        self.assertIn('detail_geojson', data)
        self.assertEqual(data['detail_geojson']['type'], 'GeometryCollection')

        # 3. 验证关联元素 (stores)
        # 这是验证 MapDisplayService.get_full_map_details 逻辑的关键
        self.assertIn('stores', data)
        self.assertEqual(len(data['stores']), 1)

        store_data = data['stores'][0]
        self.assertEqual(store_data['store_name'], "测试海底捞")
        self.assertEqual(store_data['id'], self.store.id)

        # 验证商铺的几何是否被正确序列化为 GeoJSON
        self.assertIn('geometry', store_data)
        self.assertEqual(store_data['geometry']['type'], 'Polygon')

        # 4. 验证其他空列表字段是否存在 (facilities, events, etc.)
        self.assertIn('facilities', data)
        self.assertEqual(data['facilities'], [])  # setUp中没创建设施，应为空列表

    def test_retrieve_map_not_found(self):
        """
        测试获取不存在的地图 ID
        """
        non_existent_url = reverse('map-detail', args=[99999])
        response = self.client.get(non_existent_url)

        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)


================================================================================
文件路径: python-backend\map\views.py
--------------------------------------------------------------------------------

from rest_framework import viewsets, status
from rest_framework.views import APIView
from rest_framework.response import Response
from django.contrib.gis.geos import GEOSGeometry
import json

from .serializers import MapSerializer  # 序列化器依然需要，用于格式化输出
from map.services import MapDisplayService


class MapViewSet(viewsets.ViewSet):
    """
    只读 ViewSet，不继承 ModelViewSet
    """
    service_class = MapDisplayService

    def list(self, request):
        """GET /api/maps/"""
        service = self.service_class()

        # 1. 调用 Service 获取列表
        maps = service.get_map_list()

        # 2. 序列化返回
        serializer = MapSerializer(maps, many=True)

        return Response(serializer.data)

    def retrieve(self, request, pk=None):
        """GET /api/maps/{id}/"""
        service = self.service_class()

        # 1. 调用 Service 获取组装好的对象
        map_data = service.get_full_map_details(pk)

        if not map_data:
            return Response({"error": "Map not found"}, status=status.HTTP_404_NOT_FOUND)

        # 2. 使用 Serializer 格式化 Service 返回的数据
        serializer = MapSerializer(map_data)
        return Response(serializer.data)


class MapValidationView(APIView):
    """POST /api/maps/validate/"""
    service_class = MapDisplayService

    def post(self, request):
        service = self.service_class()

        # 1. 参数提取
        geometry_data = request.data.get('geometry')
        map_id = request.data.get('map_id')
        area_type = request.data.get('type')
        exclude_id = request.data.get('exclude_id')

        # 2. 数据预处理
        try:
            shape_str = json.dumps(geometry_data) if isinstance(geometry_data, dict) else geometry_data
            shape = GEOSGeometry(shape_str)
            if shape.srid != 2385: shape.srid = 2385
        except Exception:
            return Response({"error": "Invalid Geometry"}, status=400)

        # 3. 调用 Service 业务逻辑
        is_valid, reason = service.validate_geometry(shape, map_id, exclude_id, area_type)

        return Response({"valid": is_valid, "reason": reason})


class MapBatchValidationView(APIView):
    """POST /api/maps/validate_batch/ (批量校验)"""
    service_class = MapDisplayService

    def post(self, request):
        service = self.service_class()

        map_id = request.data.get('map_id')
        updates = request.data.get('updates', [])

        if not map_id:
            return Response({"error": "map_id is required"}, status=status.HTTP_400_BAD_REQUEST)

        # 数据预处理：在 View 层统一解析几何并修正 SRID
        processed_updates = []
        for i, item in enumerate(updates):
            try:
                # 1. 提取原始数据
                raw_geo = item.get('geometry') or item.get('location')
                if not raw_geo: continue

                # 2. 转字符串
                shape_str = json.dumps(raw_geo) if isinstance(raw_geo, dict) else raw_geo

                # 3. 解析几何
                shape = GEOSGeometry(shape_str)

                # 4. 强制修正 SRID (与 MapValidationView 保持一致)
                if shape.srid != 2385:
                    shape.srid = 2385

                # 5. 将处理好的 GEOSGeometry 对象注入 item
                item['geos_obj'] = shape
                processed_updates.append(item)

            except Exception as e:
                # 如果解析失败，直接返回 400，中断处理
                return Response(
                    {"error": f"Invalid geometry at index {i} (ID: {item.get('id')}): {str(e)}"},
                    status=status.HTTP_400_BAD_REQUEST
                )

        # 调用 Service，传入包含 GEOSGeometry 对象的列表
        is_valid, errors = service.validate_batch(map_id, processed_updates)

        return Response({
            "valid": is_valid,
            "errors": errors
        })


================================================================================
文件路径: python-backend\map\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\map\migrations\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\python_backend\settings.py
--------------------------------------------------------------------------------

"""
Django settings for python_backend project.

Based on by 'django-admin startproject' using Django 2.1.2.

For more information on this file, see
https://docs.djangoproject.com/en/2.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/2.1/ref/settings/
"""

import os
import posixpath

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/2.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = '7306ec88-3719-40e9-88d4-2d6fdee59734'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ['*']

# Application references
# https://docs.djangoproject.com/en/2.1/ref/settings/#std:setting-INSTALLED_APPS
INSTALLED_APPS = [
    # Add your apps here to enable them
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.gis',
    'rest_framework',
    'django_filters',
    # 支持跨域请求
    'corsheaders',
    'core.apps.CoreConfig',
    'map.apps.MapConfig',
    'client.apps.ClientConfig',
    'management.apps.ManagementConfig',
    'search.apps.SearchConfig',
    'guide.apps.GuideConfig',
    'editor.apps.EditorConfig'
]

# Middleware framework
# https://docs.djangoproject.com/en/2.1/topics/http/middleware/
MIDDLEWARE = [
    # CORS middleware should be placed as high as possible
    'corsheaders.middleware.CorsMiddleware',
    # 注意：确保 CommonMiddleware 仍然在 CorsMiddleware 之后
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'python_backend.urls'

# Template configuration
# https://docs.djangoproject.com/en/2.1/topics/templates/
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'python_backend.wsgi.application'

# Database
# https://docs.djangoproject.com/en/2.1/ref/settings/#databases
DATABASES = {
    'default': {
        'ENGINE': 'django.contrib.gis.db.backends.postgis',
        'NAME': os.environ.get('POSTGRES_DB'),
        'USER': os.environ.get('POSTGRES_USER'),
        'PASSWORD': os.environ.get('POSTGRES_PASSWORD'),
        'HOST': 'postgres-db',
        'PORT': '5432',
    }
}

# Password validation
# https://docs.djangoproject.com/en/2.1/ref/settings/#auth-password-validators
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Internationalization
# https://docs.djangoproject.com/en/2.1/topics/i18n/
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_L10N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/2.1/howto/static-files/
STATIC_URL = '/static/'
STATIC_ROOT = posixpath.join(*(BASE_DIR.split(os.path.sep) + ['static']))

REST_FRAMEWORK = {
    # 默认权限设置：这里设置为默认需要登录才能访问，方便后续开发
    'DEFAULT_PERMISSION_CLASSES': [
        # 'rest_framework.permissions.IsAuthenticated',
        # 如果是开发初期想全部公开，可以改为:
        'rest_framework.permissions.AllowAny',
    ],

    # 默认认证方式
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
    ],

    # 默认分页设置 (推荐配置，防止大数据量查死数据库)
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,

    # 统一日期格式 (可选)
    'DATETIME_FORMAT': '%Y-%m-%d %H:%M:%S',
}

# CORS 设置（开发环境方便测试，生产请按需限制）
CORS_ALLOWED_ORIGINS = [
  "http://localhost:8080"
]
CORS_ALLOW_CREDENTIALS = True
# 可根据需要自定义允许的头、方法
# CORS_ALLOW_HEADERS = list(default_headers) + [
#     'your-custom-header',
# ]



================================================================================
文件路径: python-backend\python_backend\urls.py
--------------------------------------------------------------------------------

"""
python_backend URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/2.1/topics/http/urls/

Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""

# Uncomment next two lines to enable admin:
from django.contrib import admin
from django.urls import path,include
from rest_framework.routers import DefaultRouter
from map.views import MapViewSet, MapValidationView, MapBatchValidationView

from guide.views import RoutePlanView

from management.views import AdminAuthView, AdminProfileView


router = DefaultRouter()
router.register(r'maps', MapViewSet, basename='map')
urlpatterns = [
    path('search/', include('search.urls')),
    path('api/editor/', include('editor.urls')),
    path('api/management/', include('management.urls')),
    # Uncomment the next line to enable the admin:
    #path('admin/', admin.site.urls)
    path('api/maps/validate/', MapValidationView.as_view(), name='map-validate'),
    path('api/maps/validate_batch/', MapBatchValidationView.as_view(), name='map-validate-batch'),
    path('api/guide/route/',RoutePlanView.as_view(), name='route-plan'),
    path('api/', include(router.urls)),
    path('api/management/auth/<str:action>/', AdminAuthView.as_view(), name='admin-auth'),
    path('api/management/profile/', AdminProfileView.as_view(), name='admin-profile'),
    path('admin/', admin.site.urls),
    path('api/search/', include('search.urls')),
    # 其他URL配置...
]



================================================================================
文件路径: python-backend\python_backend\wsgi.py
--------------------------------------------------------------------------------

"""
WSGI config for python_backend project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

For more information, visit
https://docs.djangoproject.com/en/2.1/howto/deployment/wsgi/
"""

import os

import django
from django.core.wsgi import get_wsgi_application

os.environ.setdefault(
    'DJANGO_SETTINGS_MODULE',
    'python_backend.settings')
django.setup()

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
application = get_wsgi_application()



================================================================================
文件路径: python-backend\python_backend\__init__.py
--------------------------------------------------------------------------------

"""
Package for python_backend.
"""



================================================================================
文件路径: python-backend\search\admin.py
--------------------------------------------------------------------------------

from django.contrib import admin

# Register your models here.



================================================================================
文件路径: python-backend\search\apps.py
--------------------------------------------------------------------------------

from django.apps import AppConfig


class SearchConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'search'

    def ready(self):
        import core.models



================================================================================
文件路径: python-backend\search\context.py
--------------------------------------------------------------------------------

from django.apps import apps
from django.db.models import Q


class BaseSearchContext:
    """基础搜索上下文类"""

    def __init__(self, model_name):
        self.model_name = model_name
        self.model = apps.get_model('core', model_name)


class StoreareaContext(BaseSearchContext):
    """店铺区域上下文"""

    def __init__(self):
        super().__init__('Storearea')

    def get_by_id(self, storearea_id):
        """根据ID获取店铺区域"""
        try:
            return self.model.objects.get(id=storearea_id)
        except self.model.DoesNotExist:
            return None

    def search_by_name(self, name):
        """根据名称搜索店铺区域"""
        return self.model.objects.filter(
            store_name__icontains=name,
            is_active=True
        )

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选店铺区域"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_storearea_map_relations(self, storearea_id):
        """获取店铺区域的地图关联"""
        StoreareaMap = apps.get_model('core', 'StoreareaMap')
        return StoreareaMap.objects.filter(storearea_id=storearea_id)


class EventContext(BaseSearchContext):
    """活动上下文"""

    def __init__(self):
        super().__init__('Event')

    def get_by_id(self, event_id):
        """根据ID获取活动"""
        try:
            return self.model.objects.get(id=event_id)
        except self.model.DoesNotExist:
            return None

    def search_by_name(self, name):
        """根据名称搜索活动"""
        return self.model.objects.filter(
            event_name__icontains=name,
            is_active=True
        )

    def filter_active_events(self):
        """获取所有活跃活动"""
        return self.model.objects.filter(is_active=True)

    def get_event_storearea_relations(self, event_id):
        """获取活动的店铺区域关联"""
        EventStorearea = apps.get_model('core', 'EventStorearea')
        return EventStorearea.objects.filter(event_id=event_id)

    def get_event_eventarea_relations(self, event_id):
        """获取活动的活动区域关联"""
        EventEventarea = apps.get_model('core', 'EventEventarea')
        return EventEventarea.objects.filter(event_id=event_id)


class EventareaContext(BaseSearchContext):
    """活动区域上下文"""

    def __init__(self):
        super().__init__('Eventarea')

    def get_by_id(self, eventarea_id):
        """根据ID获取活动区域"""
        try:
            return self.model.objects.get(id=eventarea_id)
        except self.model.DoesNotExist:
            return None

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选活动区域"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_eventarea_map_relations(self, eventarea_id):
        """获取活动区域的地图关联"""
        EventareaMap = apps.get_model('core', 'EventareaMap')
        return EventareaMap.objects.filter(eventarea_id=eventarea_id)

    def get_eventarea_map_relations_by_map(self, map_id):
        """根据地图ID获取活动区域关联"""
        EventareaMap = apps.get_model('core', 'EventareaMap')
        return EventareaMap.objects.filter(map_id=map_id)


class FacilityContext(BaseSearchContext):
    """设施上下文"""

    def __init__(self):
        super().__init__('Facility')

    def get_by_id(self, facility_id):
        """根据ID获取设施"""
        try:
            return self.model.objects.get(id=facility_id)
        except self.model.DoesNotExist:
            return None

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选设施"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_facility_map_relations(self, facility_id):
        """获取设施的地图关联"""
        FacilityMap = apps.get_model('core', 'FacilityMap')
        return FacilityMap.objects.filter(facility_id=facility_id)

    def get_facility_map_relations_by_map(self, map_id):
        """根据地图ID获取设施关联"""
        FacilityMap = apps.get_model('core', 'FacilityMap')
        return FacilityMap.objects.filter(map_id=map_id)


class OtherareaContext(BaseSearchContext):
    """其他区域上下文"""

    def __init__(self):
        super().__init__('Otherarea')

    def get_by_id(self, otherarea_id):
        """根据ID获取其他区域"""
        try:
            return self.model.objects.get(id=otherarea_id)
        except self.model.DoesNotExist:
            return None

    def filter_by_type(self, type_id=None, is_active=True):
        """根据类型筛选其他区域"""
        queryset = self.model.objects.all()
        if is_active:
            queryset = queryset.filter(is_active=True)
        if type_id is not None:
            queryset = queryset.filter(type=type_id)
        return queryset

    def get_otherarea_map_relations(self, otherarea_id):
        """获取其他区域的地图关联"""
        OtherareaMap = apps.get_model('core', 'OtherareaMap')
        return OtherareaMap.objects.filter(otherarea_id=otherarea_id)

    def get_otherarea_map_relations_by_map(self, map_id):
        """根据地图ID获取其他区域关联"""
        OtherareaMap = apps.get_model('core', 'OtherareaMap')
        return OtherareaMap.objects.filter(map_id=map_id)


class SearchElementContext:
    """搜索元素上下文，用于处理关联关系"""

    @staticmethod
    def get_storearea_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取店铺区域ID"""
        StoreareaMap = apps.get_model('core', 'StoreareaMap')
        Storearea = apps.get_model('core', 'Storearea')

        # 获取该地图的所有storearea关联
        storearea_maps = StoreareaMap.objects.filter(map_id=map_id)
        storearea_ids = [sm.storearea_id for sm in storearea_maps]

        # 如果提供了类型参数，则进一步过滤
        if type_id is not None:
            storeareas = Storearea.objects.filter(
                id__in=storearea_ids,
                type=type_id,
                is_active=True
            )
            storearea_ids = [storearea.id for storearea in storeareas]

        return storearea_ids

    @staticmethod
    def get_eventarea_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取活动区域ID"""
        EventareaMap = apps.get_model('core', 'EventareaMap')
        Eventarea = apps.get_model('core', 'Eventarea')

        eventarea_maps = EventareaMap.objects.filter(map_id=map_id)
        eventarea_ids = [em.eventarea_id for em in eventarea_maps]

        if type_id is not None:
            eventareas = Eventarea.objects.filter(
                id__in=eventarea_ids,
                type=type_id,
                is_active=True
            )
            eventarea_ids = [eventarea.id for eventarea in eventareas]

        return eventarea_ids

    @staticmethod
    def get_facility_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取设施ID"""
        FacilityMap = apps.get_model('core', 'FacilityMap')
        Facility = apps.get_model('core', 'Facility')

        facility_maps = FacilityMap.objects.filter(map_id=map_id)
        facility_ids = [fm.facility_id for fm in facility_maps]

        if type_id is not None:
            facilities = Facility.objects.filter(
                id__in=facility_ids,
                type=type_id,
                is_active=True
            )
            facility_ids = [facility.id for facility in facilities]

        return facility_ids

    @staticmethod
    def get_otherarea_ids_by_map_and_type(map_id, type_id=None):
        """根据地图和类型获取其他区域ID"""
        OtherareaMap = apps.get_model('core', 'OtherareaMap')
        Otherarea = apps.get_model('core', 'Otherarea')

        otherarea_maps = OtherareaMap.objects.filter(map_id=map_id)
        otherarea_ids = [om.otherarea_id for om in otherarea_maps]

        if type_id is not None:
            otherareas = Otherarea.objects.filter(
                id__in=otherarea_ids,
                type=type_id,
                is_active=True
            )
            otherarea_ids = [otherarea.id for otherarea in otherareas]

        return otherarea_ids


================================================================================
文件路径: python-backend\search\serializers.py
--------------------------------------------------------------------------------

from rest_framework import serializers
from django.apps import apps


# 使用延迟加载的方式定义序列化器
def get_storearea_serializer():
    Storearea = apps.get_model('core', 'Storearea')

    class StoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            fields = '__all__'

    return StoreareaSerializer


def get_event_serializer():
    Event = apps.get_model('core', 'Event')

    class EventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            fields = '__all__'

    return EventSerializer


def get_eventarea_serializer():
    Eventarea = apps.get_model('core', 'Eventarea')

    class EventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            fields = '__all__'

    return EventareaSerializer


def get_facility_serializer():
    Facility = apps.get_model('core', 'Facility')

    class FacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            fields = '__all__'

    return FacilitySerializer


def get_otherarea_serializer():
    Otherarea = apps.get_model('core', 'Otherarea')

    class OtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            fields = '__all__'

    return OtherareaSerializer


def get_simple_storearea_serializer():
    Storearea = apps.get_model('core', 'Storearea')

    class SimpleStoreareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Storearea
            fields = ['id', 'store_name', 'type']

    return SimpleStoreareaSerializer


def get_simple_event_serializer():
    Event = apps.get_model('core', 'Event')

    class SimpleEventSerializer(serializers.ModelSerializer):
        class Meta:
            model = Event
            # is_active、description 与 image_url，便于列表接口直接展示启用状态、描述与缩略图
            fields = ['id', 'event_name', 'start_date', 'end_date', 'is_active', 'description', 'image_url']

    return SimpleEventSerializer


def get_simple_eventarea_serializer():
    Eventarea = apps.get_model('core', 'Eventarea')

    class SimpleEventareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Eventarea
            fields = ['id', 'organizer_name', 'type']

    return SimpleEventareaSerializer


def get_simple_facility_serializer():
    Facility = apps.get_model('core', 'Facility')

    class SimpleFacilitySerializer(serializers.ModelSerializer):
        class Meta:
            model = Facility
            fields = ['id', 'type']

    return SimpleFacilitySerializer


def get_simple_otherarea_serializer():
    Otherarea = apps.get_model('core', 'Otherarea')

    class SimpleOtherareaSerializer(serializers.ModelSerializer):
        class Meta:
            model = Otherarea
            fields = ['id', 'type', 'is_public']

    return SimpleOtherareaSerializer



================================================================================
文件路径: python-backend\search\services.py
--------------------------------------------------------------------------------

from rest_framework import status
from django.apps import apps
from .context import (
    StoreareaContext, EventContext, EventareaContext,
    FacilityContext, OtherareaContext, SearchElementContext
)


class SearchService:
    """搜索服务"""

    def __init__(self):
        self.storearea_ctx = StoreareaContext()
        self.event_ctx = EventContext()
        self.eventarea_ctx = EventareaContext()
        self.facility_ctx = FacilityContext()
        self.otherarea_ctx = OtherareaContext()
        self.element_ctx = SearchElementContext()

    # ========== 店铺搜索功能 ==========

    def get_storearea_by_id(self, storearea_id):
        """获取ID为<>的商铺区域的所有信息"""
        storearea = self.storearea_ctx.get_by_id(storearea_id)
        if not storearea:
            return None, {'error': 'Storearea not found'}, status.HTTP_404_NOT_FOUND
        return storearea, None, None

    def search_storearea_by_name(self, name):
        """按名称寻找店铺区域"""
        if not name:
            return None, {'error': 'Name parameter is required'}, status.HTTP_400_BAD_REQUEST
        storeareas = self.storearea_ctx.search_by_name(name)
        return storeareas, None, None

    def list_storearea_by_type(self, type_param):
        """返回指定类型店铺区域列表"""
        if type_param:
            try:
                type_id = int(type_param)
                storeareas = self.storearea_ctx.filter_by_type(type_id=type_id)
                return storeareas, {'type': type_id}, None
            except ValueError:
                return None, {'error': 'Invalid type parameter'}, status.HTTP_400_BAD_REQUEST
        else:
            storeareas = self.storearea_ctx.filter_by_type()
            return storeareas, None, None

    def get_storearea_events(self, storearea_id):
        """返回指定店铺区域的所有活动ID列表"""
        storearea = self.storearea_ctx.get_by_id(storearea_id)
        if not storearea or not storearea.is_active:
            return None, {'error': 'Storearea not found'}, status.HTTP_404_NOT_FOUND

        EventStorearea = apps.get_model('core', 'EventStorearea')
        event_relations = EventStorearea.objects.filter(storearea_id=storearea_id)
        event_ids = [relation.event_id for relation in event_relations]

        return {'storearea_id': storearea_id, 'event_ids': event_ids}, None, None

    def get_storearea_map_ids(self, storearea_id):
        """获取storearea_id为<>的活动区域所属的map_id"""
        storearea_maps = self.storearea_ctx.get_storearea_map_relations(storearea_id)
        map_ids = [storearea_map.map_id for storearea_map in storearea_maps]
        return {'storearea_id': storearea_id, 'map_ids': map_ids}, None, None

    def get_storearea_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且type为<>的所有storearea的id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            storearea_ids = self.element_ctx.get_storearea_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'storearea_ids': storearea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_all_storearea_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有storearea_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            storearea_ids = self.element_ctx.get_storearea_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'storearea_ids': storearea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST

    # ========== 活动搜索功能 ==========

    def get_event_by_id(self, event_id):
        """按ID寻找活动"""
        event = self.event_ctx.get_by_id(event_id)
        if not event:
            return None, {'error': 'Event not found'}, status.HTTP_404_NOT_FOUND
        return event, None, None

    def search_event_by_name(self, name):
        """按名称寻找活动"""
        if not name:
            return None, {'error': 'Name parameter is required'}, status.HTTP_400_BAD_REQUEST
        events = self.event_ctx.search_by_name(name)
        return events, None, None

    def list_event_by_type(self, type_param):
        """返回指定类型活动列表"""
        events = self.event_ctx.filter_active_events()

        if type_param:
            try:
                type_id = int(type_param)
                EventEventarea = apps.get_model('core', 'EventEventarea')
                event_ids = EventEventarea.objects.filter(
                    eventarea__type=type_id
                ).values_list('event_id', flat=True).distinct()

                events = events.filter(id__in=event_ids)
                return events, {'type': type_id}, None
            except ValueError:
                return None, {'error': 'Invalid type parameter'}, status.HTTP_400_BAD_REQUEST
        else:
            return events, None, None

    def get_event_areas(self, event_id):
        """返回参加该活动的区域ID列表"""
        event = self.event_ctx.get_by_id(event_id)
        if not event:
            return None, {'error': 'Event not found'}, status.HTTP_404_NOT_FOUND

        storearea_relations = self.event_ctx.get_event_storearea_relations(event_id)
        storearea_ids = [relation.storearea_id for relation in storearea_relations]

        eventarea_relations = self.event_ctx.get_event_eventarea_relations(event_id)
        eventarea_ids = [relation.eventarea_id for relation in eventarea_relations]

        result = {
            'event_id': event_id,
            'storearea_ids': storearea_ids,
            'eventarea_ids': eventarea_ids,
            'all_area_ids': storearea_ids + eventarea_ids
        }
        return result, None, None

    # ========== 活动区域功能 ==========

    def get_eventarea_by_id(self, eventarea_id):
        """获取id为<>的活动区域的所有信息"""
        eventarea = self.eventarea_ctx.get_by_id(eventarea_id)
        if not eventarea:
            return None, {'error': 'Eventarea not found'}, status.HTTP_404_NOT_FOUND
        return eventarea, None, None

    def get_eventarea_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且 type为<>的所有eventarea的id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            eventarea_ids = self.element_ctx.get_eventarea_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'eventarea_ids': eventarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_eventarea_map_ids(self, eventarea_id):
        """获取eventarea_id为<>的活动区域所属的map_id"""
        eventarea_maps = self.eventarea_ctx.get_eventarea_map_relations(eventarea_id)
        map_ids = [eventarea_map.map_id for eventarea_map in eventarea_maps]
        return {'eventarea_id': eventarea_id, 'map_ids': map_ids}, None, None

    def get_all_eventarea_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有eventarea_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            eventarea_ids = self.element_ctx.get_eventarea_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'eventarea_ids': eventarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST

    # ========== 设施功能 ==========

    def get_facility_by_id(self, facility_id):
        """获取id为<>的设施的所有信息"""
        facility = self.facility_ctx.get_by_id(facility_id)
        if not facility:
            return None, {'error': 'Facility not found'}, status.HTTP_404_NOT_FOUND
        return facility, None, None

    def get_facility_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且type为<>的所有设施id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            facility_ids = self.element_ctx.get_facility_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'facility_ids': facility_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_facility_map_ids(self, facility_id):
        """获取facility_id为<>的活动区域所属的map_id"""
        facility_maps = self.facility_ctx.get_facility_map_relations(facility_id)
        map_ids = [facility_map.map_id for facility_map in facility_maps]
        return {'facility_id': facility_id, 'map_ids': map_ids}, None, None

    def get_all_facility_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有facility_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            facility_ids = self.element_ctx.get_facility_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'facility_ids': facility_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST

    # ========== 其他区域功能 ==========

    def get_otherarea_by_id(self, otherarea_id):
        """获取id为<>的其他区域的所有信息"""
        otherarea = self.otherarea_ctx.get_by_id(otherarea_id)
        if not otherarea:
            return None, {'error': 'Otherarea not found'}, status.HTTP_404_NOT_FOUND
        return otherarea, None, None

    def get_otherarea_ids_by_map_and_type(self, map_id_str, type_param):
        """获取map_id为<> 且type为<>的所有otherarea的id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            type_id = int(type_param) if type_param else None

            otherarea_ids = self.element_ctx.get_otherarea_ids_by_map_and_type(map_id, type_id)

            result = {
                'map_id': map_id,
                'type': type_id if type_param else None,
                'otherarea_ids': otherarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid parameter'}, status.HTTP_400_BAD_REQUEST

    def get_otherarea_map_ids(self, otherarea_id):
        """获取otherarea_id为<>的活动区域所属的map_id"""
        otherarea_maps = self.otherarea_ctx.get_otherarea_map_relations(otherarea_id)
        map_ids = [otherarea_map.map_id for otherarea_map in otherarea_maps]
        return {'otherarea_id': otherarea_id, 'map_ids': map_ids}, None, None

    def get_all_otherarea_ids_by_map(self, map_id_str):
        """获取map_id为<>的地图对应的所有otherarea_id"""
        if not map_id_str:
            return None, {'error': 'map_id parameter is required'}, status.HTTP_400_BAD_REQUEST

        try:
            map_id = int(map_id_str)
            otherarea_ids = self.element_ctx.get_otherarea_ids_by_map_and_type(map_id)

            result = {
                'map_id': map_id,
                'otherarea_ids': otherarea_ids
            }
            return result, None, None
        except ValueError:
            return None, {'error': 'Invalid map_id parameter'}, status.HTTP_400_BAD_REQUEST


================================================================================
文件路径: python-backend\search\tests.py
--------------------------------------------------------------------------------

from django.test import TestCase

# Create your tests here.



================================================================================
文件路径: python-backend\search\urls.py
--------------------------------------------------------------------------------

from django.urls import path
from . import views

urlpatterns = [
    # Search店铺功能
    path('storearea/<int:storearea_id>/', views.storearea_by_id, name='storearea-by-id'),
    path('storearea/search/', views.storearea_search, name='storearea-search'),
    path('storearea/list/', views.storearea_list_by_type, name='storearea-list-by-type'),
    path('storearea/<int:storearea_id>/events/', views.storearea_events, name='storearea-events'),

    # 新增的店铺区域功能
    path('storearea/<int:storearea_id>/map/', views.storearea_map_ids, name='storearea-map-ids'),
    path('storearea/list/map/', views.storearea_ids_by_map_and_type, name='storearea-ids-by-map-type'),
    path('storearea/list/all_by_map/', views.all_storearea_ids_by_map, name='all-storearea-ids-by-map'),

    # Search活动功能
    path('event/<int:event_id>/', views.event_by_id, name='event-by-id'),
    path('event/search/', views.event_search, name='event-search'),
    path('event/list/', views.event_list_by_type, name='event-list-by-type'),
    path('event/<int:event_id>/areas/', views.event_areas, name='event-areas'),

    # 新增的活动区域功能
    path('eventarea/<int:eventarea_id>/', views.eventarea_by_id, name='eventarea-by-id'),
    path('eventarea/list/ids_by_map_type/', views.eventarea_ids_by_map_and_type, name='eventarea-ids-by-map-type'),
    path('eventarea/<int:eventarea_id>/map/', views.eventarea_map_ids, name='eventarea-map-ids'),
    path('eventarea/list/all_by_map/', views.all_eventarea_ids_by_map, name='all-eventarea-ids-by-map'),

    # 新增的设施功能
    path('facility/<int:facility_id>/', views.facility_by_id, name='facility-by-id'),
    path('facility/list/ids_by_map_type/', views.facility_ids_by_map_and_type, name='facility-ids-by-map-type'),
    path('facility/<int:facility_id>/map/', views.facility_map_ids, name='facility-map-ids'),
    path('facility/list/all_by_map/', views.all_facility_ids_by_map, name='all-facility-ids-by-map'),

    # 新增的其他区域功能
    path('otherarea/<int:otherarea_id>/', views.otherarea_by_id, name='otherarea-by-id'),
    path('otherarea/list/ids_by_map_type/', views.otherarea_ids_by_map_and_type, name='otherarea-ids-by-map-type'),
    path('otherarea/<int:otherarea_id>/map/', views.otherarea_map_ids, name='otherarea-map-ids'),
    path('otherarea/list/all_by_map/', views.all_otherarea_ids_by_map, name='all-otherarea-ids-by-map'),
]


================================================================================
文件路径: python-backend\search\views.py
--------------------------------------------------------------------------------

from rest_framework.decorators import api_view
from rest_framework.response import Response
from .services import SearchService
from .serializers import (
    get_storearea_serializer, get_simple_storearea_serializer,
    get_event_serializer, get_simple_event_serializer,
    get_eventarea_serializer, get_simple_eventarea_serializer,
    get_facility_serializer, get_simple_facility_serializer,
    get_otherarea_serializer, get_simple_otherarea_serializer
)

search_service = SearchService()


# ========== 店铺搜索功能 ==========

@api_view(['GET'])
def storearea_by_id(request, storearea_id):
    """获取id为<>的商铺区域的所有信息"""
    result, error, status_code = search_service.get_storearea_by_id(storearea_id)
    if error:
        return Response(error, status=status_code)

    StoreareaSerializer = get_storearea_serializer()
    serializer = StoreareaSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def storearea_search(request):
    """按名称寻找店铺区域"""
    name = request.GET.get('name', '').strip()
    result, error, status_code = search_service.search_storearea_by_name(name)
    if error:
        return Response(error, status=status_code)

    StoreareaSerializer = get_storearea_serializer()
    serializer = StoreareaSerializer(result, many=True)
    return Response(serializer.data)


@api_view(['GET'])
def storearea_list_by_type(request):
    """返回指定类型店铺区域列表"""
    type_param = request.GET.get('type', '').strip()
    result, extra, error = search_service.list_storearea_by_type(type_param)
    if error:
        return Response(error, status=extra)

    if type_param:
        StoreareaSerializer = get_storearea_serializer()
        serializer = StoreareaSerializer(result, many=True)
        response_data = {'type': extra['type'], 'storeareas': serializer.data}
    else:
        categorized = {}
        SimpleStoreareaSerializer = get_simple_storearea_serializer()
        for storearea in result:
            type_key = storearea.type or 0
            if type_key not in categorized:
                categorized[type_key] = []
            serializer = SimpleStoreareaSerializer(storearea)
            categorized[type_key].append(serializer.data)
        response_data = categorized

    return Response(response_data)


@api_view(['GET'])
def storearea_events(request, storearea_id):
    """返回指定店铺区域的所有活动ID列表"""
    result, error, status_code = search_service.get_storearea_events(storearea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def storearea_map_ids(request, storearea_id):
    """获取storearea_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_storearea_map_ids(storearea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def storearea_ids_by_map_and_type(request):
    """获取map_id为<> 且type为<>的所有storearea的id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_storearea_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_storearea_ids_by_map(request):
    """获取map_id为<>的地图对应的所有storearea_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_storearea_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 活动搜索功能 ==========

@api_view(['GET'])
def event_by_id(request, event_id):
    """按ID寻找活动"""
    result, error, status_code = search_service.get_event_by_id(event_id)
    if error:
        return Response(error, status=status_code)

    EventSerializer = get_event_serializer()
    serializer = EventSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def event_search(request):
    """按名称寻找活动"""
    name = request.GET.get('name', '').strip()
    result, error, status_code = search_service.search_event_by_name(name)
    if error:
        return Response(error, status=status_code)

    EventSerializer = get_event_serializer()
    serializer = EventSerializer(result, many=True)
    return Response(serializer.data)


@api_view(['GET'])
def event_list_by_type(request):
    """返回指定类型活动列表"""
    type_param = request.GET.get('type', '').strip()
    result, extra, error = search_service.list_event_by_type(type_param)
    if error:
        return Response(error, status=extra)

    if type_param:
        EventSerializer = get_event_serializer()
        serializer = EventSerializer(result, many=True)
        response_data = {'type': extra['type'], 'events': serializer.data}
    else:
        categorized = {}
        SimpleEventSerializer = get_simple_event_serializer()

        for event in result:
            # 获取该活动关联的所有Eventarea类型
            from django.apps import apps
            EventEventarea = apps.get_model('core', 'EventEventarea')
            eventarea_types = EventEventarea.objects.filter(
                event_id=event.id
            ).values_list('eventarea__type', flat=True).distinct()

            if not eventarea_types:
                type_key = 0
                if type_key not in categorized:
                    categorized[type_key] = []
                serializer = SimpleEventSerializer(event)
                categorized[type_key].append(serializer.data)
            else:
                for eventarea_type in eventarea_types:
                    type_key = eventarea_type or 0
                    if type_key not in categorized:
                        categorized[type_key] = []

                    serializer = SimpleEventSerializer(event)
                    categorized[type_key].append(serializer.data)

        response_data = categorized

    return Response(response_data)


@api_view(['GET'])
def event_areas(request, event_id):
    """返回参加该活动的区域ID列表"""
    result, error, status_code = search_service.get_event_areas(event_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 活动区域功能 ==========

@api_view(['GET'])
def eventarea_by_id(request, eventarea_id):
    """获取id为<>的活动区域的所有信息"""
    result, error, status_code = search_service.get_eventarea_by_id(eventarea_id)
    if error:
        return Response(error, status=status_code)

    EventareaSerializer = get_eventarea_serializer()
    serializer = EventareaSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def eventarea_ids_by_map_and_type(request):
    """获取map_id为<> 且 type为<>的所有eventarea的id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_eventarea_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def eventarea_map_ids(request, eventarea_id):
    """获取eventarea_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_eventarea_map_ids(eventarea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_eventarea_ids_by_map(request):
    """获取map_id为<>的地图对应的所有eventarea_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_eventarea_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 设施功能 ==========

@api_view(['GET'])
def facility_by_id(request, facility_id):
    """获取id为<>的设施的所有信息"""
    result, error, status_code = search_service.get_facility_by_id(facility_id)
    if error:
        return Response(error, status=status_code)

    FacilitySerializer = get_facility_serializer()
    serializer = FacilitySerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def facility_ids_by_map_and_type(request):
    """获取map_id为<> 且type为<>的所有设施id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_facility_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def facility_map_ids(request, facility_id):
    """获取facility_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_facility_map_ids(facility_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_facility_ids_by_map(request):
    """获取map_id为<>的地图对应的所有facility_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_facility_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


# ========== 其他区域功能 ==========

@api_view(['GET'])
def otherarea_by_id(request, otherarea_id):
    """获取id为<>的其他区域的所有信息"""
    result, error, status_code = search_service.get_otherarea_by_id(otherarea_id)
    if error:
        return Response(error, status=status_code)

    OtherareaSerializer = get_otherarea_serializer()
    serializer = OtherareaSerializer(result)
    return Response(serializer.data)


@api_view(['GET'])
def otherarea_ids_by_map_and_type(request):
    """获取map_id为<> 且type为<>的所有otherarea的id"""
    map_id = request.GET.get('map_id', '').strip()
    type_param = request.GET.get('type', '').strip()

    result, error, status_code = search_service.get_otherarea_ids_by_map_and_type(map_id, type_param)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def otherarea_map_ids(request, otherarea_id):
    """获取otherarea_id为<>的活动区域所属的map_id"""
    result, error, status_code = search_service.get_otherarea_map_ids(otherarea_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)


@api_view(['GET'])
def all_otherarea_ids_by_map(request):
    """获取map_id为<>的地图对应的所有otherarea_id"""
    map_id = request.GET.get('map_id', '').strip()

    result, error, status_code = search_service.get_all_otherarea_ids_by_map(map_id)
    if error:
        return Response(error, status=status_code)
    return Response(result)



================================================================================
文件路径: python-backend\search\__init__.py
--------------------------------------------------------------------------------




================================================================================
文件路径: python-backend\search\migrations\__init__.py
--------------------------------------------------------------------------------



