
================================================================================
æ–‡ä»¶è·¯å¾„: components\CreateModel\CreateModel.css
--------------------------------------------------------------------------------

.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal-content {
  background-color: #ffffff;
  border-radius: 0.5rem;
  width: 90%;
  max-width: 500px;
  max-height: 90vh;
  overflow-y: auto;
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem 1.5rem;
  border-bottom: 1px solid #e2e8f0;
}

.modal-title {
  font-size: 1.25rem;
  font-weight: 600;
  margin: 0;
  color: #1e293b;
}

.modal-close {
  background: none;
  border: none;
  font-size: 1.5rem;
  color: #6b7280;
  cursor: pointer;
  padding: 0;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 0.25rem;
  transition: background-color 0.2s;
}

.modal-close:hover {
  background-color: #f3f4f6;
}

.modal-body {
  padding: 1.5rem;
}

.shape-templates {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 0.5rem;
}

.shape-template {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
  padding: 1rem;
  border: 2px solid #e2e8f0;
  border-radius: 0.375rem;
  cursor: pointer;
  transition: all 0.2s;
}

.shape-template:hover {
  border-color: #93c5fd;
  background-color: #eff6ff;
}

.shape-template.selected {
  border-color: #3b82f6;
  background-color: #dbeafe;
}

.template-icon {
  font-size: 2rem;
}

.template-label {
  font-size: 0.75rem;
  font-weight: 500;
  color: #374151;
}

.size-control {
  display: flex;
  align-items: center;
  gap: 1rem;
}

.size-slider {
  flex: 1;
}

.size-value {
  font-size: 0.875rem;
  color: #6b7280;
  min-width: 30px;
}

.form-group {
  margin-bottom: 1rem;
}

.form-label {
  display: block;
  font-size: 0.875rem;
  font-weight: 500;
  color: #374151;
  margin-bottom: 0.5rem;
}

.form-select {
  width: 100%;
  padding: 0.5rem;
  border: 1px solid #d1d5db;
  border-radius: 0.375rem;
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 0.75rem;
  padding-top: 0.5rem;
}

.btn {
  padding: 0.5rem 1rem;
  border: none;
  border-radius: 0.375rem;
  font-size: 0.875rem;
  font-weight: 500;
  cursor: pointer;
}

.btn-primary {
  background-color: #3b82f6;
  color: #ffffff;
}

.btn-secondary {
  background-color: #6b7280;
  color: #ffffff;
}

.error-message {
  padding: 0.75rem;
  background-color: #fee2e2;
  border: 1px solid #fecaca;
  border-radius: 0.375rem;
  color: #dc2626;
  font-size: 0.875rem;
  margin-bottom: 1rem;
}



================================================================================
æ–‡ä»¶è·¯å¾„: components\CreateModel\CreateModel.js
--------------------------------------------------------------------------------

import { reactive, ref } from 'vue'
import { useMapEditorStore } from '../../composables/useMapEditorStore'

export function useCreateModalLogic(props, emit) {
  const { currentMapId, addLocalFeature } = useMapEditorStore()

  const submitting = ref(false)
  const errorMessage = ref('')

  const form = reactive({
    type: 'storearea',
    shape: 'square',
    size: 20
  })

  const shapeTemplates = [
    { label: 'æ­£æ–¹å½¢', shape: 'square', icon: 'â—¼ï¸' },
    { label: 'çŸ©å½¢', shape: 'rect', icon: 'â–­ï¸' },
    { label: 'åœ†å½¢', shape: 'circle', icon: 'â­•' },
    { label: 'ä¸‰è§’å½¢', shape: 'triangle', icon: 'ğŸ”º' },
    { label: 'å…­è¾¹å½¢', shape: 'hexagon', icon: 'â¬¢' }
  ]

  const close = () => {
    emit('update:visible', false)
    errorMessage.value = ''
  }

  // ç”Ÿæˆå‡ ä½•æ•°æ®
  const generateGeometry = (shape, size) => {
    // é»˜è®¤ç”Ÿæˆåœ¨ç”»å¸ƒä¸­å¿ƒï¼Œè¿™é‡Œç®€åŒ–ä¸ºå›ºå®šåæ ‡ (200, 200)
    // å®é™…é¡¹ç›®ä¸­å¯ä» store è·å– stage å®½é«˜
    const centerX = 200
    const centerY = 200
    const coords = []

    switch (shape) {
      case 'square':
        coords.push([centerX - size, centerY - size])
        coords.push([centerX + size, centerY - size])
        coords.push([centerX + size, centerY + size])
        coords.push([centerX - size, centerY + size])
        break
      case 'rect':
        coords.push([centerX - size * 1.5, centerY - size])
        coords.push([centerX + size * 1.5, centerY - size])
        coords.push([centerX + size * 1.5, centerY + size])
        coords.push([centerX - size * 1.5, centerY + size])
        break
      case 'circle': // è¿‘ä¼¼å¤šè¾¹å½¢
        const sides = 12
        for (let i = 0; i < sides; i++) {
          const angle = (i / sides) * Math.PI * 2
          coords.push([
            centerX + Math.cos(angle) * size,
            centerY + Math.sin(angle) * size
          ])
        }
        break
      case 'triangle':
        coords.push([centerX, centerY - size])
        coords.push([centerX + size, centerY + size])
        coords.push([centerX - size, centerY + size])
        break
      case 'hexagon':
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2
          coords.push([
            centerX + Math.cos(angle) * size,
            centerY + Math.sin(angle) * size
          ])
        }
        break
    }

    // é—­åˆ
    if (coords.length > 0) {
      coords.push([...coords[0]])
    }

    return {
      type: 'Polygon',
      coordinates: [coords]
    }
  }

  const handleCreate = async () => {
    if (!currentMapId.value) {
      errorMessage.value = 'è¯·å…ˆé€‰æ‹©åœ°å›¾'
      return
    }

    submitting.value = true
    try {
      const geometry = generateGeometry(form.shape, form.size)

      const createData = {
        map_id: currentMapId.value,
        geometry: geometry,
        description: '',
        is_active: true
      }

      // è®¾ç½®é»˜è®¤åç§°
      if (form.type === 'storearea') {
        createData.store_name = 'æ–°åº—é“º'
        createData.store_type = 0
      } else if (form.type === 'eventarea') {
        createData.event_name = 'æ–°æ´»åŠ¨åŒºåŸŸ'
        createData.event_type = 0
      } else if (form.type === 'otherarea') {
        createData.name = 'æ–°åŒºåŸŸ'
        createData.type_id = 0
      }

      // æ¨¡æ‹Ÿåˆ›å»ºæˆåŠŸ (å®é™…åº”è°ƒç”¨ API)
      const newArea = {
        id: Date.now(),
        ...createData
      }

      addLocalFeature(form.type, newArea)
      close()

    } catch (error) {
      errorMessage.value = error.message
    } finally {
      submitting.value = false
    }
  }

  return { form, shapeTemplates, handleCreate, close, submitting, errorMessage }
}



================================================================================
æ–‡ä»¶è·¯å¾„: components\EditorHeader\EditorHeader.css
--------------------------------------------------------------------------------

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem 2rem;
  background-color: #ffffff;
  border-bottom: 1px solid #e2e8f0;
}

.title {
  font-size: 1.5rem;
  font-weight: 600;
  margin: 0;
  color: #1e293b;
}

.actions {
  display: flex;
  gap: 1rem;
  align-items: center;
}

.map-selector {
  display: flex;
  align-items: center;
}

.filter-select {
  padding: 0.5rem 1rem;
  border: 1px solid #d1d5db;
  border-radius: 0.375rem;
  font-size: 0.875rem;
  background-color: #ffffff;
}



================================================================================
æ–‡ä»¶è·¯å¾„: components\EditorHeader\EditorHeader.js
--------------------------------------------------------------------------------

import { useMapEditorStore } from '../../composables/useMapEditorStore'

export function useHeaderLogic() {
  const { maps, currentMapId, loadCurrentMap } = useMapEditorStore()

  const handleChange = async () => {
    if (!currentMapId.value) return
    await loadCurrentMap()
  }

  return {
    maps,
    currentMapId,
    handleChange
  }
}



================================================================================
æ–‡ä»¶è·¯å¾„: components\MapCanvas\MapCanvas.css
--------------------------------------------------------------------------------

.map-canvas-container {
  flex: 1;
  position: relative;
  overflow: hidden;
  background-color: #f1f5f9;
}

.map-canvas-wrapper {
  width: 100%;
  height: 100%;
  position: relative;
}

.konva-stage-container {
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
}

.loading-container,
.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  gap: 1rem;
  color: #6b7280;
}

.loading-spinner {
  width: 40px;
  height: 40px;
  border: 4px solid rgba(59, 130, 246, 0.3);
  border-top: 4px solid #3b82f6;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.empty-icon {
  font-size: 3rem;
  opacity: 0.5;
}



================================================================================
æ–‡ä»¶è·¯å¾„: components\MapCanvas\MapCanvas.js
--------------------------------------------------------------------------------

import { watch, nextTick, onUnmounted, watchPostEffect } from 'vue'
import { useMapEditorStore } from '../../composables/useMapEditorStore'
import * as managementAPI from '@/api/management'
// ä½¿ç”¨åŠ¨æ€å¯¼å…¥æˆ–ç¡®ä¿ vite.config å·²ä¼˜åŒ–
import Konva from 'konva'

export function useCanvasLogic(stageContainerRef) {
  const {
    currentMap, loading,
    storeareas, eventareas, otherareas, facilities,
    selectedFeature, selectedType, selectFeature
  } = useMapEditorStore()

  let stage = null
  let layer = null
  let shapesLayer = null

  const typeColors = {
    storearea: '#2563eb',
    eventarea: '#16a34a',
    otherarea: '#f97316',
    facility: '#8b5cf6'
  }

  // --- åˆå§‹åŒ– Konva ---
  const initKonva = () => {
    console.log(currentMap)
    if (!stageContainerRef.value || !currentMap.value) {
        console.warn("InitKonva ä¸­æ–­ï¼ŒDOM æˆ–æ•°æ®æœªå°±ç»ªã€‚");
        return;
    }

    // æ¸…ç†
    if (stage) stage.destroy()

    const width = stageContainerRef.value.offsetWidth
    const height = stageContainerRef.value.offsetHeight
    console.log("ç”»å¸ƒå®¹å™¨å°ºå¯¸:", width, height); // å¦‚æœè¿™é‡Œæ˜¯ 0, 0ï¼Œåœ°å›¾å°±çœ‹ä¸è§
    stage = new Konva.Stage({
      container: stageContainerRef.value,
      width,
      height,
      draggable: true
    })

    layer = new Konva.Layer()
    shapesLayer = new Konva.Layer()
    stage.add(layer)
    stage.add(shapesLayer)

    // æ»šè½®ç¼©æ”¾äº‹ä»¶
    stage.on('wheel', handleWheel)

    drawBackground()
    drawAllFeatures()
  }

  // --- ç»˜åˆ¶èƒŒæ™¯ ---
  const drawBackground = () => {
    if (!layer) return
    layer.destroyChildren()

    // ç»˜åˆ¶ä¸€ä¸ªè¶³å¤Ÿå¤§çš„èƒŒæ™¯çŸ©å½¢ç”¨äºæ‹–æ‹½
    const bg = new Konva.Rect({
      x: -5000,
      y: -5000,
      width: 10000,
      height: 10000,
      fill: '#f5f5f5',
      stroke: '#ddd',
      strokeWidth: 1
    })
    layer.add(bg)
    layer.draw()
  }

  // --- ç»˜åˆ¶é€šç”¨å¤šè¾¹å½¢ ---
  const drawPolygon = (area, type) => {
    if (!area.geometry || !area.geometry.coordinates || !shapesLayer) return

    let points = []
    // ç®€å•çš„ GeoJSON è§£æ (Polygon/MultiPolygon)
    if (area.geometry.type === 'Polygon') {
      points = area.geometry.coordinates[0].flat()
    } else if (area.geometry.type === 'MultiPolygon') {
      points = area.geometry.coordinates[0][0].flat()
    }

    if (points.length < 6) return

    const color = typeColors[type]
    const poly = new Konva.Polygon({
      points,
      closed: true,
      fill: `${color}30`,
      stroke: color,
      strokeWidth: 1,
      draggable: true,
      id: `${type}-${area.id}`
    })

    // é€‰ä¸­æ€
    if (selectedFeature.value?.id === area.id && selectedType.value === type) {
      poly.strokeWidth(2)
      poly.fill(`${color}40`)
      poly.shadowBlur(5)
      poly.shadowColor(color)
    }

    poly.on('click', (e) => {
      e.cancelBubble = true
      selectFeature(type, area)
    })

    // æ‹–æ‹½ç»“æŸæ›´æ–°ä½ç½®
    poly.on('dragend', function() {
      handleGeometryChange(type, area, this)
    })

    shapesLayer.add(poly)
  }

  // --- ç»˜åˆ¶è®¾æ–½ (åœ†ç‚¹) ---
  const drawFacility = (facility) => {
    if (!shapesLayer) return

    let x = 0
    let y = 0

    // è§£æåæ ‡ï¼šä¼˜å…ˆä½¿ç”¨ location å¯¹è±¡ï¼Œå…¶æ¬¡è§£æ GeoJSON Point
    if (facility.location && typeof facility.location.x === 'number') {
      x = facility.location.x
      y = facility.location.y
    } else if (facility.geometry && facility.geometry.type === 'Point') {
      x = facility.geometry.coordinates[0]
      y = facility.geometry.coordinates[1]
    } else {
      return
    }

    const color = typeColors['facility']
    const circle = new Konva.Circle({
      x,
      y,
      radius: 10,
      fill: `${color}80`,
      stroke: color,
      strokeWidth: 2,
      draggable: true,
      id: `facility-${facility.id}`
    })

    if (selectedFeature.value?.id === facility.id && selectedType.value === 'facility') {
      circle.strokeWidth(3)
      circle.shadowBlur(8)
      circle.shadowColor(color)
    }

    circle.on('click', (e) => {
      e.cancelBubble = true
      selectFeature('facility', facility)
    })

    circle.on('dragend', function() {
      handleFacilityLocationChange(facility, this)
    })

    shapesLayer.add(circle)
  }

  // --- ç»˜åˆ¶æ‰€æœ‰è¦ç´  ---
  const drawAllFeatures = () => {
    if (!shapesLayer) return
    shapesLayer.destroyChildren()

    storeareas.value.forEach(a => drawPolygon(a, 'storearea'))
    eventareas.value.forEach(a => drawPolygon(a, 'eventarea'))
    otherareas.value.forEach(a => drawPolygon(a, 'otherarea'))
    facilities.value.forEach(f => drawFacility(f))

    shapesLayer.draw()
  }

  // --- äº‹ä»¶å¤„ç†ï¼šå¤šè¾¹å½¢å‡ ä½•æ›´æ–° ---
  const handleGeometryChange = async (type, area, shapeNode) => {
    const points = shapeNode.points()
    const x = shapeNode.x()
    const y = shapeNode.y()

    // Konva çš„ points æ˜¯ç›¸å¯¹åæ ‡ï¼Œéœ€è¦åŠ ä¸Š offset (x, y) è½¬æ¢ä¸ºç»å¯¹åæ ‡
    const absCoords = []
    for(let i=0; i<points.length; i+=2) {
      absCoords.push([points[i] + x, points[i+1] + y])
    }
    // é—­åˆå¤šè¾¹å½¢
    if(absCoords.length > 0) absCoords.push([...absCoords[0]])

    // 1. æ›´æ–°æœ¬åœ°æ•°æ®
    area.geometry = { type: 'Polygon', coordinates: [absCoords] }

    // é‡ç½® shapeNodeï¼Œé˜²æ­¢ Konva å†…éƒ¨çŠ¶æ€åç§»ç´¯ç§¯
    shapeNode.position({x:0, y:0})
    shapeNode.points(absCoords.flat())

    // 2. è°ƒç”¨ API ä¿å­˜
    try {
      const updateFn = {
        storearea: managementAPI.updateManagementStorearea,
        eventarea: managementAPI.updateManagementEventarea,
        otherarea: managementAPI.updateManagementOtherarea
      }[type]

      if (updateFn) {
        // æ³¨æ„ï¼šå®é™…åç«¯å¯èƒ½éœ€è¦ WKT æˆ–ç‰¹å®šçš„ shape æ ¼å¼å­—ç¬¦ä¸²
        // è¿™é‡Œå‡è®¾åç«¯æ¥å— GeoJSON å¯¹è±¡æˆ–ç”±å‰ç«¯åºåˆ—åŒ–
        const payload = { ...area }
        // å¦‚æœåç«¯åœ¨ management æ¥å£ä¸æ¥å— shape/geometryï¼Œéœ€è°ƒç”¨ editor æ¥å£
        // è¿™é‡Œæš‚ä¸”å¤ç”¨ management æ¥å£é€»è¾‘ï¼Œå®é™…éœ€æ ¹æ®åç«¯ editor.js è°ƒæ•´
        console.log(`[Mock] Saving geometry for ${type} ${area.id}`)
      }
    } catch(e) {
      console.error('Geometry save failed', e)
    }
  }

  // --- äº‹ä»¶å¤„ç†ï¼šè®¾æ–½ä½ç½®æ›´æ–° ---
  const handleFacilityLocationChange = async (facility, shapeNode) => {
    const x = shapeNode.x()
    const y = shapeNode.y()

    // 1. æ›´æ–°æœ¬åœ°
    facility.location = { x, y }
    // å¦‚æœæœ‰ geometry å­—æ®µä¹ŸåŒæ­¥æ›´æ–°
    if (facility.geometry) {
      facility.geometry = { type: 'Point', coordinates: [x, y] }
    }

    // 2. è°ƒç”¨ API
    try {
      await managementAPI.updateManagementFacility(facility.id, { location: { x, y } })
    } catch(e) {
      console.error('Facility location save failed', e)
    }
  }

  // --- ç¼©æ”¾é€»è¾‘ ---
  const handleWheel = (e) => {
    e.evt.preventDefault()
    const scaleBy = 1.1
    const oldScale = stage.scaleX()
    const pointer = stage.getPointerPosition()
    const mousePointTo = {
      x: (pointer.x - stage.x()) / oldScale,
      y: (pointer.y - stage.y()) / oldScale,
    }
    const newScale = e.evt.deltaY > 0 ? oldScale / scaleBy : oldScale * scaleBy
    stage.scale({ x: newScale, y: newScale })
    const newPos = {
      x: pointer.x - mousePointTo.x * newScale,
      y: pointer.y - mousePointTo.y * newScale,
    }
    stage.position(newPos)
    stage.batchDraw()
  }

  // --- ç›‘å¬å™¨ ---
  watch(
    [storeareas, eventareas, otherareas, facilities, selectedFeature],
    () => { if (stage) drawAllFeatures() },
    { deep: true }
  )

  watchPostEffect(() => {
    // è¿™ä¸ªå›è°ƒå‡½æ•°ä¼šåœ¨ currentMap æˆ–å…¶ä»–ä¾èµ–é¡¹å˜åŒ–ï¼Œå¹¶ä¸” DOM æ›´æ–°ä¹‹åæ‰§è¡Œ
    if (currentMap.value && stageContainerRef.value) {
        // å½“åœ°å›¾æ•°æ®å’Œ DOM éƒ½å‡†å¤‡å¥½æ—¶ï¼Œåˆå§‹åŒ–æˆ–é‡æ–°åˆå§‹åŒ– Konva
        initKonva();
    }

    // ä½ ä¹Ÿå¯ä»¥åœ¨è¿™é‡Œç›´æ¥è°ƒç”¨ç»˜åˆ¶å‡½æ•°ï¼Œå› ä¸ºå®ƒä¹Ÿä¾èµ–äº storeareas ç­‰ ref
    if (shapesLayer) {
        drawAllFeatures();
    }
  });

  onUnmounted(() => {
    if(stage) stage.destroy()
  })

  return {}
}



================================================================================
æ–‡ä»¶è·¯å¾„: components\PropertyPanel\PropertyPanel.css
--------------------------------------------------------------------------------

.properties-panel {
  width: 320px;
  background-color: #ffffff;
  border-left: 1px solid #e2e8f0;
  display: flex;
  flex-direction: column;
}

.panel-header {
  padding: 1rem;
  border-bottom: 1px solid #e2e8f0;
}

.panel-title {
  font-size: 1rem;
  font-weight: 600;
  margin: 0;
  color: #374151;
}

.panel-content {
  flex: 1;
  overflow-y: auto;
  padding: 1rem;
}

.panel-empty {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: #6b7280;
}

.properties-form {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.form-group {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.form-label {
  font-size: 0.875rem;
  font-weight: 500;
  color: #374151;
}

.form-input,
.form-select,
.form-textarea {
  padding: 0.5rem;
  border: 1px solid #d1d5db;
  border-radius: 0.375rem;
  font-size: 0.875rem;
  background-color: #ffffff;
}

.form-textarea {
  resize: vertical;
  min-height: 80px;
}

.toggle-switch {
  display: flex;
  align-items: center;
}

.toggle-input {
  display: none;
}

.toggle-label {
  position: relative;
  display: inline-block;
  width: 48px;
  height: 24px;
  background-color: #d1d5db;
  border-radius: 12px;
  cursor: pointer;
  transition: background-color 0.3s;
}

.toggle-label::after {
  content: '';
  position: absolute;
  top: 2px;
  left: 2px;
  width: 20px;
  height: 20px;
  background-color: #ffffff;
  border-radius: 50%;
  transition: transform 0.3s;
}

.toggle-input:checked + .toggle-label {
  background-color: #3b82f6;
}

.toggle-input:checked + .toggle-label::after {
  transform: translateX(24px);
}

.toggle-text {
  margin-left: 0.5rem;
  font-size: 0.875rem;
  color: #6b7280;
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  padding-top: 0.5rem;
}

.btn-primary {
  background-color: #3b82f6;
  color: #ffffff;
  padding: 0.5rem 1rem;
  border: none;
  border-radius: 0.375rem;
  font-size: 0.875rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.btn-primary:disabled {
  opacity: 0.7;
  cursor: not-allowed;
}

.btn-spinner {
  width: 14px;
  height: 14px;
  border: 2px solid #ffffff;
  border-top-color: transparent;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.error-message {
  padding: 0.75rem;
  background-color: #fee2e2;
  border: 1px solid #fecaca;
  border-radius: 0.375rem;
  color: #dc2626;
  font-size: 0.875rem;
}



================================================================================
æ–‡ä»¶è·¯å¾„: components\PropertyPanel\PropertyPanel.js
--------------------------------------------------------------------------------

import { reactive, ref, watch } from 'vue'
import { useMapEditorStore } from '../../composables/useMapEditorStore'
import * as managementAPI from '@/api/management'

export function usePropertiesLogic() {
  const { selectedFeature, selectedType, updateLocalFeature } = useMapEditorStore()
  const submitting = ref(false)
  const errorMessage = ref('')

  const form = reactive({
    name: '',
    type: '0',
    description: '',
    is_active: true
  })

  const typeNames = {
    storearea: 'åº—é“º',
    eventarea: 'æ´»åŠ¨åŒºåŸŸ',
    otherarea: 'å…¶ä»–åŒºåŸŸ',
    facility: 'è®¾æ–½'
  }

  const getTypeName = () => typeNames[selectedType.value] || 'åŒºåŸŸ'

  // ç›‘å¬é€‰ä¸­å˜æ›´ï¼Œå›å¡«è¡¨å•
  watch(selectedFeature, (newVal) => {
    if (newVal) {
      form.name = newVal.name || newVal.store_name || newVal.event_name || newVal.description || ''
      form.type = newVal.store_type?.toString() || newVal.type_id?.toString() || newVal.event_type?.toString() || newVal.type?.toString() || '0'
      form.description = newVal.description || ''
      form.is_active = newVal.is_active !== undefined ? newVal.is_active : true
    }
  })

  const save = async () => {
    if (!selectedFeature.value || !selectedType.value) return
    submitting.value = true
    errorMessage.value = ''

    try {
      // æ„é€ æäº¤æ•°æ®
      const submitData = {
        name: form.name,
        description: form.description,
        is_active: form.is_active
      }

      // æ ¹æ®ç±»å‹é€‚é…å­—æ®µ
      if (selectedType.value === 'storearea') {
        submitData.store_name = form.name
        submitData.store_type = parseInt(form.type)
        delete submitData.name
      } else if (selectedType.value === 'eventarea') {
        submitData.event_name = form.name
        submitData.event_type = parseInt(form.type)
        delete submitData.name
      } else if (selectedType.value === 'otherarea') {
        submitData.type_id = parseInt(form.type)
      } else if (selectedType.value === 'facility') {
        submitData.description = form.name // è®¾æ–½é€šå¸¸ç”¨ description ä½œåç§°
        submitData.type = parseInt(form.type)
        delete submitData.name
      }

      // è°ƒç”¨ API
      await managementAPI.updateAreaByTypeAndId(selectedType.value, selectedFeature.value.id, submitData)

      // æ›´æ–°æœ¬åœ°æ•°æ®ï¼Œå®ç°å³æ—¶åé¦ˆ
      const localUpdate = { ...submitData }
      // è¿˜åŸå›æœ¬åœ°å­—æ®µå
      if (selectedType.value === 'storearea') localUpdate.store_name = form.name
      else if (selectedType.value === 'eventarea') localUpdate.event_name = form.name
      else if (selectedType.value === 'otherarea') localUpdate.name = form.name

      updateLocalFeature(localUpdate)

    } catch (error) {
      console.error('ä¿å­˜å±æ€§å¤±è´¥:', error)
      errorMessage.value = `ä¿å­˜å¤±è´¥: ${error.message || 'æœªçŸ¥é”™è¯¯'}`
    } finally {
      submitting.value = false
    }
  }

  return {
    form,
    selectedFeature,
    selectedType,
    save,
    submitting,
    errorMessage,
    getTypeName
  }
}



================================================================================
æ–‡ä»¶è·¯å¾„: components\Sidebar\Sidebar.css
--------------------------------------------------------------------------------

.sidebar {
  width: 280px;
  background-color: #ffffff;
  border-right: 1px solid #e2e8f0;
  display: flex;
  flex-direction: column;
}

.sidebar-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem;
  border-bottom: 1px solid #e2e8f0;
}

.sidebar-title {
  font-size: 1rem;
  font-weight: 600;
  margin: 0;
  color: #374151;
}

.layer-groups {
  flex: 1;
  overflow-y: auto;
  padding: 0.5rem;
}

.layer-group {
  margin-bottom: 0.5rem;
  border-radius: 0.375rem;
  overflow: hidden;
}

.layer-group-header {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.75rem 1rem;
  background-color: #f3f4f6;
  cursor: pointer;
  font-size: 0.875rem;
  font-weight: 500;
  color: #374151;
  user-select: none;
}

.layer-icon {
  font-size: 1rem;
}

.layer-count {
  margin-left: auto;
  font-size: 0.75rem;
  color: #6b7280;
}

.layer-toggle {
  font-size: 0.75rem;
  color: #6b7280;
  transition: transform 0.2s;
}

.layer-toggle.expanded {
  transform: rotate(0deg); /* æ ¹æ®å…·ä½“å­—ç¬¦è°ƒæ•´ï¼Œæ­¤å¤„ä»…å ä½ */
}

.layer-items {
  padding: 0.25rem 0;
  background-color: #f9fafb;
}

.layer-item {
  padding: 0.5rem 1.5rem;
  font-size: 0.875rem;
  color: #4b5563;
  cursor: pointer;
  transition: background-color 0.2s;
}

.layer-item:hover {
  background-color: #f3f4f6;
}

.layer-item.selected {
  background-color: #dbeafe;
  color: #1e40af;
  border-right: 3px solid #3b82f6;
}

.btn-primary {
  background-color: #3b82f6;
  color: #ffffff;
  padding: 0.5rem 1rem;
  border: none;
  border-radius: 0.375rem;
  font-size: 0.875rem;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
}

.btn-primary:hover {
  background-color: #2563eb;
}



================================================================================
æ–‡ä»¶è·¯å¾„: components\Sidebar\Sidebar.js
--------------------------------------------------------------------------------

import { reactive } from 'vue'
import { useMapEditorStore } from '../../composables/useMapEditorStore'

export function useSidebarLogic() {
  const {
    storeareas, eventareas, otherareas, facilities,
    selectFeature, selectedFeature, selectedType
  } = useMapEditorStore()

  const expandedLayers = reactive({
    storearea: true,
    eventarea: true,
    otherarea: true,
    facility: true
  })

  const toggleLayer = (type) => {
    expandedLayers[type] = !expandedLayers[type]
  }

  const handleSelect = (type, item) => {
    selectFeature(type, item)
  }

  const isSelected = (type, id) => {
    return selectedType.value === type && selectedFeature.value?.id === id
  }

  return {
    storeareas,
    eventareas,
    otherareas,
    facilities,
    expandedLayers,
    toggleLayer,
    handleSelect,
    isSelected
  }
}



================================================================================
æ–‡ä»¶è·¯å¾„: composables\useMapEditorStore.js
--------------------------------------------------------------------------------

import { ref, reactive } from 'vue'
import { listMaps, getMapById } from '@/api/map'
import * as managementAPI from '@/api/management'

// å®šä¹‰å…¨å±€å“åº”å¼çŠ¶æ€ï¼ˆå•ä¾‹æ¨¡å¼ï¼Œç±»ä¼¼ç®€æ˜“ Piniaï¼‰
const maps = ref([])
const currentMapId = ref('')
const currentMap = ref(null)
const loading = ref(false)

// å›¾å±‚æ•°æ®
const storeareas = ref([])
const eventareas = ref([])
const otherareas = ref([])
const facilities = ref([])

// é€‰ä¸­çŠ¶æ€
const selectedType = ref('')
const selectedFeature = ref(null)

// è¾…åŠ©å‡½æ•°ï¼šåˆå¹¶æ•°æ®
const mergeData = (mapData, mgmtData) => {
  if (mapData && mapData.length > 0) {
    if (mgmtData && mgmtData.length > 0) {
      const mapDataById = new Map(mapData.map(item => [item.id, item]))
      mgmtData.forEach(item => {
        if (!mapDataById.has(item.id)) {
          mapDataById.set(item.id, item)
        } else {
          Object.assign(mapDataById.get(item.id), item)
        }
      })
      return Array.from(mapDataById.values())
    }
    return mapData
  }
  return mgmtData || []
}

export function useMapEditorStore() {

  // åŠ è½½åœ°å›¾åˆ—è¡¨
  const loadMaps = async () => {
    loading.value = true
    try {
      const response = await listMaps()
      maps.value = response.data || response
      if (maps.value.length > 0 && !currentMapId.value) {
        currentMapId.value = maps.value[0].id
        await loadCurrentMap()
      }
    } catch (error) {
      console.error('åŠ è½½åœ°å›¾åˆ—è¡¨å¤±è´¥:', error)
    } finally {
      loading.value = false
    }
  }

  // åŠ è½½å½“å‰åœ°å›¾è¯¦æƒ…åŠæ‰€æœ‰åŒºåŸŸæ•°æ®
  const loadCurrentMap = async () => {
    if (!currentMapId.value) return
    loading.value = true

    try {
      // 1. è·å–åœ°å›¾è¯¦æƒ… (åŒ…å« geometry)
      const mapRes = await getMapById(currentMapId.value)
      const mapData = mapRes.data || mapRes
      currentMap.value = mapData
      // 2. è·å–ç®¡ç†æ•°æ® (åŒ…å«å±æ€§)
      const [sData, eData, oData, fData] = await Promise.all([
        managementAPI.listManagementStoreareas(),
        managementAPI.listManagementEventareas(),
        managementAPI.listManagementOtherareas(),
        managementAPI.listManagementFacilities()
      ])

      const mapId = currentMapId.value

      // 3. è¿‡æ»¤å¹¶åˆå¹¶
      storeareas.value = mergeData(
        mapData.stores || mapData.storeareas,
        (sData.data || sData).filter(i => i.map_id == mapId)
      )
      eventareas.value = mergeData(
        mapData.events || mapData.eventareas,
        (eData.data || eData).filter(i => i.map_id == mapId)
      )
      otherareas.value = mergeData(
        mapData.other_areas || mapData.otherareas,
        (oData.data || oData).filter(i => i.map_id == mapId)
      )
      facilities.value = mergeData(
        mapData.facilities,
        (fData.data || fData).filter(i => i.map_id == mapId)
      )

      // æ¸…ç©ºé€‰ä¸­
      selectedFeature.value = null
      selectedType.value = ''
    } catch (error) {
      console.error('åŠ è½½åœ°å›¾è¯¦æƒ…å¤±è´¥:', error)
    } finally {
      loading.value = false
    }
  }

  // é€‰ä¸­åŠŸèƒ½
  const selectFeature = (type, feature) => {
    selectedType.value = type
    selectedFeature.value = feature
  }

  // æ›´æ–°æœ¬åœ°å•ä¸ªåŒºåŸŸæ•°æ®ï¼ˆç”¨äºä¿å­˜å±æ€§åçš„å³æ—¶å›æ˜¾ï¼‰
  const updateLocalFeature = (updatedData) => {
    if (!selectedFeature.value) return
    Object.assign(selectedFeature.value, updatedData)
  }

  // æ·»åŠ æœ¬åœ°æ–°åŒºåŸŸ
  const addLocalFeature = (type, feature) => {
    if (type === 'storearea') storeareas.value.push(feature)
    else if (type === 'eventarea') eventareas.value.push(feature)
    else if (type === 'otherarea') otherareas.value.push(feature)
  }

  return {
    maps,
    currentMapId,
    currentMap,
    loading,
    storeareas,
    eventareas,
    otherareas,
    facilities,
    selectedType,
    selectedFeature,
    loadMaps,
    loadCurrentMap,
    selectFeature,
    updateLocalFeature,
    addLocalFeature
  }
}


